'
'
' ####################
' #####  PROLOG  #####
' ####################
'
' This example uses the fpu instruction fldpi
' to return the value of pi from a function.
' Then the address of this DOUBLE value is
' analyzed to show the binary components of
' a 64-bit real floating point number.
'
'PROGRAM	"fldpi"
VERSION	"0.0001"
CONSOLE

' create a LONGDOUBLE type of 10 bytes (80 bits)
'PACKED LONGDOUBLE
'	UBYTE .ld[9]
'END TYPE

'TYPE LONGDOUBLE
'	DOUBLE .dld
'	ULONG	.uld
'END TYPE

'	IMPORT	"xst"   ' Standard library : required by most programs
' IMPORT  "xma"

DECLARE FUNCTION  Entry ()
DECLARE FUNCTION  DOUBLE Pi ()
'
'
' ######################
' #####  Entry ()  #####
' ######################
'
FUNCTION  Entry ()

' The IEEE Standard for Binary Floating-Point Arithmetic
' defines binary formats for single and double precision numbers.
' Each number is composed of three parts:
' a sign bit (s), an exponent (E) and a fraction (f).
' The numerical value of the combination (s,E,f) is given by
' the following formula,

' (-1)^s (1.fffff...) 2^E

	DOUBLE x, pi, f
	UBYTE dbl[]

	x = Pi ()
	PRINT "pi ="; x

' what is exactly shown in memory for pi
	addrX = &x

' DOUBLE type is 8 bytes
	DIM dbl[7]
	FOR i = 0 TO 7
		dbl[i] = UBYTEAT(addrX + i)
		PRINT HEX$ (dbl[i]),
	NEXT i

  PRINT

' All real numbers are stored in memory with
' the least significant bytes first.

' reverse byte order and assemble binary string
	FOR i = 7 TO 0 STEP -1
		PRINT HEX$ (dbl[i]),
		b$ = b$ + BIN$ (dbl[i], 8)
	NEXT i

  PRINT

  PRINT b$

	s$ = MID$ (b$, 1, 1)
	e$ = MID$ (b$, 2, 11)
	f$ = MID$ (b$, 13, 52)

  PRINT "sign bit      (   63):"; s$
  PRINT "exponent bits (62-52):"; e$
  PRINT "fraction bits (51- 0):"; f$

' For 64-bit real numbers, the bias of the 11 exponent's bits is 3FFh
' (the last 10 bits). The maximum value of 7FFh in the exponent field
' is reserved for NANs.

' The value of 0 in the exponent field is also reserved for a special
' category of numbers. When all bits in the significand field are also 0,
' the value of the real number would be equal to 0. If any of the bits in
' the significand field are set, the value is then called a "denormalized"
' real number.

' Because a valid number in real format must always start with a 1,
' the first bit of the number is implied and the significand field only
' contains the fraction bits f1, f2, etc. A

' Whenever all the bits are set to 1 in the exponent field of a real
' number format, the value is designated as a NAN (Not-A-Number).
' Two values in that category are generated by the FPU:
' INFINITY and INDEFINITE.

' So let's see if we can convert the three binary parts to a
' real decimal value (pi)

' exponent bits: convert binary string and subtract bias
	exp = XLONG ("0b" + e$) - 0x3FF
	PRINT "exp ="; exp

' fraction bits: convert decimal binary to decimal base 10
	upp = LEN (f$) - 1
	FOR i = 0 TO upp
		b = f${i}
		IF b = '1' THEN
			f = f + 1.0/(2.0 ** (i+1))
		END IF
	NEXT i
	PRINT "f ="; f

	pi = (1.0 + f) * (2 ** exp)

' sign bit: if bit is 0 then positive, if bit is 1, then negative
	IF s${0} = '1' THEN pi = -1 * pi

	PRINT "pi ="; pi

	PRINT
	a$ = INLINE$ ("Press any key to quit >")

END FUNCTION
'
'
' ###################
' #####  Pi ()  #####
' ###################
'
FUNCTION  DOUBLE Pi ()

' example of loading a 80-bit extended precision real
' and returning it as a DOUBLE

ASM 	fldpi											; load pi into st(0)
ASM		jmp			end.Pi.fldpi			; return with pi in st(0)

END FUNCTION
END PROGRAM
