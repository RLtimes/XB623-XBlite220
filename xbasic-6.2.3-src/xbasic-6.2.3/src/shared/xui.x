'
'
' ####################  Max Reason
' #####  PROLOG  #####  copyright 1988-2000
' ####################  XBasic GuiDesigner function library
'
' subject to LGPL license - see COPYING_LIB
'
' maxreason@maxreason.com
'
' for Windows XBasic
' for Linux XBasic
'
'
PROGRAM	"xui"
VERSION	"0.1176"
'
IMPORT	"xma"
IMPORT	"xst"
IMPORT	"xgr"
IMPORT	"xlib"
IMPORT	"kernel32"
IMPORT	"xut"
'
TYPE GRID												' bytes
	XLONG				.grid							'   4
	XLONG				.gridType					'   4
	XLONG				.gridFunc					'   4
	XLONG				.gridWindow				'   4
	XLONG				.window						'   4
	XLONG				.parent						'   4
	XLONG				.cursor						'   4
	XLONG				.clip							'   4 = 32
	XLONG				.image						'   4
	XLONG				.imageAlign				'   4
	XLONG				.imageIndentX			'   4
	XLONG				.imageIndentY			'   4
	XLONG				.imageStartX			'   4
	XLONG				.imageStartY			'   4
	XLONG				.imageWidth				'   4
	XLONG				.imageHeight			'   4 = 64
	XLONG				.x								'   4					' parent origin = 0,0
	XLONG				.y								'   4					' parent origin = 0,0
	XLONG				.width						'   4
	XLONG				.height						'   4
	XLONG				.maxWidth					'   4
	XLONG				.maxHeight				'   4
	XLONG				.minWidth					'   4
	XLONG				.minHeight				'   4 = 96
	XLONG				.focusBackground	'   4
	XLONG				.focusDrawing			'   4
	XLONG				.focusLowlight		'   4
	XLONG				.focusHighlight		'   4
	XLONG				.focusDull				'   4
	XLONG				.focusAccent			'   4
	XLONG				.focusLowtext			'   4
	XLONG				.focusHightext		'   4 = 128
	XLONG				.backgroundColor	'   4
	XLONG				.drawingColor			'   4
	XLONG				.lowlightColor		'   4
	XLONG				.highlightColor		'   4
	XLONG				.dullColor				'   4
	XLONG				.accentColor			'   4
	XLONG				.lowtextColor			'   4
	XLONG				.hightextColor		'   4 = 160
	XLONG				.cursorX					'   4
	XLONG				.cursorY					'   4
	XLONG				.cursorPos				'   4
	XLONG				.cursorLine				'   4
	XLONG				.left							'   4
	XLONG				.top							'   4
	XLONG				.right						'   4
	XLONG				.bottom						'   4 = 192
	XLONG				.redrawFlags			'   4
	XLONG				.buffer						'   4
	XLONG				.timer						'   4
	XLONG				.font							'   4
	XLONG				.indentLeft				'   4
	XLONG				.indentTop				'   4
	XLONG				.indentRight			'   4
	XLONG				.indentBottom			'   4 = 224
	XLONG				.style						'   4 = 228
	XLONG				.styleMax					'   4 = 232
	SBYTE				.xgap							'   1
	SBYTE				.ygap							'   1
	UBYTE				.zzz							'   1
	UBYTE				.group						'   1
	UBYTE				.align						'   1
	UBYTE				.justify					'   1
	UBYTE				.texture					'   1
	UBYTE				.tabWidth					'   1
	UBYTE				.border						'   1
	UBYTE				.borderUp					'   1
	UBYTE				.borderDown				'   1
	UBYTE				.borderFlags			'   1 = 240
	UBYTE				.can							'   1   can... focus, respond, callback, inputTextArray, inputTextString...
	UBYTE				.kind							'   1   code function (not a visible grid but probably controls one or more)
	UBYTE				.focus						'   1   current focus state  (have it / don't)
	UBYTE				.focusKid					'   1   kid # that gets focus
	UBYTE				.inputTextArray		'   1   kid # that can input a text array
	UBYTE				.inputTextString	'	  1   kid # that can input a text string
	SBYTE				.selectable				'   1   for GuiDesigner design window only
	SBYTE				.whomask					'   1   for internal use only
	SBYTE				.state						'   1
	SBYTE				.keyboard					'   1
	SBYTE				.mouse						'   1
	SBYTE				.redraw						'   1 = 256
END TYPE
'
TYPE MENUENTRY
	STRING*24		.name
	USHORT			.entry
	USHORT			.hover
	XLONG				.break
	XLONG				.height
	USHORT			.indentY
	USHORT			.gap
	XLONG				.hotChar
	XLONG				.firstChar
	XLONG				.firstPixel
	XLONG				.afterPixel
	XLONG				.firstUnder
	XLONG				.afterUnder
END TYPE
'
TYPE CALLBACK
	XLONG				.grid			'
	XLONG				.func			'
	XLONG				.v0				' grid ???
	XLONG				.v1				' func ???
	XLONG				.v2				' -1 for pass back v2 data
	XLONG				.v3				' -1 for pass back v3 data
	XLONG				.r0				' -1 for pass back r0 data (kid #)
	XLONG				.r1				' -1 for pass back r1 data (grid #)
END TYPE
'
TYPE CALLBACKS
	XLONG				.grid			' from the callback
	XLONG				.message	'
	XLONG				.v0				'
	XLONG				.v1				'
	XLONG				.v2				'
	XLONG				.v3				'
	XLONG				.r0				'
	XLONG				.r1				'
	XLONG				.gg				' from #GetCallbackArgs
	XLONG				.ff				'
	XLONG				.vv0			'
	XLONG				.vv1			'
	XLONG				.vv2			'
	XLONG				.vv3			'
	XLONG				.rr0			'
	XLONG				.rr1			'
END TYPE
'
TYPE WINDOW
	XLONG				.window
	XLONG				.windowType
	XLONG				.parent
	XLONG				.graph
	XLONG				.grid
	XLONG				.func
	XLONG				.xDisplay
	XLONG				.yDisplay
	XLONG				.width
	XLONG				.height
	XLONG				.selectState
	XLONG				.displayState
	XLONG				.keyboardFocusGrid
	XLONG				.previousSelectedWindow
	XLONG				.whomask
	XLONG				.www
END TYPE
'
EXPORT
'
'
' ***********************************
' *****  GuiDesigner Functions  *****
' ***********************************
'
DECLARE FUNCTION  Xui                        ()
END EXPORT
INTERNAL FUNCTION  InitGui                   ()
INTERNAL FUNCTION  InitProgram               ()
INTERNAL FUNCTION  ImbeddedGui               ()
INTERNAL FUNCTION  CreateWindows             ()
INTERNAL FUNCTION  InitWindows               ()
'
INTERNAL FUNCTION  Behavior                  (grid)
INTERNAL FUNCTION  BehaviorCode              (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  Design                    (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  Toolkit                   (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  ToolkitCode               (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  Appearance                (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  AppearanceCode            (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  XuiHelp                   (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  Report                    (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  XuiHint                   (grid, message, v0, v1, v3, v3, kid, ANY)
'
DECLARE  FUNCTION  XxxXuiReport              (state)
DECLARE  FUNCTION  XxxXuiBlowback            ()
DECLARE  FUNCTION  XxxGuiDesignerOnOff       (state)
DECLARE  FUNCTION  XxxXuiTextCursor          (color)
'
' *****  GuiDesigner Convenience Functions  *****
'
EXPORT
DECLARE FUNCTION  XuiMessage                 (message$)
DECLARE FUNCTION  XuiDialog                  (message$, default$, kid, reply$)
DECLARE FUNCTION  XuiGetResponse             (gridType$, title$, message$, grids$, v0, v1, kid, reply$)
DECLARE FUNCTION  XuiGetReply                (grid, title$, message$, grids$, v0, v1, kid, reply$)
DECLARE FUNCTION  XuiCreateWindow            (grid, gridType$, xDisp, yDisp, width, height, winType, display$)
DECLARE FUNCTION  XuiReportMessage           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSendStringMessage       (grid, message$, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetNextCallback         (grid, message$, v0, v1, v2, v3, kid, r1$)
DECLARE FUNCTION  XuiQueueCallbacks          (grid, message, v0, v1, v2, v3, kid, r1)
'
' *****  GuiDesigner Conversion Functions  *****
'
DECLARE FUNCTION  XuiAlignNameToNumber       (@name$, @number)
DECLARE FUNCTION  XuiCanNameToNumber         (@name$, @number)
DECLARE FUNCTION  XuiCanStringToNumber       (@name$, @number)
DECLARE FUNCTION  XuiJustifyNameToNumber     (@name$, @number)
DECLARE FUNCTION  XuiTextureNameToNumber     (@name$, @number)
'
DECLARE FUNCTION  XuiAlignNumberToName       (number, @name$)
DECLARE FUNCTION  XuiCanNumberToName         (number, @name$)
DECLARE FUNCTION  XuiCanNumberToString       (number, @name$)
DECLARE FUNCTION  XuiJustifyNumberToName     (number, @name$)
DECLARE FUNCTION  XuiTextureNumberToName     (number, @name$)
'
DECLARE FUNCTION  XuiPropertyValueNameToNumber (property$, value$, @value)
'
' *****  GuiDesigner Support Functions  *****
'
DECLARE FUNCTION  XuiCreateGrid              (@grid, gridType, @xWin, @yWin, @width, @height, window, parent, func)
DECLARE FUNCTION  XuiGetDefaultColors        (@back, @draw, @low, @high, @dull, @acc, @lowtext, @hightext)
DECLARE FUNCTION  XuiGetDefaultCursor        (@cursor)
DECLARE FUNCTION  XuiGetDefaultMessageFuncArray (@func[])
DECLARE FUNCTION  XuiGetGridRegion           (grid, xWin, yWin, @region, @cursor, @defaultCursor)
DECLARE FUNCTION  XuiGetGridProperty         (grid, kid, @property$, @ANY)
DECLARE FUNCTION  XuiGetGridTypeGrids        (gridType, @grid[])
DECLARE FUNCTION  XuiGetGridTypeMessageFuncArray  (gridType, @func[])
DECLARE FUNCTION  XuiGetGridTypeMessageSubArray   (gridType, SUBADDR sub[])
DECLARE FUNCTION  XuiGetGridTypeProperty     (gridType, @property$, @ANY)
DECLARE FUNCTION  XuiGetGridTypeValue        (gridType, @property$, @ANY)
DECLARE FUNCTION  XuiGetGridValue            (grid, @property$, @ANY)
DECLARE FUNCTION  XuiGetHelpWindowGrid       (@window, @grid)
DECLARE FUNCTION  XuiGetPropertyDatabase     (@data$[])
DECLARE FUNCTION  XuiGetTextArraySize        (@text$[], font, @w, @h, @width, @height, extraX, extraY)
DECLARE FUNCTION  XuiGridContainsGridCoord   (grid, messageGrid, x, y, @xx, @yy)
DECLARE FUNCTION  XuiGridFuncNameToAddr      (@name$, @address)
DECLARE FUNCTION  XuiGridKid                 (grid, checkGrid)
DECLARE FUNCTION  XuiGridTypeToGridFunc      (gridtype, @gridFunc)
DECLARE FUNCTION  XuiHelpDisable             ()
DECLARE FUNCTION  XuiHelpEnable              ()
DECLARE FUNCTION  XuiPassOn                  (grid, message, @v0, @v1, @v2, @v3, kid, @ANY)
DECLARE FUNCTION  XuiPlaceWindow             (window, mode, @xDisp, @yDisp, @width, @height)
DECLARE FUNCTION  XuiPositionGrid            (grid, @x, @y, @width, @height)
DECLARE FUNCTION  XuiProcessMessage          (grid, message, v0, v1, v2, v3, kid, ANY, gridType)
DECLARE FUNCTION  XuiRegisterGridType        (@gridType, @gridType$, gridFunc, func[], SUBADDR sub[])
DECLARE FUNCTION  XuiSendMessage             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSendToKid               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSendToKids              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetDefaultColors        (back, draw, low, high, dull, acc, lowtext, hightext)
DECLARE FUNCTION  XuiSetDefaultCursor        (cursor)
DECLARE FUNCTION  XuiSetGridProperty         (grid, kid, @property$, ANY)
DECLARE FUNCTION  XuiSetGridTypeProperty     (gridType, @property$, ANY)
DECLARE FUNCTION  XuiSetGridTypeValue        (gridType, @property$, ANY)
DECLARE FUNCTION  XuiSetGridValue            (grid, @property$, ANY)
DECLARE FUNCTION  XuiSetPropertyDatabase     (@data$[])
DECLARE FUNCTION  XuiVersion$                ()
DECLARE FUNCTION  XuiWindow                  (wingrid, message, v0, v1, v2, v3, kid, ANY)
'
DECLARE FUNCTION  XuiArea                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiBase                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiCheckBox                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiColor                   (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiColors                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiConsole                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiCoordinate              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDialog2B                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDialog3B                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDialog4B                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDirectoryBox            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDriveBox                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDropBox                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDropButton              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiImage                   (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiFile                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiFileBox                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiFont                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGrip                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiLabel                   (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiList                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiListBox                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiListButton              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiListDialog2B            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMenu                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMenuBar                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMenuTextArea1B          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMessage1B               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMessage2B               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMessage3B               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMessage4B               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPressButton             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiProgress                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPullDown                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPushButton              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRadioBox                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRadioButton             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRange                   (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiScrollBarH              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiScrollBarV              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSolidColor              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiText                    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiTextArea                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiTextArea3B              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiTextArea4B              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiTextLine                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiToggleButton            (grid, message, v0, v1, v2, v3, kid, ANY)
'
' *****  message processing functions for common messages  *****
'
DECLARE FUNCTION  XuiCallback                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiCloseWindow             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiCreateValueArray        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDestroy                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDestroyWindow           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDisable                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDisplayed               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiDisplayWindow           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiEnable                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetAlign                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetBorder               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetBorderOffset         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetCallback             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetCan                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetClipGrid             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetColor                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetColorExtra           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetCursor               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetDisplay              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetEnclosedGrids        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetEnclosingGrid        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetFocusColor           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetFocusColorExtra      (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetFont                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetFontMetrics          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetFontNumber           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridFunction         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridFunctionName     (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridName             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridNumber           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridProperties       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridType             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGridTypeName         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetGroup                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetHelp                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetHelpFile             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetHelpString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetHelpStrings          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetHintString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetImage                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetImageCoords          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetIndent               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetInfo                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetJustify              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetKeyboardFocus        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetKeyboardFocusGrid    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetKidArray             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetKidNumber            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetKids                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetCharacterMapArray    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetCharacterMapEntry    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMaxMinSize           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMenuEntryArray       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMessageFunc          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMessageFuncArray     (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMessageSub           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetMessageSubArray      (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetModalInfo            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetModalWindow          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetParent               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetRedrawFlags          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetSize                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetSmallestSize         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetState                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetStyle                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTabArray             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTabWidth             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextArray            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextArrayLine        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextArrayLines       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextFilename         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextSpacing          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTextStrings          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTexture              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetTimer                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetValue                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetValues               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetValueArray           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindow               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindowFunction       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindowGrid           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindowIcon           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindowSize           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGetWindowTitle          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGotKeyboardFocus        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGrabArray               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGrabTextArray           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGrabTextString          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiGrabValueArray          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiHidden                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiHideWindow              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiInitialize              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiKeyboardFocusBackward   (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiKeyboardFocusForward    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiLostKeyboardFocus       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMaximized               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMaximizeWindow          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMinimized               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMinimizeWindow          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMonitorContext          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMonitorHelp             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMonitorKeyboard         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMonitorMouse            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMouseDownSetKeyboardFocus  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiMouseEnter              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPokeArray               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPokeTextArray           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPokeTextString          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiPokeValueArray          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRedraw                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRedrawGrid              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRedrawText              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiRedrawWindow            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiResize                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiResizeNot               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiResizeWindow            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiResizeWindowToGrid      (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSelectWindow            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetAlign                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetBorder               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetBorderOffset         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetCallback             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetCan                  (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetClipGrid             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetColor                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetColorAll             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetColorExtra           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetColorExtraAll        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetCursor               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetFocusColor           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetFocusColorExtra      (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetFont                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetFontNumber           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridFunction         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridFunctionName     (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridName             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridProperties       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridType             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGridTypeName         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetGroup                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetHelp                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetHelpFile             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetHelpString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetHelpStrings          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetHintString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetImage                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetImageCoords          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetIndent               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetInfo                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetJustify              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetKeyboardFocus        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetKeyboardFocusGrid    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetKidArray             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetCharacterMapArray    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetCharacterMapEntry    (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMaxMinSize           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMenuEntryArray       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMessageFunc          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMessageFuncArray     (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMessageSub           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetMessageSubArray      (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetModalWindow          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetParent               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetRedrawFlags          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetSize                 (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetState                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetStyle                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTabArray             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTabWidth             (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextArray            (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextArrayLine        (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextArrayLines       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextFilename         (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextSpacing          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextString           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTextStrings          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTexture              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetTimer                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetValue                (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetValues               (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetValueArray           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetWindowFunction       (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetWindowIcon           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSetWindowTitle          (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiShowWindow              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiStartTimer              (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiSystemMessage           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiTextModifyNot           (grid, message, v0, v1, v2, v3, kid, ANY)
DECLARE FUNCTION  XuiReturnZeros             (grid, message, v0, v1, v2, v3, kid, ANY)
END EXPORT
'
INTERNAL FUNCTION  AddKidToParent            (kid, parent)
INTERNAL FUNCTION  ComputeLimits             (low, high, lo, hi, a1, a2, a3, a4)
INTERNAL FUNCTION  DeselectGrid              (grid)
INTERNAL FUNCTION  DrawTextSegment           (grid, text$, back, draw, xib, yib, topIndent, lineHeight, tabWidth, tab[])
INTERNAL FUNCTION  GetDefaultGridInfo        (GRID proto)
INTERNAL FUNCTION  GuiProgram                ( )
INTERNAL FUNCTION  FreeGridFromParent        (grid, parent)
INTERNAL FUNCTION  GetGridTypePrototype      (gridType, GRID prototype)
INTERNAL FUNCTION  GetHelpEntry              (grid, help$, file$, entry$, header, first, count, text$[])
INTERNAL FUNCTION  GetModalResponseSystem    (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  GetModalResponseUser      (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  GetProtoInfo              (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  NewMessage                (message)
INTERNAL FUNCTION  OrderKids                 (grid)
INTERNAL FUNCTION  ParseLine                 (line$, arg$[])
INTERNAL FUNCTION  PathSlash                 (path$)
INTERNAL FUNCTION  RenameFunction            (text$, old$, new$)
INTERNAL FUNCTION  ReportUserWhomask         (element, name$, address, element$)
INTERNAL FUNCTION  SelectGrid                (grid)
INTERNAL FUNCTION  SendToAll                 (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  SetMessage                (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  SortByExtent              (filename$[], order)
INTERNAL FUNCTION  SortByName                (filename$[], order)
INTERNAL FUNCTION  SortNot                   (filename$[], order)
INTERNAL FUNCTION  SplitFilenames            (filename$[], split)
INTERNAL FUNCTION  StripSymbol               (symbol$)
INTERNAL FUNCTION  StripSymbolRight          (symbol$)
INTERNAL FUNCTION  StripSymbolLeft           (symbol$)
INTERNAL FUNCTION  TrimStringArrayUpper      (array$[])
INTERNAL FUNCTION  UnsplitFilename           (filename$)
INTERNAL FUNCTION  UnsplitFilenames          (filename$[])
INTERNAL FUNCTION  UpdateCodeFunction        (func$[], const$[])
INTERNAL FUNCTION  UpdateCreateWindows       (winFunc$, codeFunc$)
INTERNAL FUNCTION  UpdateKidConstants        (func$[], const$[])
INTERNAL FUNCTION  ValidSimpleSymbol         (symbol$)
'
' text support functions
'
INTERNAL FUNCTION  FindGridName              (grid, name$)
INTERNAL FUNCTION  ParseFuncLine             (line$, ele$[])
INTERNAL FUNCTION  PullDownMessage           (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  TextLineMessage           (grid, message, v0, v1, v2, v3, kid, ANY)
INTERNAL FUNCTION  TextMessage               (grid, message, v0, v1, v2, v3, kid, ANY)
'
' drawing functions from David Szafranski
'
DECLARE FUNCTION  Raised3DBorder             (grid, x1, y1, x2, y2)
DECLARE FUNCTION  Recessed3DBorder           (grid, x1, y1, x2, y2)
DECLARE FUNCTION  DrawDottedLine             (grid, color, x1, y1, x2, y2)
DECLARE FUNCTION  DrawDottedBox              (grid, color, x1, y1, x2, y2)
DECLARE FUNCTION  Erase3DBorder              (grid, color, x1, y1, x2, y2)
DECLARE FUNCTION  FillDottedBox              (grid, color, x1, y1, x2, y2)
DECLARE FUNCTION  DrawArc2                   (grid, color, x, y, radius, start, end)
'
' private external functions
'
EXTERNAL FUNCTION  LoadLibraryA              (addrNameString)
EXTERNAL FUNCTION  FreeLibrary               (handle)
EXTERNAL FUNCTION  GetProcAddress            (handle, addrFuncName)
EXTERNAL FUNCTION  XitGetDECLARE             (@funcName$, @declare$)
EXTERNAL FUNCTION  XitGetDisplayedFunction   (@funcName$)
EXTERNAL FUNCTION  XitGetFunction            (@funcName$, @func$[])
EXTERNAL FUNCTION  XitQueryFunction          (@funcName$, @funcExists)
EXTERNAL FUNCTION  XitSetDECLARE             (@funcName$, declare$)
EXTERNAL FUNCTION  XitSetDisplayedFunction   (@funcName$)
EXTERNAL FUNCTION  XitSetFunction            (@funcName$, @func$[])
EXTERNAL FUNCTION  XitSoftBreak              ()
EXTERNAL FUNCTION  XxxGetLabelGivenAddress   (messFunc, @label$[])
EXTERNAL FUNCTION  XxxXgrSetHelpWindow       (window)
EXTERNAL FUNCTION  XxxXitGetUserProgramName  (@progName$)
EXTERNAL FUNCTION  XxxXstLog                  (text$)
EXPORT
'
'
' ***********************************
' *****  GuiDesigner Constants  *****
' ***********************************
'
'
' *****  Redraw Flags  *****
'
	$$RedrawClip						= 0x80000000
	$$RedrawFocus						= 0x00000400
	$$RedrawClear						= 0x00000200
	$$RedrawBuffer					= 0x00000100
	$$RedrawImage						= 0x00000080
	$$RedrawBorder					= 0x00000020
	$$RedrawTexture					= 0x00000010
	$$RedrawTextArray				= 0x00000008
	$$RedrawTextString			= 0x00000004
	$$RedrawTextAccent			= 0x00000002
	$$RedrawTextDull				= 0x00000001
	$$RedrawNone						= 0x00000000
	$$RedrawClearBorder			= 0x00000220	' clear, border
	$$RedrawDefault					= 0x800006FC	' clip, focus, clear, image, border, texture, array, string
	$$RedrawNoTexture				= 0x800006EC	' ditto without texture
	$$RedrawDefaultNoFocus	= 0x800002FC	' $$RedrawDefault w/o $$RedrawFocus
'
' *****  Texture  *****
'
	$$TextureFlat					=  0
	$$TextureNone					=  0
	$$TextureLower4				=  1
	$$TextureLower2				=  2
	$$TextureLower1				=  3
	$$TextureShadow				=  4
	$$TextureRaise1				=  5
	$$TextureRaise2				=  6
	$$TextureRaise4				=  7
'
' *****  Text Align and Text Justify  *****
'
	$$AlignUpperLeft			=  1			' bits 32 = vertical
	$$AlignUpperCenter		=  2			' bits 10 = horizontal
	$$AlignUpperRight			=  3
	$$AlignMiddleLeft			=  5
	$$AlignMiddleCenter		=  6
	$$AlignMiddleRight		=  7
	$$AlignLowerLeft			=  9
	$$AlignLowerCenter		= 10
	$$AlignLowerRight			= 11
	$$AlignLeft						=  1			' x value
	$$AlignCenter					=  2			' x value
	$$AlignRight					=  3			' x value
	$$AlignUpper					=  0			' y value
	$$AlignMiddle					=  4			' y value
	$$AlignLower					=  8			' y value
	$$AlignHorizontal			=  3			' x mask
	$$AlignVertical				= 12			' y mask
'
	$$JustifyLeft					=  1
	$$JustifyCenter				=  2
	$$JustifyRight				=  3
	$$JustifyBoth					=  4
'
' *****  General Constants  *****
'
	$$XuiDisable					=  0
	$$XuiEnable						= -1
	$$XuiError						= 0x80000000
'
' *****  Text Selection Constants  *****
'
	$$SelectNoChange			= 0
	$$SelectCancel				= 1								'	cancel text selection
	$$SelectSet						= 2								' set text selection (single-click)
	$$SelectDrag					= 3								' drag text selection
	$$SelectExtend				= 4								' extend (shift-click)
'
'
' *****  State Constants  *****
'
	$$ButtonNumber				= BITFIELD (3, 0)
	$$LeftButtonNumber		= 1
	$$MiddleButtonNumber	= 2
	$$RightButtonNumber		= 3
	$$HelpButtonNumber		= 3
'
	$$KeyKind							= BITFIELD ( 3,20)
	$$KeyKindVirtual			= 0
	$$KeyKindASCII				= 1
	$$KeyKindWide					= 2
	$$KeyKindUnicode			= 2
	$$KeyVirtual					= BITFIELD ( 8, 0)
	$$KeyASCII						= BITFIELD ( 8, 0)
	$$KeyWide							= BITFIELD (16, 0)
	$$KeyUnicode					= BITFIELD (16, 0)
'
'
' *****  .can  *****
'
	$$Focus								= 0x01
	$$Respond							= 0x02
	$$Callback						= 0x04
	$$InputTextArray			= 0x10
	$$InputTextString			= 0x20
	$$TextSelection				= 0x40
'
' *****  messageType  *****
'
	$$Context							= 1
	$$Help								= 2
	$$Keyboard						= 4
	$$Mouse								= 8
END EXPORT
'
	$$WORD0								= BITFIELD (16,0)
	$$WORD1								= BITFIELD (16,16)
	$$StateContents				= BITFIELD (2,20)
'
'	$$ShowUntrappedMessages = $$TRUE
	$$ShowUntrappedMessages = $$FALSE
'
	$$MouseEnter					=  9
	$$MouseExit						= 10
	$$MouseMove						=  7
	$$MouseUp							=  6
	$$KeyUp								= 13
'
	$$MIN									= -2147483647
	$$MAX									=  2147483647
	$$XgrExitGuiDesigner	= 0x0100
'
'
'
' ####################  Initialization / entry function
' #####  Xui ()  #####
' ####################  NOTE:  No PRINT statements before CreateWindows()
'
FUNCTION  Xui ()
	SHARED	report
	SHARED  terminateProgram
	STATIC	entry
'
	IF entry THEN RETURN
	error = Xgr()
	IF error THEN RETURN (error)
	entry = $$TRUE
	library = LIBRARY(0)
'
	a$ = "Max Reason"
	a$ = "copyright 1988-2000"
	a$ = "XBasic GuiDesigner function library"
	a$ = "maxreason@maxreason.com"
	a$ = ""
'
	InitGui()
	InitProgram()
	CreateWindows()
	IF library THEN ImbeddedGui() : RETURN
'
'	ImbeddedGui()										' to test HelpWindow in environment
'
	InitWindows()
'
	DO
		XgrProcessMessages ( 1 )
		IFZ (library OR ##WHOMASK) THEN PRINT "w";
	LOOP UNTIL  terminateProgram
END FUNCTION
'
'
' ########################
' #####  InitGui ()  #####
' ########################
'
' InitGui() initializes cursor, icon, message, and display variables.
' Programs can reference these variables, but must never change them.
'
FUNCTION  InitGui ()
'
' need to set program name so grid properties
' can be set from the grid property database.
'
	XstSetProgramName (@"xb")
'
	XstLoadStringArray (@"$XBDIR/templates/property.xxx", @data$[])
	XuiSetPropertyDatabase (@data$[])
'
' ***************************************
' *****  Register Standard Cursors  *****
' ***************************************
'
	XgrRegisterCursor (@"default",      @#cursorDefault)
	XgrRegisterCursor (@"arrow",        @#cursorArrow)
	XgrRegisterCursor (@"n",            @#cursorN)
	XgrRegisterCursor (@"s",            @#cursorS)
	XgrRegisterCursor (@"e",            @#cursorE)
	XgrRegisterCursor (@"w",            @#cursorW)
	XgrRegisterCursor (@"ns",           @#cursorArrowsNS)
	XgrRegisterCursor (@"ns",           @#cursorArrowsSN)
	XgrRegisterCursor (@"ew",           @#cursorArrowsEW)
	XgrRegisterCursor (@"ew",           @#cursorArrowsWE)
	XgrRegisterCursor (@"nwse",         @#cursorArrowsNWSE)
	XgrRegisterCursor (@"nesw",         @#cursorArrowsNESW)
	XgrRegisterCursor (@"all",          @#cursorArrowsAll)
	XgrRegisterCursor (@"plus",         @#cursorPlus)
	XgrRegisterCursor (@"wait",         @#cursorWait)
	XgrRegisterCursor (@"insert",       @#cursorInsert)
	XgrRegisterCursor (@"crosshair",    @#cursorCrosshair)
	XgrRegisterCursor (@"hourglass",    @#cursorHourglass)
	XgrRegisterCursor (@"hand",         @#cursorHand)
	XgrRegisterCursor (@"help",         @#cursorHelp)
'
	#defaultCursor = #cursorDefault
'
'
' ********************************************
' *****  Register Standard Window Icons  *****
' ********************************************
'
	XgrRegisterIcon (@"hand",					@#iconHand)
	XgrRegisterIcon (@"asterisk",			@#iconAsterisk)
	XgrRegisterIcon (@"question",			@#iconQuestion)
	XgrRegisterIcon (@"exclamation",	@#iconExclamation)
	XgrRegisterIcon (@"application",	@#iconApplication)
'
	XgrRegisterIcon (@"hand",					@#iconStop)						' alias
	XgrRegisterIcon (@"asterisk",			@#iconInformation)		' alias
	XgrRegisterIcon (@"application",  @#iconBlank)					' alias
'
	XgrRegisterIcon (@"window",				@#iconWindow)					' custom
'
'
' ******************************
' *****  Register Messages *****  Create message numbers for message names
' ******************************
'
	XgrRegisterMessage (@"Blowback",										@#Blowback)
	XgrRegisterMessage (@"Callback",										@#Callback)
	XgrRegisterMessage (@"Cancel",											@#Cancel)
	XgrRegisterMessage (@"Change",											@#Change)
	XgrRegisterMessage (@"CloseWindow",									@#CloseWindow)
	XgrRegisterMessage (@"ContextChange",								@#ContextChange)
	XgrRegisterMessage (@"Create",											@#Create)
	XgrRegisterMessage (@"CreateValueArray",						@#CreateValueArray)
	XgrRegisterMessage (@"CreateWindow",								@#CreateWindow)
	XgrRegisterMessage (@"CursorH",											@#CursorH)
	XgrRegisterMessage (@"CursorV",											@#CursorV)
	XgrRegisterMessage (@"Deselected",									@#Deselected)
	XgrRegisterMessage (@"Destroy",											@#Destroy)
	XgrRegisterMessage (@"Destroyed",										@#Destroyed)
	XgrRegisterMessage (@"DestroyWindow",								@#DestroyWindow)
	XgrRegisterMessage (@"Disable",											@#Disable)
	XgrRegisterMessage (@"Disabled",										@#Disabled)
	XgrRegisterMessage (@"Displayed",										@#Displayed)
	XgrRegisterMessage (@"DisplayWindow",								@#DisplayWindow)
	XgrRegisterMessage (@"Enable",											@#Enable)
	XgrRegisterMessage (@"Enabled",											@#Enabled)
	XgrRegisterMessage (@"Enter",												@#Enter)
	XgrRegisterMessage (@"ExitMessageLoop",							@#ExitMessageLoop)
	XgrRegisterMessage (@"Find",												@#Find)
	XgrRegisterMessage (@"FindForward",									@#FindForward)
	XgrRegisterMessage (@"FindReverse",									@#FindReverse)
	XgrRegisterMessage (@"Forward",											@#Forward)
	XgrRegisterMessage (@"GetAlign",										@#GetAlign)
	XgrRegisterMessage (@"GetBorder",										@#GetBorder)
	XgrRegisterMessage (@"GetBorderOffset",							@#GetBorderOffset)
	XgrRegisterMessage (@"GetCallback",									@#GetCallback)
	XgrRegisterMessage (@"GetCallbackArgs",							@#GetCallbackArgs)
	XgrRegisterMessage (@"GetCan",											@#GetCan)
	XgrRegisterMessage (@"GetCharacterMapArray",				@#GetCharacterMapArray)
	XgrRegisterMessage (@"GetCharacterMapEntry",				@#GetCharacterMapEntry)
	XgrRegisterMessage (@"GetClipGrid",									@#GetClipGrid)
	XgrRegisterMessage (@"GetColor",										@#GetColor)
	XgrRegisterMessage (@"GetColorExtra",								@#GetColorExtra)
	XgrRegisterMessage (@"GetCursor",										@#GetCursor)
	XgrRegisterMessage (@"GetCursorXY",									@#GetCursorXY)
	XgrRegisterMessage (@"GetDisplay",									@#GetDisplay)
	XgrRegisterMessage (@"GetEnclosedGrids",						@#GetEnclosedGrids)
	XgrRegisterMessage (@"GetEnclosingGrid",						@#GetEnclosingGrid)
	XgrRegisterMessage (@"GetFocusColor",								@#GetFocusColor)
	XgrRegisterMessage (@"GetFocusColorExtra",					@#GetFocusColorExtra)
	XgrRegisterMessage (@"GetFont",											@#GetFont)
	XgrRegisterMessage (@"GetFontMetrics",							@#GetFontMetrics)
	XgrRegisterMessage (@"GetFontNumber",								@#GetFontNumber)
	XgrRegisterMessage (@"GetGridFunction",							@#GetGridFunction)
	XgrRegisterMessage (@"GetGridFunctionName",					@#GetGridFunctionName)
	XgrRegisterMessage (@"GetGridName",									@#GetGridName)
	XgrRegisterMessage (@"GetGridNumber",								@#GetGridNumber)
	XgrRegisterMessage (@"GetGridProperties",						@#GetGridProperties)
	XgrRegisterMessage (@"GetGridType",									@#GetGridType)
	XgrRegisterMessage (@"GetGridTypeName",							@#GetGridTypeName)
	XgrRegisterMessage (@"GetGroup",										@#GetGroup)
	XgrRegisterMessage (@"GetHelp",											@#GetHelp)
	XgrRegisterMessage (@"GetHelpFile",									@#GetHelpFile)
	XgrRegisterMessage (@"GetHelpString",								@#GetHelpString)
	XgrRegisterMessage (@"GetHelpStrings",							@#GetHelpStrings)
	XgrRegisterMessage (@"GetHintString",								@#GetHintString)
	XgrRegisterMessage (@"GetImage",										@#GetImage)
	XgrRegisterMessage (@"GetImageCoords",							@#GetImageCoords)
	XgrRegisterMessage (@"GetIndent",										@#GetIndent)
	XgrRegisterMessage (@"GetInfo",											@#GetInfo)
	XgrRegisterMessage (@"GetJustify",									@#GetJustify)
	XgrRegisterMessage (@"GetKeyboardFocus",						@#GetKeyboardFocus)
	XgrRegisterMessage (@"GetKeyboardFocusGrid",				@#GetKeyboardFocusGrid)
	XgrRegisterMessage (@"GetKidArray",									@#GetKidArray)
	XgrRegisterMessage (@"GetKidNumber",								@#GetKidNumber)
	XgrRegisterMessage (@"GetKids",											@#GetKids)
	XgrRegisterMessage (@"GetKind",											@#GetKind)
	XgrRegisterMessage (@"GetMaxMinSize",								@#GetMaxMinSize)
	XgrRegisterMessage (@"GetMenuEntryArray",						@#GetMenuEntryArray)
	XgrRegisterMessage (@"GetMessageFunc",							@#GetMessageFunc)
	XgrRegisterMessage (@"GetMessageFuncArray",					@#GetMessageFuncArray)
	XgrRegisterMessage (@"GetMessageSub",								@#GetMessageSub)
	XgrRegisterMessage (@"GetMessageSubArray",					@#GetMessageSubArray)
	XgrRegisterMessage (@"GetModalInfo",								@#GetModalInfo)
	XgrRegisterMessage (@"GetModalWindow",							@#GetModalWindow)
	XgrRegisterMessage (@"GetParent",										@#GetParent)
	XgrRegisterMessage (@"GetPosition",									@#GetPosition)
	XgrRegisterMessage (@"GetProtoInfo",								@#GetProtoInfo)
	XgrRegisterMessage (@"GetRedrawFlags",							@#GetRedrawFlags)
	XgrRegisterMessage (@"GetSize",											@#GetSize)
	XgrRegisterMessage (@"GetSmallestSize",							@#GetSmallestSize)
	XgrRegisterMessage (@"GetState",										@#GetState)
	XgrRegisterMessage (@"GetStyle",										@#GetStyle)
	XgrRegisterMessage (@"GetTabArray",									@#GetTabArray)
	XgrRegisterMessage (@"GetTabWidth",									@#GetTabWidth)
	XgrRegisterMessage (@"GetTextArray",								@#GetTextArray)
	XgrRegisterMessage (@"GetTextArrayBounds",					@#GetTextArrayBounds)
	XgrRegisterMessage (@"GetTextArrayLine",						@#GetTextArrayLine)
	XgrRegisterMessage (@"GetTextArrayLines",						@#GetTextArrayLines)
	XgrRegisterMessage (@"GetTextCursor",								@#GetTextCursor)
	XgrRegisterMessage (@"GetTextFilename",							@#GetTextFilename)
	XgrRegisterMessage (@"GetTextPosition",							@#GetTextPosition)
	XgrRegisterMessage (@"GetTextSelection",						@#GetTextSelection)
	XgrRegisterMessage (@"GetTextSpacing",							@#GetTextSpacing)
	XgrRegisterMessage (@"GetTextString",								@#GetTextString)
	XgrRegisterMessage (@"GetTextStrings",							@#GetTextStrings)
	XgrRegisterMessage (@"GetTexture",									@#GetTexture)
	XgrRegisterMessage (@"GetTimer",										@#GetTimer)
	XgrRegisterMessage (@"GetValue",										@#GetValue)
	XgrRegisterMessage (@"GetValueArray",								@#GetValueArray)
	XgrRegisterMessage (@"GetValues",										@#GetValues)
	XgrRegisterMessage (@"GetWindow",										@#GetWindow)
	XgrRegisterMessage (@"GetWindowFunction",						@#GetWindowFunction)
	XgrRegisterMessage (@"GetWindowGrid",								@#GetWindowGrid)
	XgrRegisterMessage (@"GetWindowIcon",								@#GetWindowIcon)
	XgrRegisterMessage (@"GetWindowSize",								@#GetWindowSize)
	XgrRegisterMessage (@"GetWindowTitle",							@#GetWindowTitle)
	XgrRegisterMessage (@"GotKeyboardFocus",						@#GotKeyboardFocus)
	XgrRegisterMessage (@"GrabArray",										@#GrabArray)
	XgrRegisterMessage (@"GrabTextArray",								@#GrabTextArray)
	XgrRegisterMessage (@"GrabTextString",							@#GrabTextString)
	XgrRegisterMessage (@"GrabValueArray",							@#GrabValueArray)
	XgrRegisterMessage (@"Help",												@#Help)
	XgrRegisterMessage (@"Hidden",											@#Hidden)
	XgrRegisterMessage (@"HideTextCursor",							@#HideTextCursor)
	XgrRegisterMessage (@"HideWindow",									@#HideWindow)
	XgrRegisterMessage (@"Initialize",									@#Initialize)
	XgrRegisterMessage (@"Initialized",									@#Initialized)
	XgrRegisterMessage (@"Inline",											@#Inline)
	XgrRegisterMessage (@"InquireText",									@#InquireText)
	XgrRegisterMessage (@"KeyboardFocusBackward",				@#KeyboardFocusBackward)
	XgrRegisterMessage (@"KeyboardFocusForward",				@#KeyboardFocusForward)
	XgrRegisterMessage (@"KeyDown",											@#KeyDown)
	XgrRegisterMessage (@"KeyUp",												@#KeyUp)
	XgrRegisterMessage (@"LostKeyboardFocus",						@#LostKeyboardFocus)
	XgrRegisterMessage (@"LostTextSelection",						@#LostTextSelection)
	XgrRegisterMessage (@"Maximized",										@#Maximized)
	XgrRegisterMessage (@"MaximizeWindow",							@#MaximizeWindow)
	XgrRegisterMessage (@"Maximum",											@#Maximum)
	XgrRegisterMessage (@"Minimized",										@#Minimized)
	XgrRegisterMessage (@"MinimizeWindow",							@#MinimizeWindow)
	XgrRegisterMessage (@"Minimum",											@#Minimum)
	XgrRegisterMessage (@"MonitorContext",							@#MonitorContext)
	XgrRegisterMessage (@"MonitorHelp",									@#MonitorHelp)
	XgrRegisterMessage (@"MonitorKeyboard",							@#MonitorKeyboard)
	XgrRegisterMessage (@"MonitorMouse",								@#MonitorMouse)
	XgrRegisterMessage (@"MouseDown",										@#MouseDown)
	XgrRegisterMessage (@"MouseDrag",										@#MouseDrag)
	XgrRegisterMessage (@"MouseEnter",									@#MouseEnter)
	XgrRegisterMessage (@"MouseExit",										@#MouseExit)
	XgrRegisterMessage (@"MouseMove",										@#MouseMove)
	XgrRegisterMessage (@"MouseUp",											@#MouseUp)
	XgrRegisterMessage (@"MouseWheel",									@#MouseWheel)
	XgrRegisterMessage (@"MuchLess",										@#MuchLess)
	XgrRegisterMessage (@"MuchMore",										@#MuchMore)
	XgrRegisterMessage (@"Notify",											@#Notify)
	XgrRegisterMessage (@"OneLess",											@#OneLess)
	XgrRegisterMessage (@"OneMore",											@#OneMore)
	XgrRegisterMessage (@"PokeArray",										@#PokeArray)
	XgrRegisterMessage (@"PokeTextArray",								@#PokeTextArray)
	XgrRegisterMessage (@"PokeTextString",							@#PokeTextString)
	XgrRegisterMessage (@"PokeValueArray",							@#PokeValueArray)
	XgrRegisterMessage (@"Print",												@#Print)
	XgrRegisterMessage (@"Redraw",											@#Redraw)
	XgrRegisterMessage (@"RedrawGrid",									@#RedrawGrid)
	XgrRegisterMessage (@"RedrawLines",									@#RedrawLines)
	XgrRegisterMessage (@"Redrawn",											@#Redrawn)
	XgrRegisterMessage (@"RedrawText",									@#RedrawText)
	XgrRegisterMessage (@"RedrawWindow",								@#RedrawWindow)
	XgrRegisterMessage (@"Replace",											@#Replace)
	XgrRegisterMessage (@"ReplaceForward",							@#ReplaceForward)
	XgrRegisterMessage (@"ReplaceReverse",							@#ReplaceReverse)
	XgrRegisterMessage (@"Reset",												@#Reset)
	XgrRegisterMessage (@"Resize",											@#Resize)
	XgrRegisterMessage (@"Resized",											@#Resized)
	XgrRegisterMessage (@"ResizeNot",										@#ResizeNot)
	XgrRegisterMessage (@"ResizeWindow",								@#ResizeWindow)
	XgrRegisterMessage (@"ResizeWindowToGrid",					@#ResizeWindowToGrid)
	XgrRegisterMessage (@"Resized",											@#Resized)
	XgrRegisterMessage (@"Reverse",											@#Reverse)
	XgrRegisterMessage (@"ScrollH",											@#ScrollH)
	XgrRegisterMessage (@"ScrollV",											@#ScrollV)
	XgrRegisterMessage (@"Select",											@#Select)
	XgrRegisterMessage (@"Selected",										@#Selected)
	XgrRegisterMessage (@"Selection",										@#Selection)
	XgrRegisterMessage (@"SelectWindow",								@#SelectWindow)
	XgrRegisterMessage (@"SetAlign",										@#SetAlign)
	XgrRegisterMessage (@"SetBorder",										@#SetBorder)
	XgrRegisterMessage (@"SetBorderOffset",							@#SetBorderOffset)
	XgrRegisterMessage (@"SetCallback",									@#SetCallback)
	XgrRegisterMessage (@"SetCan",											@#SetCan)
	XgrRegisterMessage (@"SetCharacterMapArray",				@#SetCharacterMapArray)
	XgrRegisterMessage (@"SetCharacterMapEntry",				@#SetCharacterMapEntry)
	XgrRegisterMessage (@"SetClipGrid",									@#SetClipGrid)
	XgrRegisterMessage (@"SetColor",										@#SetColor)
	XgrRegisterMessage (@"SetColorAll",									@#SetColorAll)
	XgrRegisterMessage (@"SetColorExtra",								@#SetColorExtra)
	XgrRegisterMessage (@"SetColorExtraAll",						@#SetColorExtraAll)
	XgrRegisterMessage (@"SetCursor",										@#SetCursor)
	XgrRegisterMessage (@"SetCursorXY",									@#SetCursorXY)
	XgrRegisterMessage (@"SetDisplay",									@#SetDisplay)
	XgrRegisterMessage (@"SetFocusColor",								@#SetFocusColor)
	XgrRegisterMessage (@"SetFocusColorExtra",					@#SetFocusColorExtra)
	XgrRegisterMessage (@"SetFont",											@#SetFont)
	XgrRegisterMessage (@"SetFontNumber",								@#SetFontNumber)
	XgrRegisterMessage (@"SetGridFunction",							@#SetGridFunction)
	XgrRegisterMessage (@"SetGridFunctionName",					@#SetGridFunctionName)
	XgrRegisterMessage (@"SetGridName",									@#SetGridName)
	XgrRegisterMessage (@"SetGridProperties",						@#SetGridProperties)
	XgrRegisterMessage (@"SetGridType",									@#SetGridType)
	XgrRegisterMessage (@"SetGridTypeName",							@#SetGridTypeName)
	XgrRegisterMessage (@"SetGroup",										@#SetGroup)
	XgrRegisterMessage (@"SetHelp",											@#SetHelp)
	XgrRegisterMessage (@"SetHelpFile",									@#SetHelpFile)
	XgrRegisterMessage (@"SetHelpString",								@#SetHelpString)
	XgrRegisterMessage (@"SetHelpStrings",							@#SetHelpStrings)
	XgrRegisterMessage (@"SetHintString",								@#SetHintString)
	XgrRegisterMessage (@"SetImage",										@#SetImage)
	XgrRegisterMessage (@"SetImageCoords",							@#SetImageCoords)
	XgrRegisterMessage (@"SetIndent",										@#SetIndent)
	XgrRegisterMessage (@"SetInfo",											@#SetInfo)
	XgrRegisterMessage (@"SetJustify",									@#SetJustify)
	XgrRegisterMessage (@"SetKeyboardFocus",						@#SetKeyboardFocus)
	XgrRegisterMessage (@"SetKeyboardFocusGrid",				@#SetKeyboardFocusGrid)
	XgrRegisterMessage (@"SetKidArray",									@#SetKidArray)
	XgrRegisterMessage (@"SetMaxMinSize",								@#SetMaxMinSize)
	XgrRegisterMessage (@"SetMenuEntryArray",						@#SetMenuEntryArray)
	XgrRegisterMessage (@"SetMessageFunc",							@#SetMessageFunc)
	XgrRegisterMessage (@"SetMessageFuncArray",					@#SetMessageFuncArray)
	XgrRegisterMessage (@"SetMessageSub",								@#SetMessageSub)
	XgrRegisterMessage (@"SetMessageSubArray",					@#SetMessageSubArray)
	XgrRegisterMessage (@"SetModalWindow",							@#SetModalWindow)
	XgrRegisterMessage (@"SetParent",										@#SetParent)
	XgrRegisterMessage (@"SetPosition",									@#SetPosition)
	XgrRegisterMessage (@"SetRedrawFlags",							@#SetRedrawFlags)
	XgrRegisterMessage (@"SetSize",											@#SetSize)
	XgrRegisterMessage (@"SetState",										@#SetState)
	XgrRegisterMessage (@"SetStyle",										@#SetStyle)
	XgrRegisterMessage (@"SetTabArray",									@#SetTabArray)
	XgrRegisterMessage (@"SetTabWidth",									@#SetTabWidth)
	XgrRegisterMessage (@"SetTextArray",								@#SetTextArray)
	XgrRegisterMessage (@"SetTextArrayLine",						@#SetTextArrayLine)
	XgrRegisterMessage (@"SetTextArrayLines",						@#SetTextArrayLines)
	XgrRegisterMessage (@"SetTextCursor",								@#SetTextCursor)
	XgrRegisterMessage (@"SetTextFilename",							@#SetTextFilename)
	XgrRegisterMessage (@"SetTextSelection",						@#SetTextSelection)
	XgrRegisterMessage (@"SetTextSpacing",							@#SetTextSpacing)
	XgrRegisterMessage (@"SetTextString",								@#SetTextString)
	XgrRegisterMessage (@"SetTextStrings",							@#SetTextStrings)
	XgrRegisterMessage (@"SetTexture",									@#SetTexture)
	XgrRegisterMessage (@"SetTimer",										@#SetTimer)
	XgrRegisterMessage (@"SetValue",										@#SetValue)
	XgrRegisterMessage (@"SetValues",										@#SetValues)
	XgrRegisterMessage (@"SetValueArray",								@#SetValueArray)
	XgrRegisterMessage (@"SetWindowFunction",						@#SetWindowFunction)
	XgrRegisterMessage (@"SetWindowIcon",								@#SetWindowIcon)
	XgrRegisterMessage (@"SetWindowTitle",							@#SetWindowTitle)
	XgrRegisterMessage (@"ShowTextCursor",							@#ShowTextCursor)
	XgrRegisterMessage (@"ShowWindow",									@#ShowWindow)
	XgrRegisterMessage (@"SomeLess",										@#SomeLess)
	XgrRegisterMessage (@"SomeMore",										@#SomeMore)
	XgrRegisterMessage (@"StartTimer",									@#StartTimer)
	XgrRegisterMessage (@"SystemMessage",								@#SystemMessage)
	XgrRegisterMessage (@"TextDelete",									@#TextDelete)
	XgrRegisterMessage (@"TextEvent",										@#TextEvent)
	XgrRegisterMessage (@"TextInsert",									@#TextInsert)
	XgrRegisterMessage (@"TextModified",								@#TextModified)
	XgrRegisterMessage (@"TextReplace",									@#TextReplace)
	XgrRegisterMessage (@"TimeOut",											@#TimeOut)
	XgrRegisterMessage (@"Update",											@#Update)
	XgrRegisterMessage (@"WindowClose",									@#WindowClose)
	XgrRegisterMessage (@"WindowCreate",								@#WindowCreate)
	XgrRegisterMessage (@"WindowDeselected",						@#WindowDeselected)
	XgrRegisterMessage (@"WindowDestroy",								@#WindowDestroy)
	XgrRegisterMessage (@"WindowDestroyed",							@#WindowDestroyed)
	XgrRegisterMessage (@"WindowDisplay",								@#WindowDisplay)
	XgrRegisterMessage (@"WindowDisplayed",							@#WindowDisplayed)
	XgrRegisterMessage (@"WindowGetDisplay",						@#WindowGetDisplay)
	XgrRegisterMessage (@"WindowGetFunction",						@#WindowGetFunction)
	XgrRegisterMessage (@"WindowGetIcon",								@#WindowGetIcon)
	XgrRegisterMessage (@"WindowGetKeyboardFocusGrid",	@#WindowGetKeyboardFocusGrid)
	XgrRegisterMessage (@"WindowGetSelectedWindow",			@#WindowGetSelectedWindow)
	XgrRegisterMessage (@"WindowGetSize",								@#WindowGetSize)
	XgrRegisterMessage (@"WindowGetTitle",							@#WindowGetTitle)
	XgrRegisterMessage (@"WindowHelp",									@#WindowHelp)
	XgrRegisterMessage (@"WindowHide",									@#WindowHide)
	XgrRegisterMessage (@"WindowHidden",								@#WindowHidden)
	XgrRegisterMessage (@"WindowKeyDown",								@#WindowKeyDown)
	XgrRegisterMessage (@"WindowKeyUp",									@#WindowKeyUp)
	XgrRegisterMessage (@"WindowMaximize",							@#WindowMaximize)
	XgrRegisterMessage (@"WindowMaximized",							@#WindowMaximized)
	XgrRegisterMessage (@"WindowMinimize",							@#WindowMinimize)
	XgrRegisterMessage (@"WindowMinimized",							@#WindowMinimized)
	XgrRegisterMessage (@"WindowMonitorContext",				@#WindowMonitorContext)
	XgrRegisterMessage (@"WindowMonitorHelp",						@#WindowMonitorHelp)
	XgrRegisterMessage (@"WindowMonitorKeyboard",				@#WindowMonitorKeyboard)
	XgrRegisterMessage (@"WindowMonitorMouse",					@#WindowMonitorMouse)
	XgrRegisterMessage (@"WindowMouseDown",							@#WindowMouseDown)
	XgrRegisterMessage (@"WindowMouseDrag",							@#WindowMouseDrag)
	XgrRegisterMessage (@"WindowMouseEnter",						@#WindowMouseEnter)
	XgrRegisterMessage (@"WindowMouseExit",							@#WindowMouseExit)
	XgrRegisterMessage (@"WindowMouseMove",							@#WindowMouseMove)
	XgrRegisterMessage (@"WindowMouseUp",								@#WindowMouseUp)
	XgrRegisterMessage (@"WindowMouseWheel",						@#WindowMouseWheel)
	XgrRegisterMessage (@"WindowRedraw",								@#WindowRedraw)
	XgrRegisterMessage (@"WindowRegister",							@#WindowRegister)
	XgrRegisterMessage (@"WindowResize",								@#WindowResize)
	XgrRegisterMessage (@"WindowResized",								@#WindowResized)
	XgrRegisterMessage (@"WindowResizeToGrid",					@#WindowResizeToGrid)
	XgrRegisterMessage (@"WindowSelect",								@#WindowSelect)
	XgrRegisterMessage (@"WindowSelected",							@#WindowSelected)
	XgrRegisterMessage (@"WindowSetFunction",						@#WindowSetFunction)
	XgrRegisterMessage (@"WindowSetIcon",								@#WindowSetIcon)
	XgrRegisterMessage (@"WindowSetKeyboardFocusGrid",	@#WindowSetKeyboardFocusGrid)
	XgrRegisterMessage (@"WindowSetTitle",							@#WindowSetTitle)
	XgrRegisterMessage (@"WindowShow",									@#WindowShow)
	XgrRegisterMessage (@"WindowSystemMessage",					@#WindowSystemMessage)
	XgrRegisterMessage (@"LastMessage",									@#LastMessage)
'
	XgrGetDisplaySize ("", @#displayWidth, @#displayHeight, @#windowBorderWidth, @#windowTitleHeight)
END FUNCTION
'
'
' ############################
' #####  InitProgram ()  #####
' ############################
'
FUNCTION  InitProgram ()
'
	SHARED	reportGrid							' ReportMessage grid
'
	SHARED	backgroundColor					' default colors
	SHARED	drawingColor						'
	SHARED	lowlightColor						'
	SHARED	highlightColor					'
	SHARED	dullColor								'
	SHARED	accentColor							'
	SHARED	lowtextColor						'
	SHARED	hightextColor						'
'
	SHARED	defaultFontSize					'
	SHARED	defaultFontWeight				'
	SHARED	defaultFontItalic				'
	SHARED	defaultFontAngle				'
'
	SHARED	modalFont								'
	SHARED	romanFont								'
	SHARED	dialogFont							'
	SHARED	messageFont							'
	SHARED	defaultFont							'
'
	SHARED	can$[]									' can bit to can string
	SHARED	border$[]								' border style constant names
	SHARED	borderWidth[]						' border style border widths
	SHARED	texture$[]							' text texture constant names
	SHARED	justify$[]							'	text justify constant names
	SHARED	align$[]								' text align constant names
	SHARED	winkid[]								' window kids of each window
	SHARED	window[]								' parentless grids in windows
	SHARED	window$[]								' names of windows$
	SHARED  windowDisplay$[]				' display name for each window
	SHARED	upperGrid								' upper bound of grid[]
	SHARED	upperMessage						' highest message number
	SHARED	upperGridType						' upper bound of gridType[]
	SHARED	messageSub[]						' subroutines for each gridType,message
	SHARED	gridTypeMessageFunc[]		' message processing functions normally called by grid functions
	SHARED	gridMessageFunc[]				' message processing functions modified for individual grids
	SHARED	GRID  grid[]						' info on each grid (grid[grid])
	SHARED	GRID  gridType[]				' info on each grid type (gridType[gridType]))
	SHARED	CALLBACK	callback[]		' callback func/grid/r0/r1 array for each grid
	SHARED	CALLBACK	monitor[]			' monitor keyboard callbacks for each window
	SHARED	WINDOW  windowInfo[]		' window info for every window
	SHARED  MENUENTRY  menuentry[]	' holding array for XuiMenu()
	SHARED	textString$[]						' text string for each grid
	SHARED	textArray$[]						' text array for each grid
	SHARED	tabArray[]							' tab stops for text grids
	SHARED	values[]								' array of values for every grid
	SHARED	array[]									' array of any type for every grid
	SHARED	kids[]									' array of child grids for every grid
	SHARED	help$[]									' help name for each grid
	SHARED	hint$[]									' hint name for each grid
	SHARED	image$[]								' image name for each grid
	SHARED	gridName$[]							' unique name for each grid
	SHARED	gridType$[]							' grid type name for each grid
	SHARED	gridFunc$[]							' grid function name for each grid
	SHARED	gridTypeName$[]					' grid type name for each grid type
	SHARED	gridTypeFunc$[]					' grid function name for each grid type
	SHARED	tool[]									' grid type of toolkit tools
	SHARED	tool$[]									' grid type name for toolkit pushbuttons
'
	SHARED  backslash_literal[]			' literal string backslash characters
'
	SHARED	UBYTE  charsetAlphaNumeric[]	' A-Z, a-z, 0-9
	SHARED	UBYTE  charsetTextChar[]
	SHARED	UBYTE  charsetSymbol[]
	SHARED	UBYTE  charsetAlpha[]
	SHARED	UBYTE  messageType[]
'
' **************************************************
' *****  Initialize Program Specific Messages  *****
' **************************************************
'
	upperGridType		= 63
	upperMessage		= #LastMessage + 16
	upperGrid				= 255
'
	DIM messageType[upperMessage]
	DIM gridType[upperGridType]
	DIM gridTypeName$[upperGridType]
	DIM gridTypeFunc$[upperGridType]
	DIM messageSub[upperGridType, ]
	DIM gridTypeMessageFunc[upperGridType, ]
'
	DIM grid[upperGrid]
	DIM gridName$[upperGrid]
	DIM gridType$[upperGrid]
	DIM gridFunc$[upperGrid]
	DIM help$[upperGrid]
	DIM hint$[upperGrid]
	DIM image$[upperGrid]
	DIM kids[upperGrid, ]
	DIM array[upperGrid, ]
	DIM values[upperGrid, ]
	DIM callback[upperGrid]
	DIM tabArray[upperGrid, ]
	DIM menuentry[upperGrid, ]
	DIM textString$[upperGrid]
	DIM textArray$[upperGrid, ]
	DIM gridMessageFunc[upperGrid, ]
'
	DIM windowDisplay$[31]
	DIM windowInfo[31]
	DIM monitor[31]
	DIM winkid[31, ]
	DIM window[31, ]
	DIM window$[31]
	DIM tool[31]
	DIM tool$[31]
	DIM align$[15]
	DIM justify$[15]
	DIM texture$[15]
	DIM border$[31]
	DIM borderWidth[31]
	DIM can$[31]
'
'
' *********************************
' *****  backslash_literal[]  *****
' *********************************
'
	upper = 255
	DIM backslash_literal[upper]
'
	FOR i = 0 TO upper
		SELECT CASE TRUE
			CASE (i == 0x22)	: backslash_literal[i] = 1	' do backslash "
			CASE (i == 0x5C)	: backslash_literal[i] = 1	' do backslash \
			CASE (i <= 0x1F)	: backslash_literal[i] = 1	' do backslash control characters
			CASE (i >= 0x7F)	: backslash_literal[i] = 0	' no backslash non-English characters
		END SELECT
	NEXT i
'
'
'
' *******************************  tab/enter
' *****  charsetTextChar[]  *****  0x20 - 0xFF
' *******************************  (all others 0)
'
	DIM  charsetTextChar[255]
	FOR i = 0 TO 255
		SELECT CASE TRUE
			CASE (i == $$KeyTab)		: charsetTextChar[i] = i
			CASE (i == $$KeyEnter)	: charsetTextChar[i] = i
			CASE (i <= 0x1F)				: charsetTextChar[i] = 0
			CASE (i >= 0x7F)				: charsetTextChar[i] = i
			CASE ELSE								: charsetTextChar[i] = i
		END SELECT
	NEXT i
'
' *****************************  A to Z
' *****  charsetSymbol[]  *****  a to z
' *****************************  0 to 9
'
	DIM  charsetSymbol[255]
	FOR i = 0 TO 255
		SELECT CASE TRUE
			CASE ((i >= 'A') AND (i <= 'Z'))	: charsetSymbol[i] = i
			CASE ((i >= 'a') AND (i <= 'z'))	: charsetSymbol[i] = i
			CASE ((i >= '0') AND (i <= '9'))	: charsetSymbol[i] = i
			CASE ELSE													: charsetSymbol[i] = 0
		END SELECT
	NEXT i
'
' ****************************  A to Z
' *****  charsetAlpha[]  *****  a to z
' ****************************
'
	DIM  charsetAlpha[255]
	FOR i = 0 TO 255
		SELECT CASE TRUE
			CASE ((i >= 'A') AND (i <= 'Z'))	: charsetAlpha[i] = i
			CASE ((i >= 'a') AND (i <= 'z'))	: charsetAlpha[i] = i
			CASE ELSE													: charsetAlpha[i] = 0
		END SELECT
	NEXT i
'
' ***********************************  A to Z
' *****  charsetAlphaNumeric[]  *****  a to z
' ***********************************  0 to 9
'
	DIM  charsetAlphaNumeric[255]
	FOR i = 0 TO 255
		SELECT CASE TRUE
			CASE ((i >= 'A') AND (i <= 'Z'))	: charsetAlphaNumeric[i] = i
			CASE ((i >= 'a') AND (i <= 'z'))	: charsetAlphaNumeric[i] = i
			CASE ((i >= '0') AND (i <= '9'))	: charsetAlphaNumeric[i] = i
			CASE ELSE													: charsetAlphaNumeric[i] = 0
		END SELECT
	NEXT i
'
' ****************************
' *****  Default Colors  *****
' ****************************
'
	backgroundColor				=  93					' $$BrightGrey
	drawingColor					=   0					' $$Black
	lowlightColor					=   0					' $$Black
	highlightColor				= 124					' $$White
	dullColor							=  62					' $$Grey
	accentColor						= 120					' $$Yellow
	lowtextColor					=   0					' $$Black
	hightextColor					= 124					' $$White
'
'
' *************************************
' *****  Default Font Properties  *****
' *************************************
'
	defaultFontSize				=  200				' 10 point
	defaultFontWeight			=  700				' normal weight
	defaultFontItalic			=    0				' straight
	defaultFontAngle			=    0				' horizontal - left to right
'
' *******************************************
' *****  Initialize Can Constant Names  *****
' *******************************************
'
	can$[0]		= "$$Focus"
	can$[1]		= "$$Respond"
	can$[2]		= "$$Callback"
	can$[3]		= "$$InputTextArray"
	can$[4]		= "$$InputTextString"
	can$[5]		= "$$TextSelection"
'
'
' ****************************************************************
' *****  Initialize Text Align and Justify Constant Strings  *****
' ****************************************************************
'
	align$[$$AlignUpperLeft]		= "$$AlignUpperLeft"
	align$[$$AlignUpperCenter]	= "$$AlignUpperCenter"
	align$[$$AlignUpperRight]		= "$$AlignUpperRight"
	align$[$$AlignMiddleLeft]		= "$$AlignMiddleLeft"
	align$[$$AlignMiddleCenter]	= "$$AlignMiddleCenter"
	align$[$$AlignMiddleRight]	= "$$AlignMiddleRight"
	align$[$$AlignLowerLeft]		= "$$AlignLowerLeft"
	align$[$$AlignLowerCenter]	= "$$AlignLowerCenter"
	align$[$$AlignLowerRight]		= "$$AlignLowerRight"
'
	justify$[$$JustifyLeft]			= "$$JustifyLeft"
	justify$[$$JustifyCenter]		= "$$JustifyCenter"
	justify$[$$JustifyRight]		= "$$JustifyRight"
	justify$[$$JustifyBoth]			= "$$JustifyBoth"
'
'
' ******************************************************
' *****  Initialize Text Texture Constant Strings  *****
' ******************************************************
'
	texture$[$$TextureNone]			= "$$TextureNone"
	texture$[$$TextureLower4]		= "$$TextureLower4"
	texture$[$$TextureLower2]		= "$$TextureLower2"
	texture$[$$TextureLower1]		= "$$TextureLower1"
	texture$[$$TextureShadow]		= "$$TextureShadow"
	texture$[$$TextureRaise1]		= "$$TextureRaise1"
	texture$[$$TextureRaise2]		= "$$TextureRaise2"
	texture$[$$TextureRaise4]		= "$$TextureRaise4"
'
'
' ************************************
' *****  Establish Default Font  *****
' ************************************
'
	defaultFont = 0
	XgrGetFontNames (@count, @fontNames$[])			' TrueType only
	IF count THEN
		FOR i = 0 TO count - 1
			roman = $$FALSE
			utopia = $$FALSE
			fontName$ = fontNames$[i]
			IF (fontName$ = "Times New Roman") THEN roman = $$TRUE
			IF (INSTR (fontName$, "utopia")) THEN utopia = $$TRUE
			SELECT CASE TRUE
				CASE roman		:	point = 24
												fontSize = point * 20
												XgrCreateFont (@romanFont, @"Times New Roman", fontSize, 700, $$FALSE, 0)
				CASE utopia		:	point = 24
												fontSize = point * 20
												XgrCreateFont (@utopiaFont, @"utopia", fontSize, 700, $$FALSE, 0)
				EXIT FOR
			END SELECT
		NEXT i
		IFZ romanFont THEN romanFont = utopiaFont
		messageFont = romanFont
		dialogFont = romanFont
		modalFont = 0
	END IF
'
' ***************************************
' *****  Initialize Grid Functions  *****
' ***************************************
'
	XuiArea						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiBase						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiCheckBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiColor					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiColors					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiConsole				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiCoordinate			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDialog2B				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDialog3B				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDialog4B				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDirectoryBox		(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDriveBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDropBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiDropButton     (0, 0, 0, 0, 0, 0, 0, 0)
	XuiFileBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiFile 					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiFont						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiGrip						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiHint						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiImage					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiLabel					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiList						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiListBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiListButton			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiListDialog2B		(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMenu						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMenuBar				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMenuTextArea1B	(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMessage1B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMessage2B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMessage3B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiMessage4B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiPressButton		(0, 0, 0, 0, 0, 0, 0, 0)
	XuiProgress				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiPullDown				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiPushButton			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiRadioBox				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiRadioButton		(0, 0, 0, 0, 0, 0, 0, 0)
	XuiRange					(0, 0, 0, 0, 0, 0, 0, 0)
	XuiScrollBarH			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiScrollBarV			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiSolidColor     (0, 0, 0, 0, 0, 0, 0, 0)
	XuiText						(0, 0, 0, 0, 0, 0, 0, 0)
	XuiTextArea				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiTextArea3B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiTextArea4B			(0, 0, 0, 0, 0, 0, 0, 0)
	XuiTextLine				(0, 0, 0, 0, 0, 0, 0, 0)
	XuiToggleButton		(0, 0, 0, 0, 0, 0, 0, 0)
'
	Toolkit						(0, 0, 0, 0, 0, 0, 0, 0)
	Appearance        (0, 0, 0, 0, 0, 0, 0, 0)
	Report            (0, 0, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ############################
' #####  ImbeddedGui ()  #####
' ############################
'
FUNCTION  ImbeddedGui ()
	SHARED	imbedded
	SHARED	helpGrid
	SHARED	helpWindow
'
' Help Window  ( not called when debugging GuiDesigner in the environment )
'
	x = #windowBorderWidth + #windowTitleHeight + #windowTitleHeight
	y = #windowBorderWidth + #windowTitleHeight
	w = #displayWidth >> 1
	h = #displayHeight >> 1
'
	XuiHelp       (@grid, #CreateWindow, x, y, w, h, 0, 0)
	XuiSendMessage (grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" instant help ")
	XuiSendMessage (grid, #SetHelpFile, 0, 0, 0, 0, 0, @"$XBDIR/help/pde.hlp")
	XuiSendMessage (grid, #GetWindow, @helpWindow, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	XxxXgrSetHelpWindow (helpWindow)
	imbedded = $$TRUE
	helpGrid = grid
END FUNCTION
'
'
' ##############################
' #####  CreateWindows ()  #####
' ##############################
'
FUNCTION  CreateWindows ()
'	SHARED	appearanceTextGrid
'	SHARED	appearanceGrid
'	SHARED	behaviorGrid
'	SHARED	toolkitGrid
	SHARED	messageGrid
'	SHARED  reportGrid
	SHARED	helpWindow
	SHARED	helpGrid
	SHARED  hintGrid
	SHARED	fileGrid
'	SHARED	fontGrid
	SHARED  hintFont
	SHARED	romanFont
'
	XstGetApplicationEnvironment (@standalone, @nothing)
'
' Help Window  ( comment out when debugging GuiDesigner in the environment )
'
'	XuiHelp        (@grid, #CreateWindow, 200, 40, 0, 0, 0, 0)
'	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Help")
'	XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" help ")
'	XuiSendMessage ( grid, #SetHelpFile, 0, 0, 0, 0, 0, @"$XBDIR/pde.hlp")
'	XuiSendMessage ( grid, #GetWindow, @helpWindow, 0, 0, 0, 0, 0)
'	XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'	helpGrid = grid
'
' create a "hint window" AKA "tooltip window"
'
	IFZ hintGrid
		hintFont = 0
		wt = $$WindowTypeNoFrame OR $$WindowTypeNoSelect OR $$WindowTypeTopMost OR $$WindowTypeNoIcon
		XuiHint        (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Hint")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @"Hint")
		XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"Comic Sans MS")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"MS Sans Serif")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"Arial")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"utopia")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"helvetica")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"helv")
		IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		hintGrid = grid
	END IF
'
' Create a multi-purpose XuiFile Window
'
	IFZ fileGrid THEN
		wt = $$WindowTypeModal
		XuiFile        (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"File")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" file ")
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		fileGrid = grid
	END IF
'
' Create a multi-purpose XuiFont Window
'
'	IFZ fontGrid THEN
'		wt = $$WindowTypeModal
'		XuiFont        (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
'		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Font")
'		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" font ")
'		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'		fontGrid = grid
'	END IF
'
' Create a multi-purpose XuiMessage Window
'
	IFZ messageGrid THEN
		wt = $$WindowTypeModal
		XuiMessage3B   (@grid, #CreateWindow, 0, 0, 400, 300, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Message")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" message ")
		XuiSendMessage ( grid, #SetFontNumber, romanFont, 0, 0, 0, 1, 0)
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		messageGrid = grid
	END IF
'
' Create and Display the Toolkit Window
'
'	IFZ (standalone OR toolkitGrid) THEN
'		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
'		tx1 = #windowBorderWidth : ty1 = #displayHeight - 300
'		Toolkit        (@grid, #CreateWindow, tx1, ty1, 0, 0, wt, 0)
'		XuiSendMessage ( grid, #SetCallback, grid, &ToolkitCode(), -1, -1, -1, grid)
'		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Toolkit")
'		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" toolkit ")
'		XuiSendMessage ( grid, #GetValues, 0, 0, @pw, @pg, 2, 0)
'		XuiSendMessage ( grid, #GetSize, 0, 0, @w, @h, 0, 0)
'		tx2 = tx1 + w
'		ty1 = #displayHeight - h - #windowBorderWidth
'		ty2 = #displayHeight - #windowBorderWidth
'		XuiSendMessage ( grid, #ResizeWindow, tx1, ty1, w, h, 0, 0)
'		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'		toolkitGrid = grid
'	END IF
'
' Create the Appearance Window
'
'	IFZ (standalone OR appearanceGrid) THEN
'		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
'		ax1 = tx2 + #windowBorderWidth + #windowBorderWidth : ay1 = ty1
'		Appearance     (@grid, #CreateWindow, ax1, ay1, 0, 0, wt, 0)
'	  XuiSendMessage ( grid, #SetCallback, grid, &AppearanceCode(), -1, -1, -1, grid)
'		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Appearance")
'		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" appearance ")
'		XuiSendMessage ( grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
'		ax2 = ax1 + ww
'		ay1 = #displayHeight - hh - #windowBorderWidth
'		ay2 = ay1 + hh
'		XuiSendMessage ( grid, #ResizeWindow, ax1, ay1, ww, hh, 0, 0)
'		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'		appearanceGrid = grid
'	END IF
'
'	IFZ (standalone OR appearanceTextGrid) THEN
'		wt = $$WindowTypeFixedSize
'		atx1 = ax2 + #windowBorderWidth + #windowBorderWidth
'		aty1 = #displayHeight - 128 - #windowBorderWidth
'		XuiTextArea    (@grid, #CreateWindow, atx1, aty1, 256, 128, wt, 0)
'		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"AppearanceTextArray")
'		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" appearance text array ")
'		XuiSendMessage ( grid, #SetHelpString, -1, 0, 0, 0, -1, @"pde.hlp:AppearanceTextArray")
'		XuiSendMessage ( grid, #GetSize, 0, 0, @www, @hhh, 0, 0)
'		atx2 = atx1 + www
'		aty1 = #displayHeight - hhh - #windowBorderWidth
'		aty2 = aty1 + hhh
'		XuiSendMessage ( grid, #ResizeWindow, atx1, aty1, www, hhh, 0, 0)
'		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'		appearanceTextGrid = grid
'	END IF
'
' Create the Behavior Window
'
'	IFZ (standalone OR behaviorGrid) THEN
'		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
'		XuiListDialog2B (@grid, #CreateWindow, w + #windowBorderWidth + #windowBorderWidth + #windowBorderWidth, #windowTitleHeight + #windowBorderWidth, 440, 440, wt, 0)
'		XuiSendMessage  ( grid, #SetCallback, grid, &BehaviorCode(), -1, -1, -1, grid)
'		XuiSendMessage  ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Behavior")
'		XuiSendMessage  ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" behavior ")
'		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:Behavior")
'		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 1, @"pde.hlp:BehaviorList")
'		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 2, @"pde.hlp:BehaviorText")
'		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 3, @"pde.hlp:BehaviorEnter")
'		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 4, @"pde.hlp:BehaviorCancel")
'		XuiSendMessage  ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'		behaviorGrid = grid
'	END IF
'
' Create the ReportMessage window
'
	IFZ reportGrid THEN
		wt = $$WindowTypeFixedSize
		x = #windowBorderWidth
		y = #windowBorderWidth + #windowTitleHeight
		Report         (@grid, #CreateWindow, x, y, 360, 224, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Report")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" report message ")
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		reportGrid = grid
	END IF
'
' test XuiConsole in the PDE
'
'	XuiConsole     (@console, #CreateWindow, 4, 200, 512, 200, 0, 0)
'	XuiSendMessage ( console, #DisplayWindow, 0, 0, 0, 0, 0, 0)
'	XuiSendMessage ( console, #SetGridProperties, -1, 0, 0, 0, 0, 0)
'	XgrProcessMessages (-2)
'
'	FOR i = 0 TO 10000
'		i$ = STRING$(i) + "\n"
'		XuiSendMessage (console, #Print, 0, 0, 0, 0, 0, @i$)
'		XgrProcessMessages (0)
'	NEXT i
'
	XgrProcessMessages (-2)
END FUNCTION
'
'
' ############################
' #####  InitWindows ()  #####
' ############################
'
FUNCTION  InitWindows ()
	SHARED  toolkitGrid
'
	XuiSendMessage (toolkitGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' #########################
' #####  Behavior ()  #####
' #########################
'
FUNCTION  Behavior (workGrid)
	SHARED	behaviorGrid
'
	IF (workGrid <= 0) THEN RETURN
	XuiSendMessage (workGrid, #GetGridType, @gt, 0, 0, 0, 0, 0)
	XuiSendMessage (workGrid, #GetGridTypeName, 0, 0, 0, 0, 0, @i$)
	XuiSendMessage (workGrid, #GetMessageFuncArray, 0, 0, 0, 0, 0, @mf[])
	XuiSendMessage (workGrid, #GetMessageSubArray, 0, 0, 0, 0, 0, @mh[])
	uf = UBOUND(mf[])
	uh = UBOUND(mh[])
	up = MAX(uh,uf) << 1
	i$ = TRIM$(i$)
	ii = 0
	DIM b$[up]
	FOR m = 1 TO up
		b$ = ""
		f$ = ""
		s$ = ""
		name$ = ""
		mess = $$FALSE
		messSub = $$FALSE
		messFunc = $$FALSE
		IF (m <= uh) THEN messSub = mh[m]
		IF (m <= uf) THEN messFunc = mf[m]
		IF messFunc THEN
			XxxGetLabelGivenAddress (messFunc, @label$[])
'			addrFunc$ = HEX$(messFunc,8)
			FOR j = 0 TO UBOUND (label$[])
				IF label$[j] THEN
					label$ = label$[j]
					IF (label${0} = '_') THEN
						a = INSTR(label$, "@")
						IF a THEN
							name$ = MID$(label$, 2, a-2)
							EXIT FOR
						END IF
					END IF
				END IF
			NEXT j
		END IF
		IF (messSub OR messFunc) THEN
			XgrMessageNumberToName (m, @mess$)
			b$ = LJUST$(mess$, 24)
			IF messFunc THEN b$[ii] = b$ + "    " + name$ + "()" : INC ii
			IF messSub  THEN b$[ii] = b$ + "SUB " + mess$ : INC ii
		END IF
	NEXT m
	IF b$[0] THEN
		REDIM b$[ii-1]
		XstQuickSort (@b$[], @empty[], 0, ii-1, $$SortCaseInsensitive)
		title$ = "message processing functions for " + i$
		XuiSendMessage (behaviorGrid, #SetTextString, 0, 0, 0, 0, 1, title$)
		XuiSendMessage (behaviorGrid, #SetTextArray, 0, 0, 0, 0, 2, @b$[])
		XuiSendMessage (behaviorGrid, #SetTextString, 0, 0, 0, 0, 3, "")
		XuiSendMessage (behaviorGrid, #DisplayWindow, 0, 0, 0, 0, 0, 0)
'		XuiSendMessage (behaviorGrid, #GetModalInfo, 0, 0, 0, 0, 0, 0)
	END IF
END FUNCTION
'
'
' #############################
' #####  BehaviorCode ()  #####
' #############################
'
FUNCTION  BehaviorCode (grid, message, v0, v1, v2, v3, r0, r1)
'
	$Dialog		= 0
	$Label		= 1
	$List			= 2
	$Text			= 3
	$Button0	= 4
	$Button1	= 5
'
	IF (message = #Callback) THEN
		callback = r1
		message = r1
	END IF
'
	SELECT CASE message
		CASE #Selection	: GOSUB Selection
		CASE #TextEvent	: GOSUB TextEvent
	END SELECT
	RETURN
'
'
' *****  Selection  *****
'
SUB Selection
	XuiSendMessage (grid, #HideWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	key = (v2 AND 0x00FF)
	IF ((key = 0x1B) OR (key = 0x0D)) THEN
		XuiSendMessage (grid, #HideWindow, 0, 0, 0, 0, 0, 0)
	END IF
END SUB
END FUNCTION
'
'
' #######################
' #####  Design ()  #####
' #######################
'
FUNCTION  Design (wingrid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED  appearanceTextGrid
	SHARED  appearanceGrid
	SHARED  behaviorGrid
	SHARED  toolkitGrid
	SHARED	gripGrid,  lastSelectGrid,  selectGrid
	SHARED  selectX1,  selectY1,  selectX2,  selectY2
	SHARED	backgroundColor
	SHARED	testMode
	SHARED	window[]
	SHARED	kids[]
	SHARED	upperMessage
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	STATIC	SUBADDR  sub[]
	STATIC	window
	STATIC	graph
	STATIC	upper
	STATIC	index
	STATIC	win[]
	STATIC	kid[]
	STATIC  lastMove
	STATIC  downGrip
	STATIC	downTime
	STATIC	graphDownTime
'
	$graph		= 0
'
	IFZ sub[] THEN GOSUB Initialize
	IF (message <= 0) THEN PRINT "Design() : error : (message <= 0)" : RETURN
	IF (message > upperMessage) THEN PRINT "Design() : error : (message > upperMessage)" : RETURN
'
'	XgrMessageNumberToName (message, @message$)
'	PRINT "Design() : "; wingrid;; message$;; v0;; v1;; v2;; v3;;; r0;; r1
	IF sub[message] THEN
		GOSUB @sub[message]
	ELSE
		XuiWindow (wingrid, message, @v0, @v1, @v2, @v3, @r0, @r1)
	END IF
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	IF (r1 != #Destroyed) THEN
		XuiCallback (wingrid, #GetCallbackArgs, 0, 0, 0, 0, @rr0, 0)
		XuiReportMessage (wingrid, message, v0, v1, v2, v3, r0, r1)
'		PRINT "Design : hidden r0 = "; rr0
	END IF
	message = r1
	callback = message
	XgrMessageNumberToName (message, @message$)
END SUB
'
'
' *****  CreateWindow  *****
'
SUB CreateWindow
	pastX = #displayWidth - #windowBorderWidth
	pastY = #displayHeight - #windowBorderWidth
	IF (v2 < 8) THEN v2 = ((pastX >> 2 + 64) AND -16) + 8
	IF (v2 > pastX) THEN v2 = ((pastX >> 2 + 64) AND -16) + 8
	IF (v3 < 8) THEN v3 = ((pastY >> 2 + 64) AND -16) + 8
	IF (v3 > pastY) THEN v3 = ((pastY >> 2 + 64) AND -16) + 8
	IF (v0 < #windowBorderWidth) THEN v0 = pastX - v2
	IF (v1 < (#windowBorderWidth + #windowTitleHeight)) THEN v1 = #windowBorderWidth + #windowTitleHeight
	IF ((v0 + v2) > pastX) THEN v0 = #displayWidth - v2 - #windowBorderWidth
	IF ((v1 + v3) > pastY) THEN v1 = #displayHeight - v3 - #windowBorderWidth
	IF (v0 < #windowBorderWidth) THEN v0 = #windowBorderWidth
	IF (v1 < (#windowBorderWidth + #windowTitleHeight)) THEN v1 = #windowBorderWidth + #windowTitleHeight
'
	XuiWindow      (@window, #WindowCreate, @v0, @v1, @v2, @v3, 0, 0)
	XuiWindow      ( window, #WindowSetFunction, &Design(), 0, 0, 0, 0, 0)
	XuiBase        (@grid, #Create, 0, 0, @v2, @v3, @window, 0)
	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Design")
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, 0, @"DesignWindow")
	windowInfo[window].graph = grid
	wingrid = grid
	r0 = window
	window = 0
	graph = 0
END SUB
'
'
' *****  WindowDestroy  *****
'
SUB WindowDestroy
	IF selectGrid THEN DeselectGrid (selectGrid)
	XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
	gripGrid = 0
	window = 0
	graph = 0
END SUB
'
'
' *****  WindowDestroyed  *****
'
SUB WindowDestroyed
	XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
	ToolkitCode (wingrid, message, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  WindowDisplay  *****
'
SUB WindowDisplay
	XuiWindow (wingrid, #WindowDisplay, v0, v1, v2, v3, r0, r1)
	graph = windowInfo[wingrid].graph
	window = wingrid
END SUB
'
'
' *****  WindowHide  *****
'
SUB WindowHide
	XuiWindow (wingrid, #WindowHide, v0, v1, v2, v3, r0, r1)
	window = 0
	graph = 0
END SUB
'
'
'
' *****  WindowKeyDown  *****
'
SUB WindowKeyDown
	IF (v2{$$KeyKind} = $$KeyKindVirtual) THEN
		IF (v2{$$KeyVirtual} = 0x2E) THEN
			IF selectGrid THEN
				XgrGetGridBoxWindow (gripGrid, @x1, @y1, @x2, @y2)
				width = x2 - x1 + 1 : height = y2 - y1 + 1
				XuiSendMessage (selectGrid, #Destroy, 0, 0, 0, 0, 0, 0)
				XuiSendMessage (gripGrid, #Destroy, 0, 0, 0, 0, 0, 0)
				selectGrid = 0
				gripGrid = 0
				XuiSendMessage (graph, #RedrawWindow, x1, y1, width, height, 0, 0)
				XuiSendMessage (appearanceTextGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
				XuiSendMessage (appearanceGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
				XuiSendMessage (behaviorGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
				EXIT SUB
			END IF
		END IF
	END IF
	XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  WindowShow  *****
'
SUB WindowShow
	XuiWindow (wingrid, #WindowShow, v0, v1, v2, v3, r0, r1)
	graph = windowInfo[wingrid].graph
	window = wingrid
END SUB
'
'
' *****  MouseDown  *****
'
' If message is within gripGrid, redirect message to gripGrid, done.
' Deselect selectGrid and erase gripGrid.
' If message is to background graphGrid, done.
' selectGrid = grid  (new selectGrid, create, draw gripGrid).
'
SUB MouseDown
	IFZ graph THEN EXIT SUB
	XgrGetGridWindow (grid, @win)
	IF (win != window) THEN EXIT SUB
	IF testMode THEN
		XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
		EXIT SUB
	END IF
'
'	PRINT "Design() : MouseDown.A : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; v0;; v1;;;; selectGrid;; gripGrid;; downGrip
	inside = $$FALSE
	IF gripGrid THEN
		inGrid = gripGrid
		GOSUB InsideGridTest
	END IF
'
	IF inside THEN																' inside gripGrid
		IF (downTime AND ((v3 - downTime) < 400)) THEN
			IF ((v2 AND $$ShiftBit) OR (v2 AND $$CtrlBit)) THEN
				Behavior (selectGrid)
			ELSE
				AppearanceCode (appearanceGrid, #DisplayWindow, selectGrid, 0, 0, 0, 0, 0)
			END IF
			DeselectGrid (selectGrid)
			downGrip = $$TRUE
			downTime = v3
'			PRINT "Design() : MouseDown.B : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; v0;; v1;;;; selectGrid;; gripGrid;; downGrip
		ELSE
			xx = v0 : yy = v1
			IF (grid != gripGrid) THEN
				XgrConvertLocalToWindow (grid, v0, v1, @xWin, @yWin)
				XgrConvertWindowToLocal (gripGrid, xWin, yWin, @xx, @yy)
			END IF
			XuiGrip (gripGrid, #MouseDown, xx, yy, v2, v3, 0, gripGrid)
			downGrip = $$TRUE
			downTime = v3
'			PRINT "Design() : MouseDown.C : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; v0;; v1;;;; selectGrid;; gripGrid;; downGrip
		END IF
		RETURN
	END IF
'
	IF gripGrid THEN
		IF ((v2 AND $$ShiftBit) OR ((v2 AND 0x0F) = 2)) THEN GOSUB MoveEnclosed
		IF (downTime AND ((v3 - downTime) < 400)) THEN
			AppearanceCode (appearanceGrid, #DisplayWindow, selectGrid, 0, 0, 0, 0, 0)
		END IF
		DeselectGrid (selectGrid)										' deselect selectGrid
		downTime = v3
	END IF
'
	IF (grid = graph) THEN
		IF (graphDownTime AND ((v3 - graphDownTime) < 400)) THEN
			AppearanceCode (appearanceGrid, #DisplayWindow, graph, 0, 0, 0, 0, 0)
			IF selectGrid THEN DeselectGrid (selectGrid)
			graphDownTime = 0
		END IF
		graphDownTime = v3
'		PRINT "Design() : MouseDown.D : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; v0;; v1;;;; selectGrid;; gripGrid;; downGrip
		RETURN							' background graph grid
	END IF
'
	gg = grid
	DO
		IF grid[gg].selectable THEN EXIT DO					' got the selectable grid
		parent = grid[gg].parent
		IFZ parent THEN EXIT DO
		gg = parent
	LOOP
	downTime = v3																	' note time for double click watch
	IF grid[gg].selectable THEN SelectGrid (gg)		' select new select grid
	IF gripGrid THEN
		xx = v0 : yy = v1
		IF (grid != gg) THEN
			XgrConvertLocalToWindow (grid, v0, v1, @x, @y)
			XgrConvertWindowToLocal (gg, x, y, @xx, @yy)
		END IF
		XuiGrip (gripGrid, #MouseDown, xx, yy, v2, v3, 0, gripGrid)
'		XgrSetMouseFocus (window, graph)
		downGrip = $$TRUE
	END IF
'	PRINT "Design() : MouseDown.E : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; v0;; v1;;;; selectGrid;; gripGrid;; downGrip
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
'	PRINT "Design() : MouseDrag.A : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; xx;; yy;;;; graph;; selectGrid;; gripGrid; downGrip
	IF testMode THEN
		XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
		EXIT SUB
	END IF
'
	xx = v0
	yy = v1
	IF gripGrid THEN
		IF downGrip THEN
			IF (grid != gripGrid) THEN
'				PRINT "Adjust"; grid; " to"; gripGrid
				XgrConvertLocalToWindow (grid, v0, v1, @xWin, @yWin)
				XgrConvertWindowToLocal (gripGrid, xWin, yWin, @xx, @yy)
				XuiGrip (gripGrid, #MouseDrag, xx, yy, v2, v3, r0, gripGrid)
				EXIT SUB
			END IF
		END IF
	END IF
	XuiWindow (wingrid, message, xx, yy, v2, v3, r0, grid)
'	PRINT "Design() : MouseDrag.B : "; grid;; mmessage$;; v0;; v1;; v2;; v3;; r1;;;; xx;; yy;;;; graph;; selectGrid;; gripGrid; downGrip
END SUB
'
'
' *****  MouseEnter  *****
'
SUB MouseEnter
	GOSUB MouseMove
END SUB
'
'
' *****  MouseMove  *****  change cursor as appropriate
'
SUB MouseMove
	IFZ graph THEN EXIT SUB
	XgrGetGridWindow (grid, @win)
	IF (win != window) THEN EXIT SUB
	IF testMode THEN
		XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
		EXIT SUB
	END IF
'
	xx = v0
	yy = v1
	IF gripGrid THEN
		XgrGetGridBoxLocal (gripGrid, @x1, @y1, @x2, @y2)
		XgrConvertLocalToWindow (grid, v0, v1, @xWin, @yWin)
		XgrConvertWindowToLocal (gripGrid, xWin, yWin, @xx, @yy)
		IF (xx >= x1) THEN
			IF (yy >= y1) THEN
				IF (xx <= x2) THEN
					IF (yy <= y2) THEN
						XuiGrip (gripGrid, #MouseMove, xx, yy, v2, v3, r0, gripGrid)
						lastMove = gripGrid
						EXIT SUB
					END IF
				END IF
			END IF
		END IF
	END IF
'
	IF (grid = graph) THEN
		IF (lastMove = gripGrid) THEN XgrSetCursor (#cursorPlus, @cursor)
		XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
		lastMove = graph
		EXIT SUB
	END IF
'
	lastMove = grid
	gg = grid
	IF (gg != gripGrid) THEN
		DO
			IF grid[gg].selectable THEN EXIT DO
			parent = grid[gg].parent
			IFZ parent THEN EXIT DO
			gg = parent
		LOOP
	END IF
'
	xx = v0 : yy = v1
	IF (gg != r1) THEN
		XgrConvertLocalToWindow (grid, v0, v1, @x, @y)
		XgrConvertWindowToLocal (gg, x, y, @xx, @yy)
	END IF
'
	cur = $$FALSE
	XuiGetGridRegion (gg, xx, yy, @region, @cur, @default)
	IF cur THEN XgrSetCursor (cur, @cursor)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	downGrip = $$FALSE
	xx = v0
	yy = v1
	IF gripGrid THEN
		XgrGetGridBoxLocal (gripGrid, @x1, @y1, @x2, @y2)
		XgrConvertLocalToWindow (grid, v0, v1, @xWin, @yWin)
		XgrConvertWindowToLocal (gripGrid, xWin, yWin, @xx, @yy)
		IF (xx >= x1) THEN
			IF (yy >= y1) THEN
				IF (xx <= x2) THEN
					IF (yy <= y2) THEN
						XuiGrip (gripGrid, #MouseUp, xx, yy, v2, v3, r0, gripGrid)
						EXIT SUB
					END IF
				END IF
			END IF
		END IF
	END IF
	XuiWindow (wingrid, message, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  MoveEnclosed  *****
'
SUB MoveEnclosed
	IFZ kids[graph,] THEN PRINT "Design() : MoveEnclosed : error : (kids[graph,] is empty)" : RETURN
'	XgrGetGridBoxWindow (selectGrid, @sx1, @sy1, @sx2, @sy2)
	XgrGetGridBoxWindow (gripGrid, @gx1, @gy1, @gx2, @gy2)
	sx1 = selectX1
	sy1 = selectY1
	sx2 = selectX2
	sy2 = selectY2
	dx = gx1 - sx1
	dy = gy1 - sy1
	FOR i = 1 TO UBOUND(kids[graph, ])
		g = kids[graph,i]
		IF g THEN
			IF (g != gripGrid) THEN
				XgrGetGridBoxWindow (g, @xx1, @yy1, @xx2, @yy2)
				IF (xx1 < sx1) THEN DO NEXT
				IF (yy1 < sy1) THEN DO NEXT
				IF (xx2 > sx2) THEN DO NEXT
				IF (yy2 > sy2) THEN DO NEXT
				XgrSetGridPositionAndSize (g, xx1 + dx, yy1 + dy, -1, -1)
				XgrRedrawWindow (window, $$TRUE, sx1, sy1, sx2-sx1+1, sy2-sy1+1)
			END IF
		END IF
	NEXT i
END SUB
'
'
' *****  InsideGridTest  *****
'
SUB InsideGridTest
	inside = $$FALSE
	IF inGrid THEN
		XgrConvertLocalToWindow (grid, v0, v1, @xWin, @yWin)
		XgrGetGridBoxWindow (inGrid, @x1, @y1, @x2, @y2)
		SELECT CASE TRUE
			CASE (xWin < x1)	: inside = $$FALSE
			CASE (xWin > x2)	: inside = $$FALSE
			CASE (yWin < y1)	: inside = $$FALSE
			CASE (yWin > y2)	: inside = $$FALSE
			CASE ELSE					: inside = $$TRUE
		END SELECT
	END IF
END SUB
'
'
' *****  WindowRedraw  *****
'
SUB WindowRedraw
	XuiWindow (wingrid, #WindowRedraw, v0, v1, v2, v3, r0, r1)
'
	IF gripGrid THEN
		IF ((v2 <= 0) OR (v3 <= 0)) THEN v2 = 0 : v3 = 0
		IFZ v2 THEN
			xx1 = 0
			yy1 = 0
			www = 0
			hhh = 0
			redraw = $$TRUE
		ELSE
			redraw = $$FALSE
			x1Win = v0
			y1Win = v1
			x2Win = v0 + v2 - 1
			y2Win = v1 + v3 - 1
			XgrGetGridBoxLocal (gripGrid, @x1, @y1, @x2, @y2)
			XgrGetGridBoxWindow (gripGrid, @gx1, @gy1, @gx2, @gy2)
			IF (gx1 <= x2Win) THEN
				IF (gy1 <= y2Win) THEN
					IF (gx2 >= x1Win) THEN
						IF (gy2 >= y1Win) THEN
							xx1 = x1Win - gx1
							yy1 = y1Win - gy1
							xx2 = x2Win - gx1
							yy2 = y2Win - gy1
							IF (xx1 < 0) THEN xx1 = 0
							IF (yy1 < 0) THEN yy1 = 0
							IF (xx2 > x2) THEN xx2 = x2
							IF (yy2 > y2) THEN yy2 = y2
							www = xx2 - xx1 + 1
							hhh = yy2 - yy1 + 1
							redraw = $$TRUE
						END IF
					END IF
				END IF
			END IF
		END IF
	END IF
'
	IF redraw THEN XuiGrip (gripGrid, #RedrawGrid, xx1, yy1, www, hhh, r0, gripGrid)
END SUB
'
'
' *****  WindowResized  *****
'
SUB WindowResized
	base = windowInfo[window].grid
	XuiSendMessage (base, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	minX = $$MAX : minY = $$MAX
	maxX = $$MIN : maxY = $$MIN
	IF gripGrid THEN
		XgrGetGridBoxWindow (gripGrid, @x1, @y1, @x2, @y2)
		IF (x1 < minX) THEN minX = x1
		IF (y1 < minY) THEN minY = y1
		IF (x2 > maxX) THEN maxX = x2
		IF (y2 > maxY) THEN maxY = y2
	END IF
	FOR i = 1 TO upper
		g = k[i]
		IFZ g THEN DO NEXT
		IF (g = base) THEN PRINT "Design() : WindowResized : error ::: (grid is its own kid)" : DO NEXT
		IF (g != selectGrid) THEN
			XgrGetGridBoxWindow (g, @x1, @y1, @x2, @y2)
			IF (x1 < minX) THEN minX = x1
			IF (y1 < minY) THEN minY = y1
			IF (x2 > maxX) THEN maxX = x2
			IF (y2 > maxY) THEN maxY = y2
		END IF
	NEXT i
'
	IF (minY < 0) THEN PRINT "Design() : Window : error : (grid too far up)" : EXIT SUB
	IF (minX < 0) THEN PRINT "Design() : Window : error : (grid too far left)" : EXIT SUB
	XgrGetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
'
	maxWidth = maxX + 1
	maxHeight = maxY + 1
	IF (v2 < maxWidth) THEN v2 = maxWidth : adjust = $$TRUE
	IF (v3 < maxHeight) THEN v3 = maxHeight : adjust = $$TRUE
	IF v2{2,0} THEN v2 = v2 + 3 AND -4 : adjust = $$TRUE
	IF v3{2,0} THEN v3 = v3 + 3 AND -4 : adjust = $$TRUE
	IF adjust THEN
		IF (base != graph) THEN PRINT "Design() : Window: (windowInfo[window].grid != graph)" : EXIT SUB
		XgrMessagesPending (@count)
		IF count THEN
			XgrPeekMessage (@wg, @mess, 0, 0, 0, 0, 0, 0)
			IF ((mess = #WindowRedraw) AND (wg = window)) THEN
				XgrDeleteMessages (1)
			END IF
		END IF
		XuiSendMessage (base, #Resize, -1, -1, v2, v3, 0, 0)
		XuiWindow (window, #WindowResize, v0, v1, v2, v3, 0, 0)
	ELSE
		XuiWindow (window, #WindowResized, v0, v1, v2, v3, 0, 0)
	END IF
END SUB
'
'
' *****  WindowMouse  *****
'
SUB WindowMouse
	IFZ r1 THEN EXIT SUB								' non-Client message
	SELECT CASE message
		CASE #WindowMouseDown		: mmessage = #MouseDown
		CASE #WindowMouseDrag		: mmessage = #MouseDrag
		CASE #WindowMouseEnter	: mmessage = #MouseEnter
		CASE #WindowMouseExit		: mmessage = #MouseExit
		CASE #WindowMouseMove		: mmessage = #MouseMove
		CASE #WindowMouseUp			: mmessage = #MouseUp
	END SELECT
'
' send no mouse messages to deselected grids
' but do forward mouse messages to grip grid
'
	grid = r1
	IF (grid = selectGrid) THEN
		IF gripGrid THEN XuiSendMessage (gripGrid, mmessage, v0, v1, v2, v3, r0, r1)
		EXIT SUB
	END IF
'
	IF sub[mmessage] THEN
		GOSUB @sub[mmessage]
	ELSE
		XuiWindow (wingrid, message, @v0, @v1, @v2, @v3, @r0, @r1)
	END IF
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	upper = 7
	DIM win[upper]
	DIM kid[upper]
	DIM sub[upperMessage]
	sub[#Callback]					= SUBADDRESS (Callback)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#MouseDown]					= SUBADDRESS (MouseDown)
	sub[#MouseDrag]					= SUBADDRESS (MouseDrag)
	sub[#MouseEnter]				= SUBADDRESS (MouseEnter)
	sub[#MouseMove]					= SUBADDRESS (MouseMove)
	sub[#MouseUp]						= SUBADDRESS (MouseUp)
	sub[#WindowDestroy]			= SUBADDRESS (WindowDestroy)
	sub[#WindowDestroyed]		= SUBADDRESS (WindowDestroyed)
	sub[#WindowDisplay]			= SUBADDRESS (WindowDisplay)
	sub[#WindowHide]				= SUBADDRESS (WindowHide)
	sub[#WindowKeyDown]			= SUBADDRESS (WindowKeyDown)
	sub[#WindowMinimize]		= SUBADDRESS (WindowHide)
	sub[#WindowMouseDown]		= SUBADDRESS (WindowMouse)
	sub[#WindowMouseDrag]		= SUBADDRESS (WindowMouse)
	sub[#WindowMouseEnter]	= SUBADDRESS (WindowMouse)
	sub[#WindowMouseExit]		= SUBADDRESS (WindowMouse)
	sub[#WindowMouseMove]		= SUBADDRESS (WindowMouse)
	sub[#WindowMouseUp]			= SUBADDRESS (WindowMouse)
	sub[#WindowRedraw]			= SUBADDRESS (WindowRedraw)
	sub[#WindowResized]			= SUBADDRESS (WindowResized)
	sub[#WindowShow]				= SUBADDRESS (WindowShow)
END SUB
END FUNCTION
'
'
' ########################
' #####  Toolkit ()  #####
' ########################
'
FUNCTION  Toolkit (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1$[]))
	SHARED	resizeBorder
	SHARED	titleBorder
	SHARED	tool$[]
	SHARED	tool[]
	SHARED	kids[]
	SHARED	values[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	CALLBACK	callback[]
	SHARED	GRID	grid[]
	SHARED	GRID	gridType[]
	SHARED	UBYTE  charsetAlpha[]
	STATIC	SUBADDR  sub[]
	STATIC	lastTool
	STATIC	Toolkit
	STATIC	handle[]
	STATIC	library$[]
	FUNCADDR  entry ()
	FUNCADDR  func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, ANY)
'
	$Toolkit	= 0
	$Check		= 1
	$Menu			= 2
	$Label		= 3
	$Text			= 4
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, Toolkit) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	tool = -1
	upperTool = 31
	DIM tool[upperTool]
	DIM tool$[upperTool]
	DIM image$[upperTool]
	INC tool:	tool[tool] = 0 : tool$[tool] = " Toolkit "
	INC tool:	tool[tool] = 0 : tool$[tool] = " TestMode "
	INC tool:	tool[tool] = 0 : tool$[tool] = " _Window  _Grid"
	INC tool: tool[tool] = 0 : tool$[tool] = "\x1F WindowName \x1F"
	INC tool:	tool[tool] = 0 : tool$[tool] = " Selected Window"
	INC tool:	tool[tool] = 0 : tool$[tool] = " Another "
'
	name$ = "$XBDIR" + $$PathSlash$ + "templates" + $$PathSlash$ + "xtoolkit.xxx"
	XstLoadStringArray (@name$, @toolkit$[])
	IFZ toolkit$[] THEN XuiMessage ("Toolkit()\nError\nFile Not Found\n" + name$) : RETURN
	upper = UBOUND (toolkit$[])
'
	toolCount = 0
	FOR kit = 0 TO upper
		toolkit$ = TRIM$(toolkit$[kit])
		IFZ toolkit$ THEN DO NEXT
		IF toolkit${0} == ''' THEN DO NEXT								' entry commented out
		name$ = "$XBDIR" + $$PathSlash$ + "templates" + $$PathSlash$ + toolkit$
		XstLoadStringArray (@name$, @kit$[])							' load next toolkit spec
		IF kit$[] THEN
			FOR g = 0 TO UBOUND (kit$[])
				handle = 0
				kit$ = kit$[g]
				IFZ kit$ THEN DO NEXT
				IF kit${0} == ''' THEN DO NEXT								' comment line
				ParseLine (kit$[g], @line$[])									' break line at tabs
				IF line$[] THEN
					uline = UBOUND (line$[])
					IF (uline >= 4) THEN												' 4 entries minimum
						filename$ = line$[0]
						gridType$ = line$[1]
						gridFunc$ = line$[2]
						gridFile$ = line$[3]
						gridKind$ = line$[4]
'
						IFZ gridType$ THEN DO NEXT
						IFZ gridFunc$ THEN DO NEXT
						IFZ gridFile$ THEN PRINT "Toolkit() : No tool image file name"
						IFZ gridKind$ THEN PRINT "Toolkit() : No grid kind name"
'
' If the grid isn't in the imbedded default toolkit, try to load the
' accessory toolkit library that contains the grid, initialize the
' library, and hope the grid becomes known to GuiDesigner as a result.
'
						IF (filename$ != "xb") THEN
							handle = $$FALSE
							upper = UBOUND (library$[])
							FOR i = 0 TO upper
								IF (filename$ = library$[i]) THEN
									handle = handle[i]
									EXIT FOR
								END IF
							NEXT i
							IFZ handle THEN
								dllname$ = filename$ + ".dll"
								handle = LoadLibraryA (&dllname$)
								IFZ handle THEN DO NEXT											' can't open the dll
								entry = GetProcAddress (handle, &"Entry")
								IFZ entry THEN DO NEXT											' can't initialize the dll
								@entry ()
								upper = upper + 1
								REDIM handle[upper]
								REDIM library$[upper]
								handle[upper] = handle
								library$[upper] = filename$
							END IF
						END IF
'
						XgrGridTypeNameToNumber (gridType$, @gridType)
						IF (gridType <= 0) THEN PRINT "Toolkit() : error : no grid type number for "; gridType$ : DO NEXT
						IF handle THEN
							gridFunc = GetProcAddress (handle, &gridType$)
							gridType[gridType].gridFunc = gridFunc
						ELSE
							XuiGridTypeToGridFunc (gridType, @gridFunc)
						END IF
						IFZ gridFunc THEN PRINT "Toolkit() : error ::: no grid func address for "; gridType$
'
						INC tool
						INC toolCount
						IF (tool >= upperTool) THEN
							upperTool = upperTool + 16
							REDIM image$[upperTool]
							REDIM tool$[upperTool]
							REDIM tool[upperTool]
						END IF
						tool[tool] = gridType
						tool$[tool] = gridType$
						image$[tool] = "$XBDIR" + $$PathSlash$ + "images" + $$PathSlash$ + gridFile$
					END IF
				END IF
			NEXT g
		END IF
	NEXT kit
'
' all the tools are loaded in
'
	DEC toolCount
	lastTool = tool
	upperTool = tool + ((toolCount OR 3) - toolCount)
	REDIM tool[upperTool]
	REDIM tool$[upperTool]
'
	h = 20
	width = 132
'
' Create the toolkit grids
'
	t = 0
	x = 0 : y = 0
	XuiCreateGrid  (@grid, Toolkit, @v0, @v1, @v2, @v3, r0, r1, &Toolkit())
	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Toolkit")
	XuiSendMessage ( grid, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:Toolkit")
	XuiSendMessage ( grid, #SetBorder, $$BorderFrame, $$BorderFrame, $$BorderFrame, 0, 0, 0)
	x = x + 4
	y = y + 4
	INC t
'
' *****  "TestMode"  *****  CheckBox
'
	XuiCheckBox    (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Toolkit(), -1, -1, t, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ToolkitTestMode")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" test mode ")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:ToolkitTestMode")
	y = y + h
	INC t
'
' *****  Menu  *****
'
	DIM a$[13]
	a$[ 0] = "_Window  "
	a$[ 1] = " _New"
	a$[ 2] = " _Hide"
	a$[ 3] = " _Load"
	a$[ 4] = " _Save"
	a$[ 5] = " _Delete"
	a$[ 6] = " _ToFunction"
	a$[ 7] = " _FromFunction"
	a$[ 8] = " _CloseToolkit"
	a$[ 9] = "_Grid  "
	a$[10] = " _Appearance"
	a$[11] = " _Behavior"
	a$[12] = " _SortKids"
	a$[13] = " _Delete"
	XuiMenu        (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Toolkit(), -1, -1, t, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ToolkitMainMenu")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @"pde.hlp:ToolkitMainMenu")
	XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @a$[])
	y = y + h
	INC t
'
' *****  "WindowName"  *****  Label
'
	XuiLabel       (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ToolkitDesignWindowLabel")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:ToolkitDesignWindowLabel")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" window name ")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleCenter, $$JustifyCenter, 0, 0, 0, 0)
	y = y + h
	INC t
'
'
' *****  "SelectedWindow"  *****  TextLine
'
	XuiTextLine    (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Toolkit(), -1, -1, t, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ToolkitDesignWindowName")
	XuiSendMessage ( g, #SetHelpString, -1, 0, 0, 0, 0, @"pde.hlp:ToolkitDesignWindowName")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, "")
	y = y + h
	INC t
'
' *****  "Another"  *****  PushButton
'
	XuiPushButton  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Toolkit(), -1, -1, t, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ToolkitAnother")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:ToolkitAnother")
	XuiSendMessage ( g, #SetHintString, 0, 0, 0, 0, 0, @"another grid of same type & size")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, " another ")
	y = y + h
	INC t
'
' *****  Toolkit Buttons  *****  Area, Graph, etc...
'
	FOR t = t TO upperTool
		XuiPushButton (@g, #Create, 4, 4, 32, 32, r0, grid)
		IF tool[t] THEN
			XuiSendMessage ( g, #SetCallback, grid, &Toolkit(), -1, -1, t, grid)
			XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, "Toolkit" + TRIM$(tool$[t]))
			XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, 0, "pde.hlp:Toolkit" + TRIM$(tool$[t]))
			XuiSendMessage ( g, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderLower1, 0, 0, 0)
			XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, image$[t])
		END IF
	NEXT t
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"Toolkit")
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	dx = 4
	dy = 4
	columns = 4
	XuiGetKidArray (grid, #GetKidArray, 0, 0, 0, @upperTool, 0, @k[])
	rows = (upperTool - 4) >> 2					' # of rows of tool buttons
	upperTool = UBOUND (tool[])
	IF (upperTool < 4) THEN EXIT SUB		' disaster
'
	maxWidth = 0
	maxHeight = 0
	FOR i = 1 TO 5
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 0)
		maxWidth = MAX (maxWidth, width)
		maxHeight = MAX (maxHeight, height)
	NEXT i
	hh = maxHeight + 1
	ww = (maxWidth + 4) AND -4
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
'
	totalWidth = bw + bw + 128
	totalHeight = bw + bw + (5 * hh) + (rows * 32)
	XuiPositionGrid (grid, 0, 0, totalWidth, totalHeight)		' resize toolkit
'
	x = bw
	y = bw
	w = 128
	h = hh
	FOR t = 1 TO 5
		XuiSendToKid (grid, #Resize, x, y, w, h, t, 0)
		y = y + h
	NEXT t
'
	tool = 0
	sx = x : sy = y
	FOR t = t TO upperTool
		XuiSendToKid (grid, #Resize, bw + (tool * 32), y, 32, 32, t, 0)
		INC tool
		IF (tool = 4) THEN tool = 0 : y = y + 32
	NEXT t
'
	y = y + bw
	IF (y != totalHeight) THEN PRINT "Toolkit() : Height Calculation"
	v2 = totalWidth
	v3 = totalHeight
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#Resize]							= 0
'
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF sub[0] THEN PRINT "Toolkit() : Initialize : error ::: (undefined message)"
	IF func[0] THEN PRINT "Toolkit() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@Toolkit, @"Toolkit", &Toolkit(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 132
	designHeight = 100
'
	gridType = Toolkit
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       64)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  ToolkitCode ()  #####
' ############################
'
FUNCTION  ToolkitCode (grid, message, v0, v1, v2, v3, r0, (r1, r1$))
	SHARED  appearanceGrid
	SHARED  behaviorGrid
	SHARED  toolkitGrid
	SHARED  messageGrid
	SHARED  designGrid
	SHARED  designWindow
	SHARED	lastSelectGrid,  selectGrid,  workGrid,  gripGrid,  graphGrid
	SHARED	selectX,  selectY,  selectW,  selectH
	SHARED	modalFont
	SHARED	imbedded
	SHARED	testMode
	SHARED	report
	SHARED	fileGrid
	SHARED	backgroundColor,  drawingColor
	SHARED	lowlightColor,  highlightColor,  accentColor
	SHARED	tool[],  tool$[]
	SHARED	border$[],  align$[],  justify$[],  texture$[]
	SHARED	gridTypeMessageFunc[],  messageSub[]
	SHARED  backslash_literal[]
	SHARED	kids[]
	SHARED	window[]
	SHARED	window$[]
	SHARED	textArray$[]
	SHARED	textString$[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	upperGridType
	SHARED	WINDOW  windowInfo[]
	SHARED	GRID	gridType[]
	SHARED	GRID	grid[]
	SHARED	gridName$[]
	SHARED	gridType$[]
	SHARED	gridFunc$[]
	SHARED	gridTypeName$[]
	SHARED	gridTypeFunc$[]
	STATIC	GRID	current
	STATIC	GRID	base
	STATIC	currentGrid							' xxx
	STATIC	baseGrid
	STATIC	gindex[]
	STATIC	windex[]
	STATIC	window$
	STATIC	window
	STATIC	windex
	STATIC	graph
	STATIC	SUBADDR  sub[]
	FUNCADDR f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
	FUNCADDR toolFunc (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	$Toolkit						= 0
	$CheckBox						= 1
	$Menu								= 2
	$Label							= 3
	$Text								= 4
	$Another						= 5
'
	$MenuWindow					= 1
	$MenuGrid						= 2
'
	$NewWindow					= 0
	$HideWindow					= 1
	$LoadWindow					= 2
	$SaveWindow					= 3
	$DeleteWindow				= 4
	$WindowToFunction		= 5
	$WindowFromFunction	= 6
	$CloseToolkit				= 7
'
	$Appearance					= 0
	$Behavior						= 1
	$SortKids						= 2
	$Delete							= 3
	$Debug							= 4

	IFZ windex[] THEN GOSUB Initialize
	IF (grid < 0) THEN PRINT "ToolkitCode() : error : (grid < 0)" : RETURN
	IF (message < 0) THEN PRINT "ToolkitCode() : error : (message < 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "ToolkitCode() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "ToolkitCode() : error : (message > upperMesage)" : RETURN
'
	SELECT CASE message
		CASE #Callback				: GOSUB Callback
		CASE #HideWindow			: GOSUB HideToolkit
		CASE #WindowDestroyed	: GOSUB WindowDestroyed
		CASE ELSE							: XuiPassOn (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
	END SELECT
	RETURN
'
'
' *****  Callback  *****

SUB Callback
	message = r1
	callback = message
	SELECT CASE message
		CASE #Selection		: GOSUB Selection
		CASE #TextEvent		: GOSUB TextEvent
		CASE #Hidden			: GOSUB Hidden
	END SELECT
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	tool	= r0
	SELECT CASE tool
		CASE $CheckBox	: GOSUB CheckBox
		CASE $Menu			: GOSUB Menu
'		CASE $Label			:
		CASE $Text			: GOSUB TextLine
		CASE $Another		: GOSUB CreateTool
		CASE ELSE				: GOSUB CreateTool
	END SELECT
END SUB
'
'
' *****  CheckBox  *****
'
SUB CheckBox
	testMode = v0
	IF (testMode AND selectGrid) THEN DeselectGrid (selectGrid)
END SUB
'
'
' *****  Menu  *****
'
SUB Menu
	SELECT CASE v0
		CASE $MenuWindow:					: GOSUB MenuWindow
		CASE $MenuGrid:						: GOSUB MenuGrid
	END SELECT
END SUB
'
'
' *****  MenuWindow  *****
'
SUB MenuWindow
	SELECT CASE v1
		CASE $NewWindow						:	GOSUB NewWindow
		CASE $HideWindow					: GOSUB HideDesignWindow
		CASE $LoadWindow					: GOSUB LoadWindow
		CASE $SaveWindow					: GOSUB SaveWindow
		CASE $DeleteWindow				: GOSUB DeleteWindow
		CASE $WindowToFunction		: GOSUB WindowToFunction
		CASE $WindowFromFunction	: GOSUB WindowFromFunction
		CASE $CloseToolkit				: XxxGuiDesignerOnOff (0)
		CASE ELSE		: new = v1-7	: GOSUB SelectWindow
	END SELECT
END SUB
'
'
' *****  MenuGrid  *****
'
SUB MenuGrid
	SELECT CASE v1
		CASE $Appearance					: GOSUB Appearance
		CASE $Behavior						: GOSUB Behavior
		CASE $SortKids						: GOSUB SortKids
		CASE $Delete							: GOSUB Delete
		CASE $Debug								: GOSUB Debug
	END SELECT
END SUB
'
'
' *****  Debug  *****
'
SUB Debug
	report = NOT report
END SUB
'
'
' *****  SortKids  *****
'
SUB SortKids
	IF designGrid THEN
		OrderKids (designGrid)
		XuiSendMessage (designGrid, #Redraw, 0, 0, 0, 0, 0, 0)
	END IF
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
'	PRINT "ToolkitCode() : TextEvent", grid, "#TextEvent", v0, v1, v2, v3, r0, r1""
END SUB
'
'
' *****  DesignMode  *****
'
SUB DesignMode
	testMode = $$FALSE
	XuiSendMessage (toolkitGrid, #SetValues, 0, 0, 0, 0, $CheckBox, 0)
	XuiSendMessage (toolkitGrid, #RedrawGrid, 0, 0, 0, 0, $CheckBox, 0)
END SUB
'
'
' *****  NewWindow  *****
'
SUB NewWindow
	GOSUB CreateDesignWindow
	GOSUB SelectWindow
	GOSUB DesignMode
END SUB
'
'
' *****  CreateDesignWindow  *****
'
SUB CreateDesignWindow
	IF graph THEN GOSUB HideDesignWindow
	IFZ recreate THEN
		v0 = -1 : v1 = -1 : v2 = -1 : v3 = -1 : r0 = 0 : r1 = 0
	ELSE
		IF (v0 < #windowBorderWidth) THEN v0 = #windowBorderWidth
		IF (v1 < (#windowBorderWidth + #windowTitleHeight)) THEN v1 = #windowBorderWidth + #windowTitleHeight
		IF (v0 > #displayWidth) THEN v0 = #windowBorderWidth
		IF (v1 > #displayHeight) THEN v1 = #windowBorderWidth + #windowTitleHeight
		IF ((v0+v2+#windowBorderWidth) > #displayWidth) THEN v0 = #displayWidth - v2 - #windowBorderWidth
		IF ((v1+v3+#windowBorderWidth) > #displayHeight) THEN v1 = #displayHeight - v3 - #windowBorderWidth
		IF (v0 < #windowBorderWidth) THEN v0 = #windowBorderWidth
		IF (v1 < (#windowBorderWidth + #windowTitleHeight)) THEN v1 = #windowBorderWidth + #windowTitleHeight
	END IF
	Design (@grid, #CreateWindow, @v0, @v1, @v2, @v3, @r0, @r1)
	IFZ grid THEN PRINT "ToolkitCode() : CreateDesignWindow : error : (CreateWindow failed)" : EXIT SUB
	XuiSendMessage (grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" design ")
	XuiSendMessage (grid, #SetCursor, #cursorCrosshair, 0, 0, 0, 0, 0)
	new = 0
	windex = 0
	window = r0
	window$ = ""
'	window$ = "Design" + STRING$(window)
	window$[window] = window$
	upper = UBOUND(windex[])
	FOR i = 1 TO UBOUND(windex[])
		IFZ	windex[i] THEN new = i : EXIT FOR
	NEXT i
	IFZ new THEN
		new = upper + 1
		upper = upper + 16
		REDIM gindex[upper]
		REDIM windex[upper]
	END IF
	windex[new] = window
	gindex[new] = grid
	baseGrid = grid
	GOSUB UpdateMenu
END SUB
'
'
' *****  WindowDestroyed  *****
'
SUB WindowDestroyed
	win = grid
	IF (win = toolWindow) THEN
		XuiWindow (grid, message, v0, v1, v2, v3, r0, r1)
		toolkitGrid = 0
'		GOSUB CreateWindow
	ELSE
		upper = UBOUND (windex[])
		wind = 0
		FOR i = 1 TO upper
			IF (win = windex[i]) THEN wind = i : EXIT FOR
		NEXT i
		IFZ wind THEN EXIT SUB
		FOR i = wind TO upper - 1
			gindex[i] = gindex[i+1]
			windex[i] = windex[i+1]
		NEXT i
		IF (win = window) THEN
			IF appearanceGrid THEN XuiSendMessage (appearanceGrid, #HideWindow, workGrid, 0, 0, 0, 0, 0)
			IF toolkitGrid THEN
				XuiSendMessage (toolkitGrid, #SetTextString, 0, 0, 0, 0, $Text, "")
				XuiSendMessage (toolkitGrid, #Redraw, 0, 0, 0, 0, @text, 0)
			END IF
			graphGrid = 0
			designGrid = 0
			designWindow = 0
			window$[win] = ""
			window$ = ""
			window = 0
			windex = 0
			graph = 0
		END IF
		GOSUB UpdateMenu
	END IF
END SUB
'
'
' *****  UpdateMenu  *****
'
SUB UpdateMenu
	IFZ toolkitGrid THEN EXIT SUB
	XuiSendMessage (toolkitGrid, #GetTextArray, 0, 0, 0, 0, $Menu, @a$[])
	upper = UBOUND (a$[]) + 3
	IF (upper < 64) THEN upper = 63
	REDIM a$[upper]
	a = -1
	INC a : a$[a] = "_Window  "
	INC a : a$[a] = " _New"
	INC a : a$[a] = " _Hide"
	INC a : a$[a] = " _Load"
	INC a : a$[a] = " _Save"
	INC a : a$[a] = " _Delete"
	INC a : a$[a] = " _ToFunction"
	INC a : a$[a] = " _FromFunction"
	INC a : a$[a] = " _CloseToolkit"
	upper = UBOUND(windex[])
	final = 0
	FOR i = 1 TO upper
		IFZ windex[i] THEN EXIT FOR
		INC a
		final = i
		w = windex[i]
		w$ = window$[i]
		a$[a] = " _" + STRING$(i) + ": " + window$[w]
	NEXT i
	INC a : a$[a] = "_Grid"
	INC a : a$[a] = " _Appearance"
	INC a : a$[a] = " _Behavior"
	INC a : a$[a] = " _SortKids"
	INC a : a$[a] = " _Delete"
	REDIM a$[a]
	XuiSendMessage (toolkitGrid, #SetTextArray, 0, 0, 0, 0, $Menu, @a$[])
END SUB
'
'
' *****  HideToolkit  *****
'
SUB HideToolkit
	XuiSendMessage (grid, #HideWindow, 0, 0, 0, 0, 0, 0)
'	GOSUB HideDesignWindow
END SUB
'
'
' *****  Hidden  *****
'
SUB Hidden
	GOSUB HideDesignWindow
END SUB
'
'
' *****  HideDesignWindow  *****
'
SUB HideDesignWindow
	IF graph THEN
		IF selectGrid THEN DeselectGrid (selectGrid)
		XuiSendMessage (toolkitGrid, #GetTextString, 0, 0, 0, 0, $Text, @window$)
		XuiSendMessage (toolkitGrid, #SetTextString, 0, 0, 0, 0, $Text, "")
		window$ = TRIM$(window$)
		IF window$ THEN window$[window] = window$
		XuiSendMessage (graph, #HideWindow, 0, 0, 0, 0, 0, 0)
		designWindow = 0
		designGrid = 0
		window$ = ""
		window = 0
		graph = 0
	END IF
END SUB
'
'
' *****  DisplayWindow  *****
'
SUB DisplayWindow
	IF graph AND (new != windex) THEN GOSUB HideDesignWindow
	IF windex THEN
		graph = gindex[windex]
		window = windex[windex]
		window$ = window$[window]
		designWindow = window
		designGrid = graph
		graphGrid = graph
		window$ = TRIM$(window$)
		XuiSendMessage (toolkitGrid, #SetTextString, 0, 0, 0, 0, $Text, window$)
		XuiSendMessage (toolkitGrid, #Redraw, 0, 0, 0, 0, $Text, 0)
		XuiSendMessage (graph, #SetWindowTitle, 0, 0, 0, 0, 0, window$)
		XuiSendMessage (graph, #DisplayWindow, 0, 0, 0, 0, 0, 0)
	END IF
END SUB
'
'
' *****  SelectWindow  *****
'
SUB SelectWindow
	IF (new < 1) THEN PRINT "ToolkitCode() : SelectWindow : error : (menu entry too low)" : EXIT SUB
	IF graph THEN
		XuiSendMessage (toolkitGrid, #GetTextString, 0, 0, 0, 0, $Text, @ww$)
		window$[window] = ww$
		IF (new != windex) THEN
			GOSUB UpdateMenu
			GOSUB HideDesignWindow
		END IF
	END IF
	windex = new
	GOSUB DisplayWindow
END SUB
'
'
' *****  TextLine  *****
'
SUB TextLine
	XuiSendMessage (toolkitGrid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
	ValidSimpleSymbol (@text$)
	IF graph THEN XuiSendMessage (graph, #SetWindowTitle, 0, 0, 0, 0, 0, @text$)
	window$[window] = text$
	GOSUB UpdateMenu
END SUB
'
'
' *****  DeleteWindow  *****
'
SUB DeleteWindow
	IF graph THEN XuiSendMessage (graph, #DestroyWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Delete  *****  selectGrid and gripGrid
'
SUB Delete
	IF selectGrid THEN
		XuiSendMessage (selectGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (gripGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		selectGrid = 0
		gripGrid = 0
		XuiSendMessage (graph, #RedrawWindow, 0, 0, 0, 0, 0, 0)
	END IF
END SUB
'
'
' *****  SaveWindow  *****
'
SUB SaveWindow
	busted = $$FALSE
	GOSUB WindowToArray
	IF busted THEN EXIT SUB
'
	IF winFunc$ THEN
		IF w$[] THEN
			name$ = ""
			IF winFunc$ THEN name$ = winFunc$ + ".win"
			XuiDialog ("ToolkitCode()\nSaveWindow\n\nWindow Name\n\"" + winFunc$ + "\"\n\n Enter Filename To SaveAs", @name$, @reply, @reply$)
			IF ((reply = 4) OR (reply = -1)) THEN EXIT SUB
			IFZ reply$ THEN XuiMessage ("ToolkitCode()\nSaveWindow\n\nError:  Empty Filename String") : EXIT SUB
			reply$ = TRIM$ (reply$)
			dot = INSTR (reply$, ".")
			IFZ dot THEN reply$ = reply$ + ".win"
			ofile = OPEN (reply$, $$WRNEW)
			IF (ofile <= 0) THEN
				XuiMessage ("ToolkitCode()\nSaveWindow\n\nError:  Cannot open <" + reply$ + ">")
				EXIT SUB
			END IF
			FOR k = 0 TO i
				PRINT [ofile], w$[k]
			NEXT k
			CLOSE (ofile)
		END IF
	END IF
END SUB
'
'
' *****  WindowToFunction  *****
'
SUB WindowToFunction
	IF ##USERRUNNING THEN XuiMessage (@"ToolkitCode()\nWindowToFunction\n\nError:  Program running") : EXIT SUB
	IFZ GuiProgram() THEN XuiMessage (@"ToolkitCode()\nWindowToFunction\n\nError:  Need GUI program\n\nA: FileNewGuiProgram\nB: FileLoad (a GUI program)") : EXIT SUB
	busted = $$FALSE
	GOSUB WindowToArray
	IF busted THEN EXIT SUB
	XitQueryFunction (winFunc$, @gridFuncExists)
	XuiSendMessage (messageGrid, #SetKeyboardFocusGrid, 0, 0, 0, 0, 2, 0)
	IF gridFuncExists THEN XuiGetReply (messageGrid, @"WindowToFunction", winFunc$ + " ( )\nAlready Exists", @"Update\nReplace\nCancel", 0, 0, @reply, @reply$)
	SELECT CASE reply
		CASE 2	: GOSUB UpdateFunction
		CASE 4	: EXIT SUB
	END SELECT
	XitGetDECLARE (winFunc$, @gridDeclare$)
	IFZ gridDeclare$ THEN
		winLength = LEN (winFunc$)
		IF (winLength < 13) THEN space$ = SPACE$ (13 - winLength) ELSE space$ = ""
		XitSetDECLARE (winFunc$, "INTERNAL FUNCTION  " + winFunc$ + space$ + " (grid, message, v0, v1, v2, v3, r0, ANY)")
	END IF
	XitSetFunction (winFunc$, @w$[])
'
	DIM f$[]
	reply = 3
	codeFunc$ = winFunc$ + "Code"
	XitQueryFunction (@codeFunc$, @codeFuncExists)
	XuiSendMessage (messageGrid, #SetKeyboardFocusGrid, 0, 0, 0, 0, 2, 0)
	IF codeFuncExists THEN XuiGetReply (messageGrid, "WindowToFunction", codeFunc$ + " ( )\nAlready Exists", @"Update\nReplace\nCancel", 0, 0, @reply, @reply$)
	SELECT CASE reply
		CASE 2	: XitGetFunction (@codeFunc$, @f$[])
		CASE 3	: name$ = "$XBDIR" + $$PathSlash$ + "templates" + $$PathSlash$ + "code.xxx"
							XstLoadString (@name$, @text$)
							IF text$ THEN
								RenameFunction (@text$, @"Code", @codeFunc$)
								XstStringToStringArray (@text$, @f$[])
							ELSE
								XuiMessage ("ToolkitCode()\nWindowToFunction\n\nError: Can't load disk file " + name$)
								DIM f$[]
							END IF
		CASE 4	: EXIT SUB
	END SELECT
'
	IF f$[] THEN
		UpdateKidConstants (@f$[], @k$[])
		IFZ codeFuncExists THEN
			XitGetDECLARE (codeFunc$, @codeDeclare$)
			IFZ codeDeclare$ THEN
				codeLength = LEN (codeFunc$)
				IF (codeLength < 13) THEN space$ = SPACE$ (13 - codeLength) ELSE space$ = ""
				XitSetDECLARE (@codeFunc$, "INTERNAL FUNCTION  " + codeFunc$ + space$ + " (grid, message, v0, v1, v2, v3, kid, ANY)")
			END IF
			UpdateCodeFunction (@f$[], @s$[])
		ELSE
			IF (reply = 3) THEN UpdateCodeFunction (@f$[], @s$[])
		END IF
		XitSetFunction (@codeFunc$, @f$[])
		XitSetDisplayedFunction (codeFunc$)
	END IF
'
	UpdateCreateWindows (@winFunc$, @codeFunc$)
END SUB
'
'
' *****  UpdateFunction  *****
'
SUB UpdateFunction
	comment = 0
	sharedOld = 0
	firstConstantOld = 0
	finalConstantOld = 0
	firstCreateOld = 0
	finalCreateOld = 0
	firstDesignOld = 0
	finalDesignOld = 0
'
	XitGetFunction (@winFunc$, @o$[])
	FOR i = 0 TO UBOUND(o$[])
		o$ = TRIM$(o$[i])
		IFZ o$ THEN DO NEXT
		SELECT CASE TRUE
			CASE (INSTR(o$,"SHARED") = 1)						: sharedOld = i
			CASE (o${0} = ''')											: IF ((sharedOld != 0) AND (comment = 0)) THEN comment = i
                                                IF (firstCreateOld AND (finalCreateOld = 0)) THEN finalCreateOld = i-1
			CASE (o${0} = '$')											:	IFZ firstConstantOld THEN firstConstantOld = i : finalConstantOld = i : EXIT SELECT
																								IF (finalConstantOld = (i-1)) THEN finalConstantOld = i
			CASE (o$ = "SUB Create")								: firstCreateOld = i+1
			CASE (o$ = "END SUB")										: IF (firstCreateOld AND (finalCreateOld = 0)) THEN finalCreateOld = i-1
			CASE (INSTR(o$,"GOSUB"))								: IF (firstCreateOld AND (finalCreateOld = 0)) THEN finalCreateOld = i-1 : DEC finalCreate
			CASE (INSTR(o$,"designX = ") = 1)				: firstDesignOld = i
			CASE (INSTR(o$,"designHeight = ") = 1)	: finalDesignOld = i
		END SELECT
	NEXT i
'
	IFZ firstConstantOld THEN
		firstConstantOld = comment + 1
		finalConstantOld = comment
	END IF
'
	IF firstCreateOld THEN
		IF finalCreateOld THEN
			IF firstDesignOld THEN
				IF finalDesignOld THEN
					constantCount			= finalConstant			- firstConstant			+ 1
					constantCountOld	= finalConstantOld	- firstConstantOld	+ 1
					createCount				= finalCreate				- firstCreate				+ 1
					createCountOld		= finalCreateOld		- firstCreateOld		+ 1
					designCount				= finalDesign				- firstDesign				+ 1
					designCountOld		= finalDesignOld		- firstDesignOld		+ 1
					XstReplaceLines (@o$[], @w$[], firstConstantOld, constantCountOld, firstConstant, constantCount)
					firstCreateOld		= firstCreateOld + constantCount - constantCountOld
					firstDesignOld		= firstDesignOld + constantCount - constantCountOld
					XstReplaceLines (@o$[], @w$[], firstCreateOld, createCountOld, firstCreate, createCount)
					firstDesignOld		= firstDesignOld + createCount - createCountOld
					XstReplaceLines (@o$[], @w$[], firstDesignOld, designCountOld, firstDesign, designCount)
					SWAP w$[], o$[]
				END IF
			END IF
		END IF
	END IF
END SUB
'
'
' *****  WindowToArray  *****
'
SUB WindowToArray
	IFZ graph THEN
		XuiMessage (@"ToolkitCode()\nWindowToArray\n\nError:  Design window not displayed")
		busted = $$TRUE
		EXIT SUB
	END IF
	XuiSendMessage (toolkitGrid, #GetTextString, 0, 0, 0, 0, $Text, @window$)
	ValidSimpleSymbol (@window$)
	winFunc$ = ""
	IFZ window$ THEN
		XuiMessage (@"ToolkitCode()\nWindowToArray\n\nError:  Design Window Name Required\nEnter Design Name in toolkit TextLine")
		busted = $$TRUE
		EXIT SUB
	END IF
	window$[designWindow] = window$
	XuiSendMessage (graph, #SetGridName, 0, 0, 0, 0, 0, @window$)
	XuiSendMessage (toolkitGrid, #SetTextString, 0, 0, 0, 0, $Text, @window$)
	XuiSendMessage (toolkitGrid, #Redraw, 0, 0, 0, 0, $Text, 0)
	const = 0
	upper = 1023
	DIM w$[upper]
	DIM t$[upper]
	DIM c$[upper]
	DIM cc$[upper]
	IF selectGrid THEN DeselectGrid (selectGrid)
	IF (graph <= 0) THEN PRINT "ToolkitCode() : WindowToFunction : error : (graph <= 0)" : RETURN
	lastGrid				= UBOUND(kids[graph, ])
	IF (lastGrid < 0) THEN PRINT "ToolkitCode() : WindowToFunction : error : (kids[graph,] is empty)" : RETURN
	IFZ window$ THEN window$ = window$[designWindow]
	IFZ window$ THEN window$ = "Design" + STRING(designWindow)
	window$					= UCASE$(LEFT$(window$,1)) + MID$(window$, 2)
	winFunc$				= UCASE$(LEFT$(window$,1)) + MID$(window$, 2)
	xDisplay$				= STRING$(windowInfo[designWindow].xDisplay)
	yDisplay$				= STRING$(windowInfo[designWindow].yDisplay)
	designWidth$		= STRING$(windowInfo[designWindow].width)
	designHeight$		= STRING$(windowInfo[designWindow].height)
	banner$					= "'	" + CHR$ ('#', LEN(winFunc$) + 17)
	cc$[const]			= "$" + winFunc$
	c$[const]				= "$" + winFunc$
	t$[const]				= winFunc$
	INC const
	winType$				= winFunc$
	i = 0 : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  =  banner$
	INC i : w$[i]  = "'	#####  " + winFunc$ + " ()  #####"
	INC i : w$[i]  =  banner$
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'	\"Anatomy of Grid Functions\" in the GuiDesigner Programmer Guide"
	INC i : w$[i]  = "'	describes the operation and modification of grid functions in detail."
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'	WindowFromFunction and/or WindowToFunction may not work, or may not generate the desired results if you:"
	INC i : w$[i]  = "'		* Modify the kid constant definition improperly."
	INC i : w$[i]  = "'		* Modify the code in the Create subroutine improperly."
	INC i : w$[i]  = "'		* Imbed blank or comment lines in the Create subroutine."
	INC i : w$[i]  = "'		* Remove the GOSUB Resize line in the Create subroutine (comment out is okay)."
	INC i : w$[i]  = "'		* Imbed special purpose code in the Create subroutine before the GOSUB Resize line."
	INC i : w$[i]  = "'		* Delete any of the four lines that assign values to designX, designY, designWidth, designHeight."
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "FUNCTION  " + winFunc$ + " (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))"
	INC i : w$[i]  = "	STATIC  designX,  designY,  designWidth,  designHeight"
	INC i : w$[i]  = "	STATIC  SUBADDR  sub[]"
	INC i : w$[i]  = "	STATIC  upperMessage"
	INC i : w$[i]  = "	STATIC  " + winType$
	INC i : w$[i]  = "'"
	firstConstant  = i + 1
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	IFZ sub[] THEN GOSUB Initialize"
	INC i : w$[i]  = "'	XuiReportMessage (grid, message, v0, v1, v2, v3, r0, r1)"
	INC i : w$[i]  = "	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, " + winType$ + ") THEN RETURN"
	INC i : w$[i]  = "	IF (message <= upperMessage) THEN GOSUB @sub[message]"
	INC i : w$[i]  = "	RETURN"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Callback  *****  message = Callback : r1 = original message"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Callback"
	INC i : w$[i]  = "	message = r1"
	INC i : w$[i]  = "	callback = message"
	INC i : w$[i]  = "	IF (message <= upperMessage) THEN GOSUB @sub[message]"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Create" : firstCreate = i+1
	INC i : w$[i]  = "	IF (v0 <= 0) THEN v0 = 0"
	INC i : w$[i]  = "	IF (v1 <= 0) THEN v1 = 0"
	INC i : w$[i]  = "	IF (v2 <= 0) THEN v2 = designWidth"
	INC i : w$[i]  = "	IF (v3 <= 0) THEN v3 = designHeight"
	INC i : w$[i]  = "	XuiCreateGrid  (@grid, " + winType$ + ", @v0, @v1, @v2, @v3, r0, r1, &" + winFunc$ + "())"
'	INC i : w$[i]  = "	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @\"" + winType$ + "\")"
'
' Update base grid if necessary
'
	k$ = "0"
	g$ = "grid"
	grid = graph
	grid$ = "grid"
	currentGrid = grid
	gridFunc$ = "XuiSendMessage"
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	width = x2 - x1 + 1
	height = y2 - y1 + 1
	XuiBase (@proto, #Create, x1, y1, width, height, designWindow, 0)
	GOSUB UpdateGridName
	GOSUB UpdateStyle
	GOSUB UpdateColor
	GOSUB UpdateAlign
	GOSUB UpdateBorder
	GOSUB UpdateIndent
	GOSUB UpdateTexture
	GOSUB UpdateHelpString
	GOSUB UpdateHintString
	GOSUB UpdateFontString
	GOSUB UpdateImageString
	GOSUB UpdateTextString
	GOSUB UpdateTextArray
	XuiSendMessage (proto, #Destroy, 0, 0, 0, 0, 0, 0)
'
' Create the grids in the window
'
	can = 0
	focusKid = 0
	inArray = 0
	inString = 0
	activeGrid	= 0
	FOR g = 1 TO lastGrid													' for all kids of graph grid
		IF (i > (upper-64)) THEN
			upper = upper + 256
			REDIM w$[upper]														' avoid out of bounds error
		END IF
		grid				= kids[graph, g]								' next grid
		IFZ grid THEN DO NEXT												' if deleted try next one
		INC activeGrid
		g$					= "g"														'
		currentGrid	= grid													'	xxx
		current			= grid[grid]										'
		gridType		= current.gridType
		gridFunc		= current.gridFunc
		grid$				= gridName$[grid]								' TRIM$(current.gridName)
		gridFunc$		= gridFunc$[grid]								' TRIM$(current.gridFuncName)
		gridType$		= gridType$[grid]								' TRIM$(current.gridTypeName)
		gridName$		= gridType$ + STRING$(grid)			' TRIM$(current.gridTypeName) + STRING$(grid)
		XgrGetGridPositionAndSize (grid, @xWin, @yWin, @width, @height)
		xWin$				= STRING$(xWin)
		yWin$				= STRING$(yWin)
		width$			= STRING$(width)
		height$			= STRING$(height)
		activeGrid$ = STRING$(activeGrid)
		constant$		= "$" + grid$
		cc$[const]	= constant$
		c$[const]		= constant$
		t$[const]		= gridType$
		INC const
		IF (current.can AND $$InputTextString) THEN
			IFZ inString THEN inString = activeGrid
			can = can OR $$InputTextString
		END IF
		IF (current.can AND $$InputTextArray) THEN
			IFZ inArray THEN inArray = activeGrid
			can = can OR $$InputTextArray
		END IF
		IF (current.can AND $$Callback) THEN can = can OR $$Callback
		IF (current.can AND $$Respond) THEN can = can OR $$Respond
		IF (current.can AND $$Focus) THEN
			IFZ (can AND $$Focus) THEN
				can = can OR $$Focus
				focusKid = activeGrid
			END IF
		END IF
		toolFunc = gridFunc
		@toolFunc (@proto, #Create, xWin, yWin, width, height, designWindow, 0)
		IF (LEN(gridFunc$) < 14) THEN extra$ = SPACE$(14 - LEN(gridFunc$)) ELSE extra$ = ""
		INC i : w$[i]  = "	" + gridFunc$ + extra$ + " (@g" + ", #Create, " + xWin$ + ", " + yWin$ + ", " + width$ + ", " + height$ + ", r0, grid)"
		IF (current.can AND $$Callback) THEN
			INC i : w$[i]  = "	XuiSendMessage ( g, #SetCallback, grid, &" + winFunc$ + "(), -1, -1, " + constant$ + ", grid)"
		END IF
		XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
		IFZ k[] THEN DIM k[0] : k[0] = grid
'
' Check attributes of kids against default values... emit code for differences
'
		FOR k = 0 TO UBOUND(k[])
			kid = k[k]
			k$ = STRING$(k)
			IFZ kid THEN DO NEXT
			currentGrid = kid
'			XuiSendMessage (grid, #GetInfo, 0, 0, 0, 0, k, @current)
'			XuiSendMessage (proto, #GetInfo, 0, 0, 0, 0, k, @base)
			GOSUB UpdateGridName
			GOSUB UpdateStyle
			GOSUB UpdateColor
			GOSUB UpdateAlign
			GOSUB UpdateBorder
			GOSUB UpdateIndent
			GOSUB UpdateTexture
			GOSUB UpdateHelpString
			GOSUB UpdateHintString
			GOSUB UpdateFontString
			GOSUB UpdateImageString
			GOSUB UpdateTextString
			GOSUB UpdateTextArray
		NEXT k
'		INC i : w$[i]  = "	XuiSendMessage ( g, #SetGridProperties, -1, 0, 0, 0, 0, 0)"
		XuiSendMessage (proto, #Destroy, 0, 0, 0, 0, 0, 0)
	NEXT g
	XuiCanNumberToString (can, @can$)
	IFZ can$ THEN can$ = HEXX$ (can,2)
	INC i : w$[i]  = "	GOSUB Resize"
	INC i : w$[i]  = "END SUB" : finalCreate = i-1
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB CreateWindow"
	INC i : w$[i]  = "	IF (v0 == 0) THEN v0 = designX"
	INC i : w$[i]  = "	IF (v1 == 0) THEN v1 = designY"
	INC i : w$[i]  = "	IF (v2 <= 0) THEN v2 = designWidth"
	INC i : w$[i]  = "	IF (v3 <= 0) THEN v3 = designHeight"
	INC i : w$[i]  = "	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)"
	INC i : w$[i]  = "	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$"
	INC i : w$[i]  = "	GOSUB Create"
	INC i : w$[i]  = "	r1 = 0 : ATTACH display$ TO r1$"
	INC i : w$[i]  = "	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @\"" + winFunc$ + "\")"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  GetSmallestSize  *****  see \"Anatomy of Grid Functions\""
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB GetSmallestSize"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Redrawn  *****  see \"Anatomy of Grid Functions\""
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Redrawn"
	INC i : w$[i]  = "	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, r0, r1)"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Resize  *****  see \"Anatomy of Grid Functions\""
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Resize"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Selection  *****  see \"Anatomy of Grid Functions\""
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Selection"		: firstSelection = i+1
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' *****  Initialize  *****  see \"Anatomy of Grid Functions\""
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "SUB Initialize"
	INC i : w$[i]  = "	XuiGetDefaultMessageFuncArray (@func[])"
	INC i : w$[i]  = "	XgrMessageNameToNumber (@\"LastMessage\", @upperMessage)"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	func[#Callback]           = &XuiCallback ()               ' disable to handle Callback messages internally"
	INC i : w$[i]  = "' func[#GetSmallestSize]    = 0                             ' enable to add internal GetSmallestSize routine"
	INC i : w$[i]  = "' func[#Resize]             = 0                             ' enable to add internal Resize routine"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	DIM sub[upperMessage]"
	INC i : w$[i]  = "'	sub[#Callback]            = SUBADDRESS (Callback)         ' enable to handle Callback messages internally"
	INC i : w$[i]  = "	sub[#Create]              = SUBADDRESS (Create)           ' must be subroutine in this function"
	INC i : w$[i]  = "	sub[#CreateWindow]        = SUBADDRESS (CreateWindow)     ' must be subroutine in this function"
	INC i : w$[i]  = "'	sub[#GetSmallestSize]     = SUBADDRESS (GetSmallestSize)  ' enable to add internal GetSmallestSize routine"
	INC i : w$[i]  = "	sub[#Redrawn]             = SUBADDRESS (Redrawn)          ' generate #Redrawn callback if appropriate"
	INC i : w$[i]  = "'	sub[#Resize]              = SUBADDRESS (Resize)           ' enable to add internal Resize routine"
	INC i : w$[i]  = "	sub[#Selection]           = SUBADDRESS (Selection)        ' routes Selection callbacks to subroutine"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	IF sub[0] THEN PRINT \"" + winFunc$ + "() : Initialize : error ::: (undefined message)\""
	INC i : w$[i]  = "	IF func[0] THEN PRINT \"" + winFunc$ + "() : Initialize : error ::: (undefined message)\""
	INC i : w$[i]  = "	XuiRegisterGridType (@" + winFunc$ + ", \"" + winFunc$ + "\", &" + winFunc$ + "(), @func[], @sub[])"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "' Don't remove the following 4 lines, or WindowFromFunction/WindowToFunction will not work"
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	designX = " + xDisplay$						: firstDesign = i
	INC i : w$[i]  = "	designY = " + yDisplay$
	INC i : w$[i]  = "	designWidth = " + designWidth$
	INC i : w$[i]  = "	designHeight = " + designHeight$		: finalDesign = i
	INC i : w$[i]  = "'"
	INC i : w$[i]  = "	gridType = " + winFunc$
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"x\",                designX)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"y\",                designY)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"width\",            designWidth)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"height\",           designHeight)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"maxWidth\",         designWidth)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"maxHeight\",        designHeight)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"minWidth\",         designWidth)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"minHeight\",        designHeight)"
	INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"can\",              " + can$ + ")"
	IF (can AND $$Focus) THEN
		INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"focusKid\",         " + c$[focusKid] + ")"
	END IF
	IF (can AND $$InputTextArray) THEN
		INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"inputTextArray\",   " + c$[inArray] + ")"
	END IF
	IF (can AND $$InputTextString) THEN
		INC i : w$[i]  = "	XuiSetGridTypeProperty (gridType, @\"inputTextString\",  " + c$[inString] + ")"
	END IF
	INC i : w$[i]  = "	IFZ message THEN RETURN"
	INC i : w$[i]  = "END SUB"
	INC i : w$[i]  = "END FUNCTION"
	c$[const] = "$UpperKid"
	INC const
	DIM k$[const]
	REDIM c$[const]
	REDIM t$[const]
	REDIM cc$[const-2]
	FOR cc = 0 TO const-1
		length = LEN (c$[cc])
		IF (length > longest) THEN longest = length
	NEXT cc
	longest = longest + 2
	FOR cc = 0 TO const-2
		length = LEN (c$[cc])
		num$ = RJUST$ (STRING$(cc),3)
		k$[cc] = "	" + c$[cc] + SPACE$(longest-length) + "= " + num$ + "  ' kid " + num$ + " grid type = " + t$[cc]
	NEXT cc
	k$[cc] = "	$UpperKid" + SPACE$(longest-9) + "= " + num$ + "  ' kid maximum"
	INC cc
	DIM t$[]
	k$[cc] = "'"
	XstReplaceLines (@w$[], @k$[], firstConstant, 0, 0, const+1)
	finalConstant		= firstConstant + const - 1
	firstCreate			= firstCreate + const + 1
	finalCreate			= finalCreate + const + 1
	firstSelection	= firstSelection + const + 1
	firstDesign			= firstDesign + const + 1
	finalDesign			= finalDesign + const + 1
	i = i + const + 1
'
	DIM s$[const]
	s$[0] = "	SELECT CASE r0"
	s$[const] = "	END SELECT"
	FOR cc = 0 TO const-2
		length = LEN (c$[cc])
		s$[cc+1] = "		CASE " + c$[cc] + SPACE$ (longest-length) + ":"
	NEXT cc
'
' enable the following commented out lines to imbed a SELECT CASE block
' in the Selection subroutine of the grid function.
'
'	XstReplaceLines (@w$[], @s$[], firstSelection, 0, 0, const+1)
'	finalSelection	= firstSelection + const + 1
'	firstDesign			= firstDesign + const + 1
'	finalDesign			= finalDesign + const + 1
'	i = i + const + 1
	REDIM w$[i]
END SUB
'
'
' *****  UpdateGridName  *****
'
SUB UpdateGridName
	kid$ = gridName$[currentGrid]
	IFZ kid$ THEN kid$ = gridType$[currentGrid] + STRING(kid)
'	IF (kid$ != kidName$) THEN INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetGridName, 0, 0, 0, 0, " + k$ + ", @\"" + kid$ + "\")"
	INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetGridName, 0, 0, 0, 0, " + k$ + ", @\"" + kid$ + "\")"
END SUB
'
'
' *****  UpdateStyle  *****
'
SUB UpdateStyle
	XuiSendMessage (grid, #GetStyle, @style, @styleMax, 0, 0, k, 0)
	XuiSendMessage (proto, #GetStyle, @styleProto, @styleMaxProto, 0, 0, k, 0)
	change = $$FALSE
	SELECT CASE TRUE
		CASE (style != styleProto)				: change = $$TRUE
		CASE (styleMax != styleMaxProto)	: change = $$TRUE
	END SELECT
	IF change THEN INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetStyle, " + STRING$(style) + ", " + STRING$(styleMax) + ", 0, 0, " + k$ + ", 0)"
END SUB
'
'
' *****  UpdateColor  *****
'
SUB UpdateColor
	XuiSendMessage (grid, #GetColor, @back, @draw, @low, @high, k, 0)
	XuiSendMessage (grid, #GetColorExtra, @dull, @acc, @lowtext, @hightext, k, 0)
	XuiSendMessage (proto, #GetColor, @backProto, @drawProto, @lowProto, @highProto, k, 0)
	XuiSendMessage (proto, #GetColorExtra, @dullProto, @accProto, @lowtextProto, @hightextProto, k, 0)
'
	change = $$FALSE
	SELECT CASE TRUE
		CASE (back != backProto)		: change = $$TRUE
		CASE (draw != drawProto)		: change = $$TRUE
		CASE (low != lowProto)			: change = $$TRUE
		CASE (high != highProto)		: change = $$TRUE
	END SELECT
	IF change THEN
		back$ = "" : draw$ = "" : low$ = "" : high$ = ""
		XgrColorNumberToName (back, @back$)
		XgrColorNumberToName (draw, @draw$)
		XgrColorNumberToName (low, @low$)
		XgrColorNumberToName (high, @high$)
		IFZ back$ THEN back$ = STRING$ (back)
		IFZ draw$ THEN draw$ = STRING$ (draw)
		IFZ low$ THEN low$ = STRING$ (low)
		IFZ high$ THEN high$ = STRING$ (high)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetColor, " + back$ + ", " + draw$ + ", " + low$ + ", " + high$ + ", " + k$ + ", 0)"
	END IF
'
	change = $$FALSE
	SELECT CASE TRUE
		CASE (dull != dullProto)					: change = $$TRUE
		CASE (acc != accProto)						: change = $$TRUE
		CASE (lowtext != lowtextProto)		: change = $$TRUE
		CASE (hightext != hightextProto)	: change = $$TRUE
	END SELECT
	IF change THEN
		dull$ = "" : acc$ = "" : lowtext$ = "" : hightext$ = ""
		XgrColorNumberToName (dull, @dull$)
		XgrColorNumberToName (acc, @acc$)
		XgrColorNumberToName (lowtext, @lowtext$)
		XgrColorNumberToName (hightext, @hightext$)
		IFZ dull$ THEN dull$ = STRING$ (dull)
		IFZ acc$ THEN acc$ = STRING$ (acc)
		IFZ lowtext$ THEN lowtext$ = STRING$ (lowtext)
		IFZ hightext$ THEN hightext$ = STRING$ (hightext)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetColorExtra, " + dull$ + ", " + acc$ + ", " + lowtext$ + ", " + hightext$ + ", " + k$ + ", 0)"
	END IF
END SUB
'
'
' *****  UpdateBorder  *****
'
SUB UpdateBorder
	XuiSendMessage (grid, #GetBorder, @style, @styleUp, @styleDown, 0, k, 0)
	XuiSendMessage (proto, #GetBorder, @styleProto, @styleUpProto, @styleDownProto, 0, k, 0)
	change = $$FALSE
	SELECT CASE TRUE
		CASE (style			!= styleProto)			: change = $$TRUE
		CASE (styleUp		!= styleUpProto)		: change = $$TRUE
		CASE (styleDown	!= styleDownProto)	: change = $$TRUE
	END SELECT
	IF change THEN
		XgrBorderNumberToName (style, @style$)
		XgrBorderNumberToName (styleUp, @styleUp$)
		XgrBorderNumberToName (styleDown, @styleDown$)
		IFZ style$ THEN style$ = STRING$ (style)
		IFZ styleUp$ THEN styleUp$ = STRING$ (styleUp)
		IFZ styleDown$ THEN styleDown$ = STRING$ (styleDown)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetBorder, " + style$ + ", " + styleUp$ + ", " + styleDown$ + ", 0, " + k$ + ", 0)"
	END IF
END SUB
'
'
' *****  UpdateFontString  *****
'
SUB UpdateFontString
	XuiSendMessage (grid, #GetFont, @fontSize, @fontWeight, @fontItalic, @fontAngle, k, @font$)
	XuiSendMessage (proto, #GetFont, @protoSize, @protoWeight, @protoItalic, @protoAngle, k, @protoFont$)
	IFZ font$ THEN
		IFZ protoFont$ THEN EXIT SUB
	END IF
	change = $$FALSE
	SELECT CASE TRUE
		CASE (font$ != protoFont$)				: change = $$TRUE
		CASE (fontSize != protoSize)			: change = $$TRUE
		CASE (fontWeight != protoWeight)	: change = $$TRUE
		CASE (fontAngle != protoAngle)		: change = $$TRUE
	END SELECT
	IF change THEN INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetFont, " + STRING$(fontSize) + ", " + STRING$(fontWeight) + ", " + STRING$(fontItalic) + ", " + STRING$(fontAngle) + ", " + k$ + ", @\"" + font$ + "\")"
END SUB
'
'
' *****  UpdateHelpString  *****
'
SUB UpdateHelpString
	XuiSendMessage (grid, #GetHelpString, 0, 0, 0, 0, k, @help$)
	IF help$ THEN INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetHelpString, 0, 0, 0, 0, " + k$ + ", @\"" + help$ + "\")"
END SUB
'
'
' *****  UpdateHintString  *****
'
SUB UpdateHintString
	XuiSendMessage (grid, #GetHintString, 0, 0, 0, 0, k, @hint$)
	IF hint$ THEN INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetHintString, 0, 0, 0, 0, " + k$ + ", @\"" + hint$ + "\")"
END SUB
'
'
' *****  UpdateImageString  *****
'
SUB UpdateImageString
	XuiSendMessage (grid, #GetImage, 0, 0, @imageIndentX, @imageIndentY, k, @image$)
	IF image$ THEN
		i$ = XstBinStringToBackStringThese$ (@image$, @backslash_literal[])
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetImage, 0, 0, " + STRING$(imageIndentX) + ", " + STRING$(imageIndentY) + ", " + k$ + ", @\"" + i$ + "\")"
		XuiSendMessage (grid, #GetImageCoords, @imageStartX, @imageStartY, @imageWidth, @imageHeight, k, 0)
		IF (imageStartX OR imageStartY OR imageWidth OR imageHeight) THEN
			INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetImageCoords, " + STRING$(imageStartX) + ", " + STRING$(imageStartY) + ", " + STRING$(imageWidth) + ", " + STRING$(imageHeight) + ", " + k$ + ", 0)"
		END IF
	END IF
END SUB
'
'
' *****  UpdateAlign  *****
'
SUB UpdateAlign
	XuiSendMessage (grid, #GetAlign, @align, @justify, 0, 0, k, 0)
	XuiSendMessage (proto, #GetAlign, @alignProto, @justifyProto, 0, 0, k, 0)
	change = $$FALSE
	SELECT CASE TRUE
		CASE (align		!= alignProto)		: change	= $$TRUE
		CASE (justify != justifyProto)	: change	= $$TRUE
	END SELECT
	IF change THEN
		XuiAlignNumberToName (align, @align$)
		XuiJustifyNumberToName (justify, @justify$)
		IFZ align$ THEN align$ = STRING$ (align)
		IFZ justify$ THEN justify$ = STRING$ (justify)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetAlign, " + align$ + ", " + justify$ + ", -1, -1, " + k$ + ", 0)"
	END IF
END SUB
'
'
' *****  UpdateIndent  *****
'
SUB UpdateIndent
	XuiSendMessage (grid, #GetIndent, @left, @top, @right, @bottom, k, 0)
	XuiSendMessage (proto, #GetIndent, @leftProto, @topProto, @rightProto, @bottomProto, k, 0)
	change = $$FALSE
	SELECT CASE TRUE
		CASE (left		!= leftProto)			: change = $$TRUE
		CASE (top			!= topProto)			: change = $$TRUE
		CASE (right		!= rightProto)		: change = $$TRUE
		CASE (bottom	!= bottomProto)		: change = $$TRUE
	END SELECT
	IF change THEN
		left$ = STRING$ (left)
		top$ = STRING$ (top)
		right$ = STRING$ (right)
		bottom$ = STRING$ (bottom)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetIndent, " + left$ + ", " + top$ + ", " + right$ + ", " + bottom$ + ", " + k$ + ", 0)"
	END IF
END SUB
'
'
' *****  UpdateTexture  *****
'
SUB UpdateTexture
	XuiSendMessage (grid, #GetTexture, @texture, 0, 0, 0, k, 0)
	XuiSendMessage (proto, #GetTexture, @textureProto, 0, 0, 0, k, 0)
	change = $$FALSE
	SELECT CASE TRUE
		CASE (texture != textureProto)	: change = $$TRUE
	END SELECT
	IF change THEN
		XuiTextureNumberToName (texture, @texture$)
		IFZ texture$ THEN texture$ = STRING$ (texture)
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetTexture, " + texture$ + ", 0, 0, 0, " + k$ + ", 0)"
	END IF
END SUB
'
'
' *****  UpdateTextString  *****
'
SUB UpdateTextString
	XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, k, @text$)
	XuiSendMessage (proto, #GetTextString, 0, 0, 0, 0, k, @proto$)
	IF (text$ != proto$) THEN
		text$ = XstBinStringToBackStringThese$ (@text$, @backslash_literal[])
		INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetTextString, 0, 0, 0, 0, " + k$ + ", @\"" + text$ + "\")"
	END IF
END SUB
'
'
' *****  UpdateTextArray  *****
'
SUB UpdateTextArray
	XuiSendMessage (grid, #GetTextArray, 0, 0, 0, 0, k, @tt$[])
	IF tt$[] THEN
		maxi = -1
		FOR t = 0 TO UBOUND(tt$[])
			IF tt$[t] THEN maxi = t
		NEXT t
		IF (maxi >= 0) THEN
			maxi$ = STRING$(maxi)
			digits = LEN(maxi$)
			XstBinArrayToBackArray (@tt$[], @text$[])
			IF ((i + maxi + 4) >= upper) THEN upper = upper + maxi + 32 : REDIM w$[upper]
			INC i : w$[i]  = "	DIM text$[" + STRING(maxi) + "]"
			FOR t = 0 TO maxi
				backtext$ = text$[t]
				INC i : w$[i]  = "	text$[" + RJUST$(STRING(t),digits) + "] = \"" + backtext$ + "\""
			NEXT t
			INC i : w$[i]  = "	XuiSendMessage ( " + g$ + ", #SetTextArray, 0, 0, 0, 0, " + k$ + ", @text$[])"
		END IF
	END IF
END SUB
'
'
' *****  LoadWindow  *****
'
SUB LoadWindow
	XuiSendMessage (fileGrid, #Update, 0, 0, 0, 0, 0, 0)
	XuiGetReply (fileGrid, "Filename of Window Function", "", "", @cancel, 0, @reply, @reply$)
	IF (cancel < 0) THEN EXIT SUB
	IFZ reply$ THEN EXIT SUB
	##ERROR = $$FALSE
	upper = UBOUND (reply$)
	IF (reply${upper} = $$PathSlash) THEN EXIT SUB				' need file, not directory
	dot = INSTR (reply$, ".")
	IFZ dot THEN reply$ = reply$ + ".win"
	ifile = OPEN (reply$, $$RD)
	IF (##ERROR OR (ifile <= 0)) THEN
		XuiMessage ("ToolkitCode()\nLoadWindow\nError\n\nCannot open disk file\n<" + reply$ + ">")
		EXIT SUB
	END IF
	length = LOF (ifile)
	IF (length <= 0) THEN
		XuiMessage (@"ToolkitCode()\nLoadWindow\n\nError:  File empty or not accessible")
		EXIT SUB
	END IF
	ifile$ = NULL$ (length)
	READ [ifile], ifile$
	CLOSE (ifile)
	XstStringToStringArray (@ifile$, @ifile$[])
	GOSUB ArrayToWindow
END SUB
'
'
' *****  WindowFromFunction  *****
'
SUB WindowFromFunction
	IF ##USERRUNNING THEN XuiMessage (@"ToolkitCode()\nWindowFromFunction\n\nError:  Program running") : EXIT SUB
	IFZ GuiProgram() THEN XuiMessage (@"ToolkitCode()\nWindowFromFunction\n\nError:  Need valid GUI program\n\nA: FileNewGuiProgram\nB: FileLoad (a GUI program)") : EXIT SUB
	XitGetDisplayedFunction (@funcname$)
	IFZ funcname$ THEN XuiMessage (@"ToolkitCode()\nWindowFromFunction\n\nError:  Valid grid function not displayed") : EXIT SUB
	IF (funcname$ = "PROLOG") THEN XuiMessage (@"ToolkitCode()\nFunctionToWindow\n\nError:  Valid grid function not displayed") : EXIT SUB
	IF (RIGHT$(funcname$,4) = "Code") THEN funcname$ = RCLIP$(funcname$,4)
	XitGetFunction (funcname$, @ifile$[])
	IFZ ifile$[] THEN XuiMessage (@"ToolkitCode()\nFunctionToWindow\n\nError:  Valid grid function not displayed") : EXIT SUB
	GOSUB ArrayToWindow
END SUB
'
'
' *****  ArrayToWindow  *****
'
SUB ArrayToWindow
	found = $$FALSE
	recreate = $$FALSE
	gotDesignX = $$FALSE
	gotDesignY = $$FALSE
	gotDesignWidth = $$FALSE
	gotDesignHeight = $$FALSE
'
	upper = UBOUND(ifile$[])
	FOR i = 0 TO upper
		ifile$ = ifile$[i]
		ilength = LEN (ifile$)
		IFZ funcLine THEN
			IF (LEFT$(ifile$, 8) = "FUNCTION") THEN
				func$ = MID$(ifile$, 9)
				ValidSimpleSymbol (@func$)
				IFZ func$ THEN EXIT FOR
				funcLine = i
			END IF
		END IF
		IFZ startCreate THEN
			IF (ifile$ = "SUB Create") THEN startCreate = i : DO NEXT
		END IF
		IF startCreate THEN
			IFZ endCreate THEN
				IFZ ifile$ THEN endCreate = i : DO NEXT
				IF (ifile${0} = ''') THEN comment = i : DO NEXT
				IF (LEFT$(ifile$, 3) = "END") THEN endCreate = i : DO NEXT
				IF (LEFT$(ifile$, 5) = "GOSUB") THEN endCreate = i : DO NEXT
'				IF ((ilength = 1) AND (ifile${0} = ''')) THEN endCreate = i : DO NEXT
			END IF
		END IF
		SELECT CASE FALSE
			CASE gotDesignX				:	check = INSTR(ifile$, "designX = ")
															IF check THEN
																gotDesignX = $$TRUE
																designX = XLONG(MID$(ifile$,check+10))
															END IF
			CASE gotDesignY				:	check = INSTR(ifile$, "designY = ")
															IF check THEN
																gotDesignY = $$TRUE
																designY = XLONG(MID$(ifile$,check+10))
															END IF
			CASE gotDesignWidth		:	check = INSTR(ifile$, "designWidth = ")
															IF check THEN
																gotDesignWidth = $$TRUE
																designWidth = XLONG(MID$(ifile$,check+14))
															END IF
			CASE gotDesignHeight	:	check = INSTR (ifile$, "designHeight = ")
															IF check THEN
																gotDesignHeight = $$TRUE
																designHeight = XLONG(MID$(ifile$,check+15))
															END IF
		END SELECT
	NEXT i
'
	IFZ func$ THEN XuiMessage (@"ToolkitCode()\nFunctionToWindow\n\nerror\ninvalid function name") : EXIT SUB
	IFZ (startCreate && endCreate) THEN XuiMessage (@"ToolkitCode()\nFunctionToWindow\n\nerror\nnot a valid grid function\n(No <SUB Create ... END SUB> block)") : EXIT SUB
	IFZ (gotDesignX AND gotDesignY AND gotDesignWidth AND gotDesignHeight) THEN XuiMessage (@"ToolkitCode()\nFunctionToWindow\n\nError\nnot a valid grid function\n(Didn't find <designX, designY, designWidth, designHeight> assignments)") : EXIT SUB
	IF ((designWidth > 0) AND (designHeight > 0)) THEN recreate = $$TRUE
	v0 = designX : v1 = designY : v2 = designWidth : v3 = designHeight
	GOSUB CreateDesignWindow
'
	FOR i = startCreate+1 TO endCreate-1
		i$ = TRIM$(ifile$[i])
		ParseFuncLine (@i$, @a$[])
		IFZ a$[] THEN
			IF i$ THEN
				IF (i${0} = ''') THEN DO NEXT
			END IF
			IF LEFT$(i$, 4) = "DIM " THEN
				d = INSTR (i$, "$")
				s = INSTR (i$, "[")
				e = INSTR (i$, "]")
				IF ((s > 0) AND (d < s) AND (s < e)) THEN
					array$ = TRIM$(MID$(i$, 5, d-4))
					u$ = MID$(i$, s+1, e-s-1)
					u = XLONG (u$)
					DIM tt$[u]
					done = 0
					DO WHILE (i < (endCreate-1))
						INC i
						i$	= TRIM$(ifile$[i])
						d		= INSTR (i$, "$")
						s		= INSTR (i$, "[")
						e		= INSTR (i$, "]")
						qs	= INSTR (i$, "\"")
						qe	= LEN (i$)
						qe$ = MID$(i$, qe)
						name$ = TRIM$(LEFT$(i$, d))
						IF (qe$ != "\"") THEN DEC i : EXIT DO
						IF (array$ != name$) THEN DEC i : EXIT DO
						IFZ (d && s && e && qs && qe) THEN DEC i : EXIT DO
						s$	= MID$(i$, qs+1, qe-qs-1)
						n$	= MID$(i$, s+1, e-s-1)
						n		= XLONG (n$)
						IF (n > u) THEN DEC i : EXIT DO
						t$ = XstBackStringToBinString$ (@s$)
						SWAP t$, tt$[n]
					LOOP
				END IF
			END IF
		ELSE
'			FOR j = 0 TO 9
'				PRINT ":"; a$[j]; ":  ";
'			NEXT j
'			PRINT
			IF i$ THEN
				IF (i${0} = ''') THEN DO NEXT
			END IF
			theFunc$ = a$[0]
			theGrid$ = a$[1]
			theMessage$ = a$[2]
			IF theMessage$ THEN
				IF (theMessage${0} = '#') THEN theMessage$ = MID$(theMessage$,2)
			END IF
			XgrMessageNameToNumber (@theMessage$, @theMessage)
			v0 = XLONG(a$[3])
			v1 = XLONG(a$[4])
			v2 = XLONG(a$[5])
			v3 = XLONG(a$[6])
			r0 = XLONG(a$[7])
			r1 = XLONG(a$[8])
			SELECT CASE theFunc$
				CASE "XuiSendMessage"	: GOSUB SendMessage
				CASE "XuiCreateGrid"	: GOSUB CreateBaseGrid
				CASE ELSE							: GOSUB OtherFunction
			END SELECT
		END IF
		aa$ = ""
		IF eee THEN
			PRINT "Error : " + ifile$[eee] : func$ = ""
			EXIT FOR
		END IF
	NEXT i
	XuiSendMessage (baseGrid, #SetWindowTitle, 0, 0, 0, 0, 0, @func$)
	XuiSendMessage (toolkitGrid, #SetTextString, 0, 0, 0, 0, $Text, @func$)
	XuiSendMessage (toolkitGrid, #Redraw, 0, 0, 0, 0, $Text, 0)
	window$[window] = func$
	window$ = func$
	IF func$ THEN
		GOSUB DesignMode
		GOSUB SelectWindow
	ELSE
		GOSUB DeleteWindow
	END IF
	window$[window] = func$
	GOSUB UpdateMenu
END SUB
'
'
' *****  CreateBaseGrid  *****
'
SUB CreateBaseGrid
	IF gridCreated THEN eee = i : EXIT SUB
	IF (a$[1] != "@grid") THEN eee = i : EXIT SUB
	IF (a$[2] != func$) THEN eee = i : EXIT SUB
	IF (a$[3] != "@v0") THEN eee = i : EXIT SUB
	IF (a$[4] != "@v1") THEN eee = i : EXIT SUB
	IF (a$[5] != "@v2") THEN eee = i : EXIT SUB
	IF (a$[6] != "@v3") THEN eee = i : EXIT SUB
	IF (a$[7] != "r0") THEN eee = i : EXIT SUB
	IF (a$[8] != "r1") THEN eee = i : EXIT SUB
	IF (a$[9] != "&" + func$ + "()") THEN eee = i : EXIT SUB
	baseGridType$ = func$
	XgrRegisterGridType (@baseGridType$, @baseGridType)
	gridCreated = i
	theName$ = "grid"
	theGrid = grid
	kidNumber = 0
END SUB
'
'
' *****  SendMessage  *****
'
SUB SendMessage
'	IF (theMessage = #SetGridProperties) THEN		' no error, but skip it
'		gotSetGridProperties = $$TRUE
'		EXIT SUB
'	END IF
	IFZ gridCreated THEN eee = i : EXIT SUB
	IFZ theGrid THEN eee = i : EXIT SUB
	IF (a$[1] != theName$) THEN eee = i : EXIT SUB
	SELECT CASE theMessage
		CASE #SetBorder						:	XgrBorderNameToNumber (a$[3], @vv0)
																XgrBorderNameToNumber (a$[4], @vv1)
																XgrBorderNameToNumber (a$[5], @vv2)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
																IF (v3 >= 0) THEN v3 = vv3
		CASE #SetCallback					:	@f ( theGrid, #SetCallback, theGrid, &Design(), -1, -1, kidNumber, theGrid)
																EXIT SUB
		CASE #SetColor, #SetColorExtra, #SetFocusColor, #SetFocusColorExtra
																XgrColorNameToNumber (a$[3], @vv0)
																XgrColorNameToNumber (a$[4], @vv1)
																XgrColorNameToNumber (a$[5], @vv2)
																XgrColorNameToNumber (a$[6], @vv3)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
																IF (v3 >= 0) THEN v3 = vv3
		CASE #SetAlign						:	XuiAlignNameToNumber (a$[3], @vv0)
																XuiJustifyNameToNumber (a$[4], @vv1)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
		CASE #SetGridName					:	r1$ = a$[8]
		CASE #SetGridTypeName			:	r1$ = a$[8]
		CASE #SetGridFunctionName	:	r1$ = a$[8]
		CASE #SetHelpString				:	r1$ = a$[8]
		CASE #SetHintString				:	r1$ = a$[8]
		CASE #SetFont							:	r1$ = a$[8]
		CASE #SetImage						:	rx$ = a$[8]
																r1$ = XstBackStringToBinString$ (@rx$)
		CASE #SetMessageFunc			: PRINT "ToolkitCode() : WindowFromFunction : XuiSetMessageFunc() ignored"
																EXIT SUB
		CASE #SetTextString				:	r1$ = a$[8]
																r1$ = XstBackStringToBinString$ (@r1$)
		CASE #SetTextArray				:	aa$ = a$[8]
		CASE #SetTexture					:	XuiTextureNameToNumber (a$[3], @vv0)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
		CASE #Create							:	eee = i : EXIT SUB
		CASE #CreateWindow				:	eee = i : EXIT SUB
	END SELECT
'
	SELECT CASE TRUE
		CASE r1$	:	start = INSTR (r1$, "\"")
								IFZ start THEN eee = i : EXIT SUB
								final = RINSTR (r1$, "\"")
								IF (final <= start) THEN eee = i : EXIT SUB
								length = final - start - 1
								IFZ length THEN r1$ = "" ELSE r1$ = MID$(r1$, start+1, length)
								XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, @r1$)
		CASE aa$	:	aa$ = TRIM$ (aa$)
								IF (LEFT$(aa$, 1) = "@") THEN aa$ = MID$(aa$, 2)
								d = INSTR (aa$, "$")
								s = INSTR (aa$, "[")
								IF (d < 2) THEN NEXT CASE
								IF (s < d) THEN NEXT CASE
								aa$ = LEFT$ (aa$, d)
								IF (aa$ != array$) THEN NEXT CASE
								IF tt$[] THEN XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, @tt$[])
		CASE ELSE	:	XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, r1)
	END SELECT
END SUB
'
'
' *****  OtherFunction  *****
'
SUB OtherFunction
	IFZ theMessage THEN eee = i : EXIT SUB
	SELECT CASE theMessage
		CASE #Create:				IF (a$[1]{0} != '@') THEN eee = i : EXIT SUB
												XuiGridFuncNameToAddr (@theFunc$, @f)
												IFZ f THEN eee = i : EXIT SUB
												theName$ = MID$(a$[1], 2)
												createFunc$ = theFunc$
												@f (@theGrid, #Create, v0, v1, v2, v3, window, baseGrid)
												IF (theGrid <= 0) THEN eee = i : EXIT SUB
												INC kidNumber
												grid[theGrid].selectable = $$TRUE
		CASE #SetCallback:	@f ( theGrid, #SetCallback, theGrid, &Design(), -1, -1, kidNumber, theGrid)
		CASE ELSE:					IF (theName$ != a$[1]) THEN eee = i : EXIT SUB
												IF (theFunc$ != createFunc$) THEN eee = i : EXIT SUB
												GOSUB SendMessage
	END SELECT
END SUB
'
'
' *****  Appearance  *****
'
SUB Appearance
	workGrid = 0
	IF selectGrid THEN workGrid = selectGrid ELSE workGrid = lastSelectGrid
	IFZ workGrid THEN EXIT SUB
	DeselectGrid (selectGrid)
	AppearanceCode (appearanceGrid, #DisplayWindow, workGrid, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Behavior  *****
'
SUB Behavior
	workGrid = 0
	IF selectGrid THEN workGrid = selectGrid ELSE workGrid = lastSelectGrid
	IFZ workGrid THEN EXIT SUB
	IF selectGrid THEN DeselectGrid (selectGrid)
	Behavior (workGrid)
END SUB
'
'
' *****  CreateTool  *****
'
SUB CreateTool
	IFZ designWindow THEN EXIT SUB
	IF selectGrid THEN DeselectGrid (selectGrid)
	IF testMode THEN XuiMessage (@"ToolkitCode() : CreateTool\nError: Can't create tool in TestMode") : EXIT SUB
'
	gridType = tool[tool]
	IF (tool = $Another) THEN
		IFZ lastSelectGrid THEN EXIT SUB
		gridType = grid[lastSelectGrid].gridType
		IFZ gridType THEN EXIT SUB
	END IF
'
	winWidth	= windowInfo[designWindow].width
	winHeight	= windowInfo[designWindow].height
	outer			= windowInfo[designWindow].graph
	IF (outer != graph) THEN PRINT "ToolkitCode() : CreateTool : error ::: (outer != graph)"
	w					= gridType[gridType].width
	h					= gridType[gridType].height
	IF (w < 12) THEN w = 32
	IF (h < 12) THEN h = 32
	toolFunc	= gridType[gridType].gridFunc
	IF (w > (winWidth-8)) THEN w = winWidth - 8
	IF (h > (winHeight-8)) THEN h = winHeight - 8
'
	XuiSendMessage (baseGrid, #GetBorder, 0, 0, 0, 0, 0, @baseBorderWidth)
	xMin = baseBorderWidth
	yMin = baseBorderWidth
'
	xWin = xMin
	yWin = yMin
	gt = gridType
'
	IFZ gridType[gt].grid THEN
		IF lastSelectGrid THEN gt = grid[lastSelectGrid].gridType
	END IF
'
'
' *****  Create selectGrid  *****
'
	@toolFunc (@grid, #Create, @xWin, @yWin, @w, @h, designWindow, outer)
	IF (grid <= 0) THEN PRINT "ToolkitCode() : CreateToolkitGrid : error : (grid <= 0)" : RETURN
	@toolFunc ( grid, #GetKidNumber, @kid, 0, 0, 0, 0, 0)
	@toolFunc ( grid, #SetCallback, grid, &Design(), -1, -1, kid, grid)
	ww = w
	hh = h
	IF (ww < 12) THEN ww = 32
	IF (hh < 12) THEN hh = 32
	GOSUB Stacker
	IF ((xWin + w) > winWidth) THEN xWin = xMin
	IF ((xWin + w) > winWidth) THEN xWin = 0
	IF ((yWin + h) > winHeight) THEN yWin = yMin
	IF ((yWin + h) > winHeight) THEN yWin = 0
	@toolFunc (grid, #Resize, @xWin, @yWin, @w, @h, 0, 0)
	IF (((yWin + h) > winHeight) OR ((xWin + w) > winWidth)) THEN
		@toolFunc ( grid, #Resize, xWin, yWin, winWidth-xWin, winHeight-yWin, 0, 0)
		@toolFunc ( grid, #GetSize, @xWin, @yWin, @w, @h, 0, 0)
		IF (((xWin + w) > winWidth) OR ((yWin + h) > winHeight)) THEN
			@toolFunc ( grid, #Destroy, 0, 0, 0, 0, 0, 0)
			XuiMessage (@"Error\n\nGrid Larger Than\nCurrent Design Window")
			EXIT SUB
		END IF
	END IF
	XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	grid[grid].selectable = $$TRUE
	gridType[gridType].grid = grid
	SelectGrid (grid)
END SUB
'
'
' *****  Stacker  *****
'
SUB Stacker
	IF (v2 AND $$CtrlBit) THEN dir = -1 ELSE dir = +1
	IF (v2 AND $$ShiftBit) THEN flip = -1 ELSE flip = 0
	IFZ flip THEN GOSUB StackHorizontal ELSE GOSUB StackVertical
END SUB
'
'
' *****  StackHorizontal  *****
'
SUB StackHorizontal
	IFZ lastSelectGrid THEN
		xWin = xMin
		yWin = yMin
		EXIT SUB
	END IF
'
	xWin			= selectX + (selectW * dir)										' stack horizontal
	yWin			= selectY
'
	IF ((xWin < 0) OR ((xWin + ww - 1) > winWidth)) THEN		' stack vertical
		xWin		= selectX
		yWin		= selectY + (selectH * dir)
	END IF
'
	IF ((xWin < 0) OR ((xWin + ww - 1) > winWidth)) THEN		' stack not
		xWin		= xMin
		yWin		= yMin
	END IF
'
	IF ((yWin < 0) OR ((yWin + hh - 1) > winHeight)) THEN		' stack not
		xWin		= xMin
		yWin		= yMin
	END IF
END SUB
'
'
' *****  StackVertical  *****
'
SUB StackVertical
	IFZ lastSelectGrid THEN
		xWin = xMin
		yWin = yMin
		EXIT SUB
	END IF
'
	xWin			= selectX																			' stack vertical
	yWin			= selectY + (selectH * dir)
'
	IF ((yWin < 0) OR ((yWin + hh - 1) > winHeight)) THEN		' stack horizontal
		xWin		= selectX + (selectW * dir)
		yWin		= selectY
	END IF
'
	IF ((yWin < 0) OR ((yWin + hh - 1) > winHeight)) THEN		' stack not
		xWin		= xMin
		yWin		= yMin
	END IF
'
	IF ((xWin < 0) OR ((xWin + ww - 1) > winWidth)) THEN		' stack not
		xWin		= xMin
		yWin		= yMin
	END IF
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	graph = 0
	windex = 0
	window = 0
	window$ = ""
	DIM gindex[31]
	DIM windex[31]
END SUB
END FUNCTION
'
'
' ###########################
' #####  Appearance ()  #####
' ###########################
'
FUNCTION  Appearance (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
  STATIC	SUBADDR  sub[]
	STATIC	upperMessage
  STATIC	Appearance
'
	$Appearance               =  0
	$Menu                     =  1
	$LabelGridType            =  2
	$LabelGridTypeText        =  3
	$LabelGridFunc            =  4
	$LabelGridFuncText        =  5
	$LabelGridName            =  6
	$TextLineGridName         =  7
	$LabelHintString          =  8
	$TextLineHintString       =  9
	$LabelHelpString          = 10
	$TextLineHelpString       = 11
	$ButtonBackground         = 12
	$AreaBackground           = 13
	$Color                    = 14
	$ButtonDrawing            = 15
	$AreaDrawing              = 16
	$ButtonLowlight           = 17
	$AreaLowlight             = 18
	$ButtonHighlight          = 19
	$AreaHighlight            = 20
	$ButtonDull               = 21
	$AreaDull                 = 22
	$SolidColor               = 23
	$AreaBorders              = 24
	$AreaNone                 = 25
	$AreaFlat1                = 26
	$AreaFlat2                = 27
	$AreaFlat4                = 28
	$AreaHiLine1              = 29
	$AreaHiLine2              = 30
	$AreaHiLine4              = 31
	$AreaRaise1               = 32
	$AreaRaise2               = 33
	$AreaRaise4               = 34
	$ButtonAccent             = 35
	$AreaAccent               = 36
	$ButtonLowtext            = 37
	$AreaLowtext              = 38
	$AreaRidge                = 39
	$AreaValley               = 40
	$AreaFrame                = 41
	$AreaDrain                = 42
	$AreaLoLine1              = 43
	$AreaLoLine2              = 44
	$AreaLoLine4              = 45
	$AreaLower1               = 46
	$AreaLower2               = 47
	$AreaLower4               = 48
	$ButtonHightext           = 49
	$AreaHightext             = 50
	$LabelTextString          = 51
	$TextLineTextString       = 52
	$LabelTextTexture         = 53
	$ButtonFlat               = 54
	$ButtonLower              = 55
	$ButtonRaise              = 56
	$ButtonShadow             = 57
	$LabelJustify             = 58
	$ButtonJustifyLeft        = 59
	$ButtonJustifyCenter      = 60
	$ButtonJustifyRight       = 61
	$ButtonJustifyBoth        = 62
	$ButtonAlignUpperLeft     = 63
	$ButtonAlignUpperCenter   = 64
	$ButtonAlignUpperRight    = 65
	$ButtonFont               = 66
	$LabelStyle               = 67
	$RangeStyle               = 68
	$RangeIndentLeft          = 69
	$RangeIndentRight         = 70
	$ButtonAlignMiddleLeft    = 71
	$ButtonAlignMiddleCenter  = 72
	$ButtonAlignMiddleRight   = 73
	$ButtonTextArray          = 74
	$LabelTimer               = 75
	$RangeTimer               = 76
	$RangeIndentTop           = 77
	$RangeIndentBottom        = 78
	$ButtonAlignLowerLeft     = 79
	$ButtonAlignLowerCenter   = 80
	$ButtonAlignLowerRight    = 81
	$ButtonImage              = 82
	$ButtonEnter              = 83
	$ButtonRestore            = 84
	$ButtonDefaults           = 85
	$ButtonCancel             = 86
	$UpperKid                 = 86
'
'	XgrMessageNumberToName (message, @mess$)
'	PRINT grid;; message;; mess$;; HEX$(v0,8);; HEX$(v1,8);; HEX$(v2,8);; HEX$(v3,8);; r0;; r1
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, Appearance) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, Appearance, @v0, @v1, @v2, @v3, r0, r1, &Appearance())
	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Appearance")
	XuiMenu        (@g, #Create, 4, 4, 396, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $Menu, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Menu")
	DIM text$[1]
	text$[0] = "_Kids"
	text$[1] = " _Self"
	XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 1, @"AppearanceMenuBar")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 1, @"_Kids")
	XuiLabel       (@g, #Create, 4, 28, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelGridType")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"GridType:")
	XuiLabel       (@g, #Create, 112, 28, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelGridTypeText")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 6, 0, 0, 0)
	XuiLabel       (@g, #Create, 4, 52, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelGridFunc")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"GridFunc:")
	XuiLabel       (@g, #Create, 112, 52, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelGridFuncText")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 6, 0, 0, 0)
	XuiLabel       (@g, #Create, 4, 76, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelGridName")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"GridName:")
	XuiTextLine    (@g, #Create, 112, 76, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $TextLineGridName, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLineGridName")
	XuiLabel       (@g, #Create, 4, 100, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelHintString")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"HintString:")
	XuiTextLine    (@g, #Create, 112, 100, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $TextLineHintString, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLineHintString")
	XuiLabel       (@g, #Create, 4, 124, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelHelpString")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"HelpString:")
	XuiTextLine    (@g, #Create, 112, 124, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $TextLineHelpString, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLineHelpString")
	XuiPushButton  (@g, #Create, 4, 148, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonBackground, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonBackground")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"background")
	XuiLabel       (@g, #Create, 112, 148, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaBackground")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiColors      (@g, #Create, 144, 148, 250, 80, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $Color, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Color")
	XuiPushButton  (@g, #Create, 4, 168, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonDrawing, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonDrawing")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"drawing")
	XuiLabel       (@g, #Create, 112, 168, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaDrawing")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 188, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonLowlight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonLowlight")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"lowlight")
	XuiLabel       (@g, #Create, 112, 188, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLowlight")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 208, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonHighlight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonHighlight")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"highlight")
	XuiLabel       (@g, #Create, 112, 208, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaHighlight")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 228, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonDull, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonDull")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"dull")
	XuiLabel       (@g, #Create, 112, 228, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaDull")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiSolidColor  (@g, #Create, 144, 228, 40, 80, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $SolidColor, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"SolidColor")
	XuiLabel       (@g, #Create, 184, 228, 216, 80, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaBorders")
' XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiArea        (@g, #Create, 188, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaNone, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaNone")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"0")
	XuiArea        (@g, #Create, 208, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaFlat1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaFlat1")
	XuiSendMessage ( g, #SetBorder, $$BorderFlat1, $$BorderFlat1, $$BorderFlat1, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"1")
	XuiArea        (@g, #Create, 228, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaFlat2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaFlat2")
	XuiSendMessage ( g, #SetBorder, $$BorderFlat2, $$BorderFlat2, $$BorderFlat2, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"2")
	XuiArea        (@g, #Create, 248, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaFlat4, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaFlat4")
	XuiSendMessage ( g, #SetBorder, $$BorderFlat4, $$BorderFlat4, $$BorderFlat4, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"4")
	XuiArea        (@g, #Create, 276, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaHiLine1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaHiLine1")
	XuiSendMessage ( g, #SetBorder, $$BorderHiLine1, $$BorderHiLine1, $$BorderHiLine1, -1, 0, 0)
	XuiArea        (@g, #Create, 296, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaHiLine2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaHiLine2")
	XuiSendMessage ( g, #SetBorder, $$BorderHiLine2, $$BorderHiLine2, $$BorderHiLine2, -1, 0, 0)
	XuiArea        (@g, #Create, 316, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaHiLine4, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaHiLine4")
	XuiSendMessage ( g, #SetBorder, $$BorderHiLine4, $$BorderHiLine4, $$BorderHiLine4, -1, 0, 0)
	XuiArea        (@g, #Create, 340, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaRaise1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaRaise1")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, -1, 0, 0)
	XuiArea        (@g, #Create, 360, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaRaise2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaRaise2")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise2, $$BorderRaise2, $$BorderRaise2, -1, 0, 0)
	XuiArea        (@g, #Create, 380, 232, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaRaise4, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaRaise4")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise4, $$BorderRaise4, $$BorderRaise4, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 248, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAccent, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAccent")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"accent")
	XuiLabel       (@g, #Create, 112, 248, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaAccent")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 268, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonLowtext, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonLowtext")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"lowtext")
	XuiLabel       (@g, #Create, 112, 268, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLowtext")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiArea        (@g, #Create, 188, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaRidge, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaRidge")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, -1, 0, 0)
	XuiArea        (@g, #Create, 208, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaValley, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaValley")
	XuiSendMessage ( g, #SetBorder, $$BorderValley, $$BorderValley, $$BorderValley, -1, 0, 0)
	XuiArea        (@g, #Create, 228, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaFrame, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaFrame")
	XuiSendMessage ( g, #SetBorder, $$BorderFrame, $$BorderFrame, $$BorderFrame, -1, 0, 0)
	XuiArea        (@g, #Create, 248, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaDrain, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaDrain")
	XuiSendMessage ( g, #SetBorder, $$BorderDrain, $$BorderDrain, $$BorderDrain, -1, 0, 0)
	XuiArea        (@g, #Create, 276, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLoLine1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLoLine1")
	XuiSendMessage ( g, #SetBorder, $$BorderLoLine1, $$BorderLoLine1, $$BorderLoLine1, -1, 0, 0)
	XuiArea        (@g, #Create, 296, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLoLine2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLoLine2")
	XuiSendMessage ( g, #SetBorder, $$BorderLoLine2, $$BorderLoLine2, $$BorderLoLine2, -1, 0, 0)
	XuiArea        (@g, #Create, 316, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLoLine4, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLoLine4")
	XuiSendMessage ( g, #SetBorder, $$BorderLoLine4, $$BorderLoLine4, $$BorderLoLine4, -1, 0, 0)
	XuiArea        (@g, #Create, 340, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLower1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLower1")
	XuiSendMessage ( g, #SetBorder, $$BorderLower1, $$BorderLower1, $$BorderLower1, -1, 0, 0)
	XuiArea        (@g, #Create, 360, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLower2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLower2")
	XuiSendMessage ( g, #SetBorder, $$BorderLower2, $$BorderLower2, $$BorderLower2, -1, 0, 0)
	XuiArea        (@g, #Create, 380, 272, 16, 32, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $AreaLower4, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaLower4")
	XuiSendMessage ( g, #SetBorder, $$BorderLower4, $$BorderLower4, $$BorderLower4, -1, 0, 0)
	XuiPushButton  (@g, #Create, 4, 288, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonHightext, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonHightext")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"hightext")
	XuiLabel       (@g, #Create, 112, 288, 32, 20, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"AreaHightext")
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRaise1, -1, 0, 0)
	XuiLabel       (@g, #Create, 4, 308, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelTextString")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"TextString:")
	XuiTextLine    (@g, #Create, 112, 308, 288, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $TextLineTextString, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextStringTextLine")
	XuiLabel       (@g, #Create, 4, 332, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelTextTexture")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"TextTexture:")
	XuiPushButton  (@g, #Create, 112, 332, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonFlat, grid)
	XuiSendMessage ( g, #SetTexture, $$TextureNone, $$TextureNone, $$TextureNone, 0, 0, 0)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonFlat")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"flat")
	XuiPushButton  (@g, #Create, 184, 332, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonLower, grid)
	XuiSendMessage ( g, #SetTexture, $$TextureLower1, $$TextureLower1, $$TextureLower1, 0, 0, 0)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonLower")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"lower")
	XuiPushButton  (@g, #Create, 256, 332, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonRaise, grid)
	XuiSendMessage ( g, #SetTexture, $$TextureRaise1, $$TextureRaise1, $$TextureRaise1, 0, 0, 0)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonRaise")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"raise")
	XuiPushButton  (@g, #Create, 328, 332, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonShadow, grid)
	XuiSendMessage ( g, #SetTexture, $$TextureShadow, $$TextureShadow, $$TextureShadow, 0, 0, 0)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonShadow")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"shadow")
	XuiLabel       (@g, #Create, 4, 356, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"LabelJustify")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"TextJustify:")
	XuiPushButton  (@g, #Create, 112, 356, 36, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonJustifyLeft, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonJustifyLeft")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\justl.bmp")
	XuiPushButton  (@g, #Create, 148, 356, 36, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonJustifyCenter, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonJustifyCenter")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\justc.bmp")
	XuiPushButton  (@g, #Create, 184, 356, 36, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonJustifyRight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonJustifyRight")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\justr.bmp")
	XuiPushButton  (@g, #Create, 220, 356, 36, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonJustifyBoth, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonJustifyBoth")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\justb.bmp")
	XuiPushButton  (@g, #Create, 256, 356, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignUpperLeft, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignUpperLeft")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignul.bmp")
	XuiPushButton  (@g, #Create, 280, 356, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignUpperCenter, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignUpperCenter")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignuc.bmp")
	XuiPushButton  (@g, #Create, 304, 356, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignUpperRight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignUpperRight")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignur.bmp")
	XuiPushButton  (@g, #Create, 328, 356, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonFont, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonFont")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"font")
	XuiLabel       (@g, #Create, 4, 380, 54, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Style")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"style")
	XuiRange       (@g, #Create, 58, 380, 54, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeStyle, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeStyle")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeStyle")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\style.bmp")
	XuiRange       (@g, #Create, 112, 380, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeIndentLeft, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeIndentLeft")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeIndentLeft")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\indentl.bmp")
	XuiRange       (@g, #Create, 184, 380, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeIndentRight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeIndentRight")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeIndentRight")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\indentr.bmp")
	XuiPushButton  (@g, #Create, 256, 380, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignMiddleLeft, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignMiddleLeft")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignml.bmp")
	XuiPushButton  (@g, #Create, 280, 380, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignMiddleCenter, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignMiddleCenter")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignmc.bmp")
	XuiPushButton  (@g, #Create, 304, 380, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignMiddleRight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignMiddleRight")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignmr.bmp")
	XuiPushButton  (@g, #Create, 328, 380, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonTextArray, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonTextArray")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"text$[ ]")
	XuiLabel       (@g, #Create, 4, 404, 54, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Timer")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, 4, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"timer")
	XuiRange       (@g, #Create, 58, 404, 54, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeTimer, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeTimer")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeTimer")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\timer.bmp")
	XuiRange       (@g, #Create, 112, 404, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeIndentTop, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeIndentTop")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeIndentTop")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\indentt.bmp")
	XuiRange       (@g, #Create, 184, 404, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $RangeIndentBottom, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"RangeIndentBottom")
	XuiSendMessage ( g, #SetHelpString, 0, 0, 0, 0, -1, @":RangeIndentBottom")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 1, @"$XBDIR\\images\\indentb.bmp")
	XuiPushButton  (@g, #Create, 256, 404, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignLowerLeft, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignLowerLeft")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignll.bmp")
	XuiPushButton  (@g, #Create, 280, 404, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignLowerCenter, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignLowerCenter")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignlc.bmp")
	XuiPushButton  (@g, #Create, 304, 404, 24, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonAlignLowerRight, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonAlignLowerRight")
	XuiSendMessage ( g, #SetImage, 0, 0, 0, 0, 0, @"$XBDIR\\images\\alignlr.bmp")
	XuiPushButton  (@g, #Create, 328, 404, 72, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonImage, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonImage")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"image")
	XuiPushButton  (@g, #Create, 4, 428, 108, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonEnter, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonEnter")
'	XuiSendMessage ( g, #SetColor, $$BrightCyan, -1, -1, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 112, 428, 96, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonRestore, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonRestore")
'	XuiSendMessage ( g, #SetColor, $$BrightCyan, -1, -1, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" restore ")
	XuiPushButton  (@g, #Create, 208, 428, 96, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonDefaults, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonDefaults")
'	XuiSendMessage ( g, #SetColor, $$BrightCyan, -1, -1, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" defaults ")
	XuiPushButton  (@g, #Create, 304, 428, 96, 24, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &Appearance(), -1, -1, $ButtonCancel, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ButtonCancel")
'	XuiSendMessage ( g, #SetColor, $$BrightCyan, -1, -1, -1, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
  GOSUB Resize
	XuiMonitorHelp (grid, #MonitorHelp, grid, &Appearance(), 0, 0, 0, $$TRUE)
	XuiCreateValueArray (grid, #CreateValueArray, 15, 0, 0, 0, 0, 0)
	XuiSetValue (grid, #SetValue, -1, 0, 0, 0, 0, 15)
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
	GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"Appearance")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'	PRINT "Appearance() : MouseDown : RightButton + Ctl+Shift : "; style;; grid;; HEX$(v2,8)
	IF (style AND 0x01) THEN
		IF (grid != r1) THEN EXIT SUB		' always works on itself
	END IF
	IF (v2 AND $$ShiftBit) THEN
		IF (v2 AND $$ControlBit) THEN
			IF (v2 AND $$HelpButtonBit) THEN
'				PRINT "Appearance() : MouseDown : RightButton + Ctl+Shift : "; enabled;; grid;; HEX$(v2,8)
				XuiShowWindow (grid, #ShowWindow, 0, 0, 0, 0, 0, 0)
				XuiCallback (grid, #DisplayWindow, r1, 0, 0, 0, 0, grid)
				XuiSendMessage (r1, #Redraw, 0, 0, 0, 0, 0, 0)
				r0 = $$TRUE
			END IF
		END IF
	END IF
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]           = &XuiCallback()
	func[#MouseDown]					= 0
	func[#Resize]             = &XuiResizeNot()
'
	DIM sub[upperMessage]
	sub[#Create]              = SUBADDRESS (Create)
	sub[#CreateWindow]        = SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
'
	IF func[0] THEN PRINT "Appearance() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "Appearance() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@Appearance, "Appearance", &Appearance(), @func[], @sub[])
'
	designX = 616
	designY = 23
	designWidth = 404
	designHeight = 456
'
	gridType = Appearance
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        designWidth)
	XuiSetGridTypeProperty (gridType, @"minHeight",       designHeight)
	XuiSetGridTypeProperty (gridType, @"maxWidth",        designWidth)
	XuiSetGridTypeProperty (gridType, @"maxHeight",       designHeight)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $TextLineGridName)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $TextLineGridName)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###############################
' #####  AppearanceCode ()  #####
' ###############################
'
FUNCTION  AppearanceCode (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	appearanceGrid,  appearanceTextGrid,  appearanceTextState
	SHARED	designWindow,  designGrid
	SHARED	backgroundColor
	SHARED	kids[]
	SHARED	values[]
	SHARED	gridName$[]
	SHARED	gridType$[]
	SHARED	gridFunc$[]
	SHARED	fileGrid
	SHARED	fontGrid
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	upperGridType
	SHARED  backslash_literal[]
	SHARED	WINDOW  windowInfo[]
	SHARED	GRID	gridType[]
	SHARED	GRID	grid[]
	STATIC	GRID	start
	STATIC	GRID	current
	STATIC	SUBADDR  sub[]
	STATIC	Appearance
	STATIC	parent,  k,  kid
	STATIC	start$[],  start$,  startHelp$,  startHint$,  startGridName$
	STATIC	gridType,  gridName$,  gridType$,  gridFunc$
	STATIC	help$,  hint$,  image$,  text$,  text$[],  helpStrings$[]
	STATIC	oldColor,  thisColor
	STATIC	style,  styleMax, timer
	STATIC	border,  borderUp,  borderDown,  borderFlags
	STATIC	back,  draw,  low,  high,  acc,  dull,  lowtext,  hightext
	STATIC	font,  texture,  align,  justify
	STATIC	indentLeft,  indentTop,  indentRight,  indentBottom
	STATIC	imageIndentX,  imageIndentY
	FUNCADDR func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	$Appearance               =  0
	$Menu                     =  1
	$LabelGridType            =  2
	$LabelGridTypeText        =  3
	$LabelGridFunc            =  4
	$LabelGridFuncText        =  5
	$LabelGridName            =  6
	$TextLineGridName         =  7
	$LabelHintString          =  8
	$TextLineHintString       =  9
	$LabelHelpString          = 10
	$TextLineHelpString       = 11
	$ButtonBackground         = 12
	$AreaBackground           = 13
	$Color                    = 14
	$ButtonDrawing            = 15
	$AreaDrawing              = 16
	$ButtonLowlight           = 17
	$AreaLowlight             = 18
	$ButtonHighlight          = 19
	$AreaHighlight            = 20
	$ButtonDull               = 21
	$AreaDull                 = 22
	$SolidColor               = 23
	$AreaBorders              = 24
	$AreaNone                 = 25
	$AreaFlat1                = 26
	$AreaFlat2                = 27
	$AreaFlat4                = 28
	$AreaHiLine1              = 29
	$AreaHiLine2              = 30
	$AreaHiLine4              = 31
	$AreaRaise1               = 32
	$AreaRaise2               = 33
	$AreaRaise4               = 34
	$ButtonAccent             = 35
	$AreaAccent               = 36
	$ButtonLowtext            = 37
	$AreaLowtext              = 38
	$AreaRidge                = 39
	$AreaValley               = 40
	$AreaFrame                = 41
	$AreaDrain                = 42
	$AreaLoLine1              = 43
	$AreaLoLine2              = 44
	$AreaLoLine4              = 45
	$AreaLower1               = 46
	$AreaLower2               = 47
	$AreaLower4               = 48
	$ButtonHightext           = 49
	$AreaHightext             = 50
	$LabelTextString          = 51
	$TextLineTextString       = 52
	$LabelTextTexture         = 53
	$ButtonFlat               = 54
	$ButtonLower              = 55
	$ButtonRaise              = 56
	$ButtonShadow             = 57
	$LabelJustify             = 58
	$ButtonJustifyLeft        = 59
	$ButtonJustifyCenter      = 60
	$ButtonJustifyRight       = 61
	$ButtonJustifyBoth        = 62
	$ButtonAlignUpperLeft     = 63
	$ButtonAlignUpperCenter   = 64
	$ButtonAlignUpperRight    = 65
	$ButtonFont               = 66
	$LabelStyle               = 67
	$RangeStyle               = 68
	$RangeIndentLeft          = 69
	$RangeIndentRight         = 70
	$ButtonAlignMiddleLeft    = 71
	$ButtonAlignMiddleCenter  = 72
	$ButtonAlignMiddleRight   = 73
	$ButtonTextArray          = 74
	$LabelTimer               = 75
	$RangeTimer               = 76
	$RangeIndentTop           = 77
	$RangeIndentBottom        = 78
	$ButtonAlignLowerLeft     = 79
	$ButtonAlignLowerCenter   = 80
	$ButtonAlignLowerRight    = 81
	$ButtonImage              = 82
	$ButtonEnter              = 83
	$ButtonRestore            = 84
	$ButtonDefaults           = 85
	$ButtonCancel             = 86
	$UpperKid                 = 86
'
	IFZ helpStrings$[] THEN GOSUB Initialize
' XgrMessageNumberToName (message, @message$)
' PRINT "AppearanceCode() "; grid, message$, v0, v1, v2, v3, r0, r1
'
	SELECT CASE message
		CASE #Callback			: GOSUB Callback
		CASE #DisplayWindow	: GOSUB DisplayWindow
		CASE #HideWindow		: GOSUB HideWindow
		CASE #Reset					: GOSUB Reset
		CASE #SetValues			: GOSUB SetValues
'		CASE ELSE						: XuiPassOn (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
	END SELECT
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	SELECT CASE message
		CASE #MouseDown			: GOSUB Selection
		CASE #Selection			: GOSUB Selection
		CASE #DisplayWindow	: GOSUB DisplayWindow
'		CASE #TextEvent			: GOSUB TextEvent
	END SELECT
END SUB
'
'
' *****  SetValues  *****
'
SUB SetValues
	IFZ v0 THEN EXIT SUB
	IFZ appearanceGrid THEN EXIT SUB
	IFZ grid THEN grid = appearanceGrid
	IF (grid != appearanceGrid) THEN EXIT SUB
	XuiSendMessage (appearanceTextGrid, #SetTextArray, 0, 0, 0, 0, 0, @empty$[])
	XuiSendMessage (appearanceTextGrid, #Redraw, 0, 0, 0, 0, 0, 0)
	DIM empty$[]
'
	parent					= v0											' selectGrid = workGrid
	values[grid,0]	= v0											' selectGrid = workGrid
	slot						= $ButtonBackground
	GOSUB NewPlace
'
	g = v0 : k = 0														' g = grid : k = starting kid # = 0
	GOSUB GetGridAttributes										' get attributes of grid g
	GOSUB SetStartingAttributes								' set starting attributes
	GOSUB UpdateAppearanceWindow							' display attributes of g
	GOSUB UpdateKidsMenu											' update kids pulldown menu
END SUB
'
'
' *****  DisplayWindow  *****
'
SUB DisplayWindow
	IFZ v0 THEN EXIT SUB
	IFZ appearanceGrid THEN EXIT SUB
	IFZ grid THEN grid = appearanceGrid
	IF (grid != appearanceGrid) THEN EXIT SUB
	XuiSendMessage (appearanceTextGrid, #SetTextArray, 0, 0, 0, 0, 0, @empty$[])
	XuiSendMessage (appearanceTextGrid, #Redraw, 0, 0, 0, 0, 0, 0)
	DIM empty$[]
'
	parent					= v0											' selectGrid = workGrid
	values[grid,0]	= v0											' selectGrid = workGrid
	slot						= $ButtonBackground
	GOSUB NewPlace
'
	g = v0 : k = 0														' g = grid : k = starting kid # = 0
	GOSUB GetGridAttributes										' get attributes of grid g
	GOSUB SetStartingAttributes								' set starting attributes
	GOSUB UpdateAppearanceWindow							' display attributes of g
	GOSUB UpdateKidsMenu											' update kids pulldown menu
	XuiSendMessage (appearanceGrid, #DisplayWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  UpdateKidsMenu  *****
'
SUB UpdateKidsMenu
	kkk = -1
	kids$ = ""
	DIM kids$[999]
	INC kkk : kids$[kkk] = "_Kids"
	IFZ kids[g, ] THEN
		INC kkk : kids$[kkk] = " _0: " + gridName$[g]
	ELSE
		XuiSendMessage (g, #GetKidArray, 0, 0, 0, 0, 0, @k[])
		kids = UBOUND(k[])
		pad = 1
		IF (kids > 9) THEN pad = 2
		IF (kids > 99) THEN pad = 3
		IF (kids > 999) THEN pad = 4
		FOR i = 0 TO kids
			IF k[i] THEN
				SELECT CASE TRUE
					CASE (i <= 9)	: INC kkk : kids$[kkk] = RJUST$(" _" + STRING$(i), pad+2) + ": " + gridName$[k[i]]
					CASE ELSE			: INC kkk : kids$[kkk] = RJUST$(" " + STRING$(i), pad+1) + ": " + gridName$[k[i]]
				END SELECT
			END IF
		NEXT i
	END IF
	REDIM kids$[kkk]
	XuiSendMessage (appearanceGrid, #SetTextArray, 0, 0, 0, 0, $Menu, @kids$[])
END SUB
'
'
' *****  HideWindow  *****
'
SUB HideWindow
	IFZ appearanceGrid THEN EXIT SUB
	GOSUB Reset
	XuiSendMessage (appearanceGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
	XuiSendMessage (appearanceTextGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Reset  *****
'
SUB Reset
	IFZ appearanceGrid THEN EXIT SUB
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $LabelGridTypeText,  "")
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $LabelGridFuncText,  "")
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $TextLineGridName,   "")
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $TextLineHelpString, "")
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $TextLineTextString, "")
	XuiSendMessage (appearanceGrid, #SetTextString, 0, 0, 0, 0, $TextLineHelpString, "")
	XuiSendMessage (appearanceGrid, #SetValues, 0, 1, 0, 255, $RangeStyle,    0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $LabelGridTypeText,  0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $LabelGridFuncText,  0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $TextLineGridName,   0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $TextLineHelpString, 0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $TextLineTextString, 0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $TextLineHelpString, 0)
	XuiSendMessage (appearanceGrid, #Redraw, 0, 0, 0, 0, $RangeStyle,         0)
	XuiSendMessage (appearanceTextGrid, #SetTextArray, 0, 0, 0, 0, 0, @empty$[])
	XuiSendMessage (appearanceTextGrid, #Redraw, 0, 0, 0, 0, 0, 0)
	slot = $ButtonBackground
	DIM empty$[]
	GOSUB NewPlace
	DIM kids$[1]
	kids$[0] = "_Kids"
	kids$[1] = "[ No Active Grid ]"
	XuiSendMessage (appearanceGrid, #SetTextArray, 0, 0, 0, 0, $Menu, @kids$[])
	values[appearanceGrid,0] = 0
	parent = 0
	kid = 0
	k = 0
END SUB
'
'
' *****  GetGridAttributes  *****  g = gridNumber : k = kid #
'
SUB GetGridAttributes
	kid = g
	IF (k > 0) THEN
		XuiSendMessage (g, #GetKidArray, 0, 0, 0, 0, 0, @k[])
		IF k[] THEN
			upper = UBOUND(k[])
			IF (k > upper) THEN PRINT "Appearance() : GetGridAttributes : error : (k > upperKid)" : RETURN
			kid = k[k]
			IFZ kid THEN PRINT "Appearance() : GetGridAttributes : error : (kid grid number <= 0)" : RETURN
		END IF
	END IF
	XuiSendMessage (g, #GetInfo, 0, 0, 0, 0, k, @current)
	values[grid,4]	= g														' g = grid
	values[grid,5]	= k														' k = kid #
	values[grid,6]	= kid													' kid = kids[g,k]
	XuiSendMessage (g, #GetGridType, @gridType, 0, 0, 0, k, 0)
	XuiSendMessage (g, #GetGridName, 0, 0, 0, 0, k, @gridName$)
	XuiSendMessage (g, #GetGridTypeName, 0, 0, 0, 0, k, @gridType$)
	XuiSendMessage (g, #GetGridFunctionName, 0, 0, 0, 0, k, @gridFunc$)
	XuiSendMessage (g, #GetColor, @back, @draw, @low, @high, k, 0)
	XuiSendMessage (g, #GetColorExtra, @dull, @acc, @lowtext, @hightext, k, 0)
	XuiSendMessage (g, #GetBorder, @border, @borderUp, @borderDown, @borderFlags, k, 0)
	XuiSendMessage (g, #GetAlign, @align, @justify, 0, 0, k, 0)
	XuiSendMessage (g, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, k, 0)
	XuiSendMessage (g, #GetTexture, @texture, 0, 0, 0, k, 0)
	XuiSendMessage (g, #GetStyle, @style, @styleMax, 0, 0, k, 0)
	XuiSendMessage (g, #GetTimer, @timer, 0, 0, 0, k, 0)
	XuiSendMessage (g, #GetImage, 0, 0, @imageIndentX, @imageIndentY, k, @image$)
	XuiSendMessage (g, #GetFontNumber, @font, 0, 0, 0, k, 0)
	XuiSendMessage (g, #GetHelpString, 0, 0, 0, 0, k, @help$)
	XuiSendMessage (g, #GetHintString, 0, 0, 0, 0, k, @hint$)
	XuiSendMessage (g, #GetTextString, 0, 0, 0, 0, k, @text$)
	XuiSendMessage (g, #GetTextArray, 0, 0, 0, 0, k, @text$[])
END SUB
'
'
' *****  SetGridAttributes  *****  see "SUB GetGridAttributes"
'
SUB SetGridAttributes
	kid = g
	IF (k > 0) THEN
		XuiSendMessage (g, #GetKidArray, 0, 0, 0, 0, 0, @k[])
		IF k[] THEN
			upper = UBOUND(k[])
			IF (k > upper) THEN PRINT "Appearance() : SetGridAttributes : error : (k > upperKid)" : RETURN
			kid = k[k]
			IFZ kid THEN PRINT "Appearance() : SetGridAttributes : error : (kid grid number <= 0)" : RETURN
		END IF
	END IF
	XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, k, @gridName$)
	XuiSendMessage (g, #SetColor, back, draw, low, high, k, 0)
	XuiSendMessage (g, #SetColorExtra, dull, acc, lowtext, hightext, k, 0)
	XuiSendMessage (g, #SetBorder, border, borderUp, borderDown, borderFlags, k, 0)
	XuiSendMessage (g, #SetAlign, align, justify, -1, -1, k, 0)
	XuiSendMessage (g, #SetIndent, indentLeft, indentTop, indentRight, indentBottom, k, 0)
	XuiSendMessage (g, #SetTexture, texture, 0, 0, 0, k, 0)
	XuiSendMessage (g, #SetStyle, style, styleMax, 0, 0, k, 0)
	XuiSendMessage (g, #SetTimer, timer, 0, 0, 0, k, 0)
	XuiSendMessage (g, #SetImage, 0, 0, imageIndentX, imageIndentY, k, @image$)
	XuiSendMessage (g, #SetFontNumber, font, 0, 0, 0, k, 0)
	XuiSendMessage (g, #SetHelpString, 0, 0, 0, 0, k, help$)
	XuiSendMessage (g, #SetHintString, 0, 0, 0, 0, k, hint$)
	XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, k, text$)
	XuiSendMessage (g, #SetTextArray, 0, 0, 0, 0, k, @text$[])
	XuiSendMessage (g, #GetSize, @x, @y, @w, @h, k, 0)
	XuiSendMessage (g, #Resize, x, y, w, h, k, 0)
	XuiSendMessage (g, #GetWindow, @win, 0, 0, 0, k, 0)
	XgrConvertLocalToWindow (kid, x, y, @wx1, @wy1)
	XgrConvertLocalToWindow (kid, x+w-1, y+h-1, @wx2, @wy2)
	XgrConvertLocalToWindow (kid, 0, 0, @wx1, @wy1)
	XgrConvertLocalToWindow (kid, w-1, h-1, @wx2, @wy2)
	XgrRedrawWindow (win, $$TRUE, wx1, wy1, wx2-wx1+1, wy2-wy1+1)
'	XgrRedrawWindow (designWindow, $$TRUE, wx1, wy1, wx2-wx1+1, wy2-wy1+1)
	GOSUB UpdateKidsMenu
END SUB
'
'
' *****  SetStartingAttributes  *****
'
SUB SetStartingAttributes
	start = current														' starting gridInfo
	start$ = text$														' starting textString$
	startHelp$ = help$												' starting helpString$
	startHint$ = hint$												' starting hintString$
	startImage$ = image$											' starting imageString$
	startGridName$ = gridName$								' starting gridName$
	XstCopyArray (@text$[], @start$[])				' starting textArray$[]
END SUB
'
'
' *****  UpdateAppearanceWindow  *****  see "SUB GetGridAttributes"
'
SUB UpdateAppearanceWindow
	style$ = STRING$(style)
	styleMax$ = STRING(styleMax)
	test$ = XstBinStringToBackStringThese$ (@text$, @backslash_literal[])
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $LabelGridTypeText, gridType$)
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $LabelGridFuncText, gridFunc$ + "()")
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineGridName, gridName$)
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineHelpString, @help$)
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineHintString, @hint$)
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineTextString, @test$)
	XuiSendMessage (grid, #SetValue, indentLeft, 0, 0, 0, $RangeIndentLeft, 0)
	XuiSendMessage (grid, #SetValue, indentTop, 0, 0, 0, $RangeIndentTop, 0)
	XuiSendMessage (grid, #SetValue, indentRight, 0, 0, 0, $RangeIndentRight, 0)
	XuiSendMessage (grid, #SetValue, indentBottom, 0, 0, 0, $RangeIndentBottom, 0)
	XuiSendMessage (grid, #SetValue, style, styleMax, 0, 0, $RangeStyle, 0)
	XuiSendMessage (grid, #SetValue, timer, 0, 0, 0, $RangeTimer, 0)
	XuiSendMessage (grid, #SetColor, back,     -1, -1, -1, $AreaBackground, 0)
	XuiSendMessage (grid, #SetColor, draw,     -1, -1, -1, $AreaDrawing,    0)
	XuiSendMessage (grid, #SetColor, low,      -1, -1, -1, $AreaLowlight,   0)
	XuiSendMessage (grid, #SetColor, high,     -1, -1, -1, $AreaHighlight,  0)
	XuiSendMessage (grid, #SetColor, acc,      -1, -1, -1, $AreaAccent,     0)
	XuiSendMessage (grid, #SetColor, dull,     -1, -1, -1, $AreaDull,       0)
	XuiSendMessage (grid, #SetColor, lowtext,  -1, -1, -1, $AreaLowtext,    0)
	XuiSendMessage (grid, #SetColor, hightext, -1, -1, -1, $AreaHightext,   0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XstBinArrayToBackArray (@text$[], @tt$[])
	XuiSendMessage (appearanceTextGrid, #SetTextArray, 0, 0, 0, 0, 0, @tt$[])
	XuiSendMessage (appearanceTextGrid, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	g = values[grid,0]
	SELECT CASE r0
		CASE $Menu
					k = v1
					slot = $ButtonBackground
					GOSUB NewPlace
					GOSUB GetGridAttributes
					GOSUB SetStartingAttributes
					GOSUB UpdateAppearanceWindow
		CASE $Color
					color = v0
					slot = values[grid,3]
					SELECT CASE slot
						CASE $ButtonBackground: back			= color
						CASE $ButtonDrawing		: draw			= color
						CASE $ButtonLowlight	: low				= color
						CASE $ButtonHighlight	: high			= color
						CASE $ButtonDull			: dull			= color
						CASE $ButtonAccent		: acc				= color
						CASE $ButtonLowtext		: lowtext		= color
						CASE $ButtonHightext	: hightext	= color
					END SELECT
					GOSUB UpdateColor
		CASE $SolidColor
					color = v0
					slot = values[grid,3]
					SELECT CASE slot
						CASE $ButtonBackground: back			= color
						CASE $ButtonDrawing		: draw			= color
						CASE $ButtonLowlight	: low				= color
						CASE $ButtonHighlight	: high			= color
						CASE $ButtonDull			: dull			= color
						CASE $ButtonAccent		: acc				= color
						CASE $ButtonLowtext		: lowtext		= color
						CASE $ButtonHightext	: hightext	= color
					END SELECT
					GOSUB UpdateColor
		CASE $ButtonBackground				: slot	= r0									:	GOSUB NewPlace	' back
		CASE $ButtonDrawing						: slot	= r0									:	GOSUB NewPlace	' draw
		CASE $ButtonLowlight					: slot	= r0									:	GOSUB NewPlace	' low
		CASE $ButtonHighlight					: slot	= r0									:	GOSUB NewPlace	' high
		CASE $ButtonAccent						: slot	= r0									:	GOSUB NewPlace	' acc
		CASE $ButtonDull							: slot	= r0									:	GOSUB NewPlace	' dull
		CASE $ButtonLowtext						: slot	= r0									: GOSUB NewPlace	' lowtext
		CASE $ButtonHightext					: slot	= r0									: GOSUB NewPlace	' hightext
		CASE $AreaNone								: bs = $$BorderNone						: GOSUB SetBorder
		CASE $AreaFlat1								: bs = $$BorderFlat1					: GOSUB SetBorder
		CASE $AreaFlat2								: bs = $$BorderFlat2					: GOSUB SetBorder
		CASE $AreaFlat4								: bs = $$BorderFlat4					: GOSUB SetBorder
		CASE $AreaHiLine1							: bs = $$BorderHiLine1				: GOSUB SetBorder
		CASE $AreaHiLine2							: bs = $$BorderHiLine2				: GOSUB SetBorder
		CASE $AreaHiLine4							: bs = $$BorderHiLine4				: GOSUB SetBorder
		CASE $AreaRaise1							: bs = $$BorderRaise1					: GOSUB SetBorder
		CASE $AreaRaise2							: bs = $$BorderRaise2					: GOSUB SetBorder
		CASE $AreaRaise4							: bs = $$BorderRaise4					: GOSUB SetBorder
		CASE $AreaRidge								: bs = $$BorderRidge					: GOSUB SetBorder
		CASE $AreaValley							: bs = $$BorderValley					: GOSUB SetBorder
		CASE $AreaFrame								: bs = $$BorderFrame					:	GOSUB SetBorder
		CASE $AreaDrain								: bs = $$BorderDrain					: GOSUB SetBorder
		CASE $AreaLoLine1							: bs = $$BorderLoLine1				: GOSUB SetBorder
		CASE $AreaLoLine2							: bs = $$BorderLoLine2				: GOSUB SetBorder
		CASE $AreaLoLine4							: bs = $$BorderLoLine4				: GOSUB SetBorder
		CASE $AreaLower1							: bs = $$BorderLower1					: GOSUB SetBorder
		CASE $AreaLower2							: bs = $$BorderLower2					: GOSUB SetBorder
		CASE $AreaLower4							: bs = $$BorderLower4					: GOSUB SetBorder
		CASE $ButtonFlat							: texture = $$TextureNone			: GOSUB SetTexture
		CASE $ButtonLower							: texture = $$TextureLower1		: GOSUB SetTexture
		CASE $ButtonRaise							: texture = $$TextureRaise1		: GOSUB SetTexture
		CASE $ButtonShadow						: texture = $$TextureShadow		: GOSUB SetTexture
		CASE $ButtonJustifyLeft				: justify = $$JustifyLeft			: GOSUB UpdateDesign
		CASE $ButtonJustifyCenter			: justify = $$JustifyCenter		: GOSUB UpdateDesign
		CASE $ButtonJustifyRight			: justify = $$JustifyRight		: GOSUB UpdateDesign
		CASE $ButtonJustifyBoth				: justify = $$JustifyBoth			: GOSUB UpdateDesign
		CASE $ButtonAlignUpperLeft		: align = $$AlignUpperLeft		: GOSUB UpdateDesign
		CASE $ButtonAlignUpperCenter	: align = $$AlignUpperCenter	: GOSUB UpdateDesign
		CASE $ButtonAlignUpperRight		: align = $$AlignUpperRight		: GOSUB UpdateDesign
		CASE $ButtonAlignMiddleLeft		: align = $$AlignMiddleLeft		: GOSUB UpdateDesign
		CASE $ButtonAlignMiddleCenter	: align = $$AlignMiddleCenter	: GOSUB UpdateDesign
		CASE $ButtonAlignMiddleRight	: align = $$AlignMiddleRight	: GOSUB UpdateDesign
		CASE $ButtonAlignLowerLeft		: align = $$AlignLowerLeft		: GOSUB UpdateDesign
		CASE $ButtonAlignLowerCenter	: align = $$AlignLowerCenter	: GOSUB UpdateDesign
		CASE $ButtonAlignLowerRight		: align = $$AlignLowerRight		: GOSUB UpdateDesign
		CASE $RangeIndentLeft					: indentLeft = v0							: GOSUB UpdateDesign
		CASE $RangeIndentRight				: indentRight = v0						: GOSUB UpdateDesign
		CASE $RangeIndentTop					: indentTop = v0              : GOSUB UpdateDesign
		CASE $RangeIndentBottom				: indentBottom = v0						: GOSUB UpdateDesign
		CASE $RangeStyle							: style = v0									: GOSUB UpdateDesign
		CASE $RangeTimer							: old = timer
																		timer = v0
																		IFZ timer THEN
																			SELECT CASE old
																				CASE 1			: timer = 0
																				CASE 10			: timer = 9
																				CASE 100		: timer = 90
																				CASE 1000		: timer = 900
																				CASE 10000	: timer = 9000
																			END SELECT
																		END IF
																		SELECT CASE TRUE
																			CASE (timer < 10)					: XuiSendMessage (grid, #SetValues, timer, 1, 0, 10000, $RangeTimer, 0)
																			CASE (timer < 100)				: XuiSendMessage (grid, #SetValues, timer, 10, 0, 10000, $RangeTimer, 0)
																			CASE (timer < 1000)				: XuiSendMessage (grid, #SetValues, timer, 100, 0, 10000, $RangeTimer, 0)
																			CASE ELSE									: XuiSendMessage (grid, #SetValues, timer, 1000, 0, 10000, $RangeTimer, 0)
																		END SELECT
																		IF (old != timer) THEN
																			XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $RangeTimer, 0)
																			GOSUB UpdateDesign
																		END IF
		CASE $ButtonFont							: GOSUB Font
		CASE $ButtonImage							: GOSUB Image
		CASE $ButtonTextArray					: GOSUB TextArray
		CASE $TextLineTextString
					XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineTextString, @tt$)
					text$ = XstBackStringToBinString$ (@tt$)
					GOSUB UpdateDesign
		CASE $TextLineHelpString
					XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineHelpString, @help$)
					GOSUB UpdateDesign
		CASE $TextLineHintString
					XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineHintString, @help$)
					GOSUB UpdateDesign
		CASE $TextLineGridName
					XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineGridName, @name$)
					GOSUB UpdateDesign
		CASE $ButtonEnter							: GOSUB Enter
		CASE $ButtonRestore						: GOSUB Restore
		CASE $ButtonDefaults					: GOSUB Defaults
		CASE $ButtonCancel						: GOSUB Cancel
		CASE ELSE:	PRINT "Appearance() : Selection : error : (CASE ELSE): ", grid, "#Selection", v0, v1, v2, v3, r0, r1
	END SELECT
END SUB
'
'
' *****  SetBorder  *****
'
SUB SetBorder
	SELECT CASE v2{$$ButtonNumber}
		CASE $$LeftButtonNumber:		IFZ (v2 AND $$ShiftBit) THEN border = bs : borderUp = bs ELSE borderDown = bs
		CASE $$MiddleButtonNumber:	borderDown = bs
		CASE ELSE:									EXIT SUB
	END SELECT
	GOSUB SetGridAttributes
END SUB
'
'
' *****  SetTexture  *****
'
SUB SetTexture
	GOSUB SetGridAttributes
END SUB
'
'
' *****  Font  *****
'
SUB Font
	XuiGetReply (fontGrid, @"Select Font", "", "", @f, 0, 0, "")
	IF (f >= 0) THEN font = f : GOSUB UpdateDesign
END SUB
'
'
' *****  Image  *****
'
SUB Image
	XuiGetReply (fileGrid, @"Select Image", "", "", @i, 0, 0, @i$)
	IF (i < 0) THEN i$ = ""
	IF i$ THEN image$ = i$ : GOSUB UpdateDesign
END SUB
'
'
' *****  TextArray  *****
'
SUB TextArray
	IF appearanceTextState THEN
		XuiSendMessage (appearanceTextGrid, #GetTextArray, 0, 0, 0, 0, 0, @tt$[])
		XuiSendMessage (appearanceTextGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XstBackArrayToBinArray (@tt$[], @text$[])
		GOSUB SetGridAttributes
		appearanceTextState = $$FALSE
	ELSE
		GOSUB GetGridAttributes
		XstBinArrayToBackArray (@text$[], @tt$[])
		XuiSendMessage (appearanceTextGrid, #SetTextArray, 0, 0, 0, 0, 0, @tt$[])
		XuiSendMessage (appearanceGrid, #GetWindowSize, @ax1, @ay1, @awidth, @aheight, 0, 0)
		XuiSendMessage (appearanceTextGrid, #GetWindowSize, @tx1, @ty1, @twidth, @theight, 0, 0)
		tx1 = ax1 + awidth + #windowBorderWidth + #windowBorderWidth : ty1 = #displayHeight - theight - #windowBorderWidth
		XuiSendMessage (appearanceTextGrid, #ResizeWindow, tx1, ty1, twidth, theight, 0, 0)
		XuiSendMessage (appearanceTextGrid, #DisplayWindow, 0, 0, 0, 0, 0, 0)
		appearanceTextState = $$TRUE
	END IF
END SUB
'
'
' *****  Enter  *****
'
SUB Enter
	GOSUB SetGridAttributes
	GOSUB UpdateAppearanceWindow
END SUB
'
'
' *****  Restore  *****
'
SUB Restore
	current = start
	g = values[grid,0]
	text$					= start$
	help$					= startHelp$
	hint$					= startHint$
	gridName$			= startGridName$
	XstCopyArray (@start$[], @text$[])
	back					= current.backgroundColor
	draw					= current.drawingColor
	low						= current.lowlightColor
	high					= current.highlightColor
	dull					= current.dullColor
	acc						= current.accentColor
	lowtext				= current.lowtextColor
	hightext			= current.hightextColor
	border				= current.border
	borderUp			= current.borderUp
	borderDown		= current.borderDown
	align					= current.align
	justify				= current.justify
	indentLeft		= current.indentLeft
	indentTop			= current.indentTop
	indentRight		= current.indentRight
	indentBottom	= current.indentBottom
	texture				= current.texture
	style					= current.style
	styleMax			= current.styleMax
	timer					= current.timer
	font					= current.font
	GOSUB SetGridAttributes
	GOSUB UpdateAppearanceWindow
END SUB
'
'
' *****  Defaults  *****
'
SUB Defaults
	func = grid[g].gridFunc
	gridWindow = grid[g].window
	IFZ func THEN XgrGetGridFunction (grid, @func)
	IFZ gridWindow THEN XgrGetGridWindow (grid, @gridWindow)
	XuiSendMessage (  g, #GetSize, @xWin, @yWin, @width, @height, 0, 0)
	@func (@gg, #Create, xWin, yWin, width, height, gridWindow, 0)
	XuiSendMessage ( gg, #GetInfo, 0, 0, 0, 0, k, @current)
	XuiSendMessage ( gg, #GetTextString, 0, 0, 0, 0, k, @text$)
	XuiSendMessage ( gg, #Destroy, 0, 0, 0, 0, 0, 0)
	DIM text$[]
	help$					= startHelp$
	hint$					= startHint$
	gridName$			= startGridName$
	back					= current.backgroundColor
	draw					= current.drawingColor
	low						= current.lowlightColor
	high					= current.highlightColor
	dull					= current.dullColor
	acc						= current.accentColor
	lowtext				= current.lowtextColor
	hightext			= current.hightextColor
	border				= current.border
	borderUp			= current.borderUp
	borderDown		= current.borderDown
	align					= current.align
	justify				= current.justify
	indentLeft		= current.indentLeft
	indentTop			= current.indentTop
	indentRight		= current.indentRight
	indentBottom	= current.indentBottom
	texture				= current.texture
	style					= current.style
	styleMax			= current.styleMax
	timer					= current.timer
	font					= current.font
	GOSUB SetGridAttributes
	GOSUB UpdateAppearanceWindow
END SUB
'
'
' *****  Cancel  *****
'
SUB Cancel
	GOSUB HideWindow
END SUB
'
'
' *****  NewPlace  *****
'
SUB NewPlace
	new = slot
	old = values[grid,3]
	IF old THEN
		XuiSendMessage (grid, #SetColor, oldColor, -1, -1, -1, old, 0)
		XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, old, 0)
	END IF
	values[grid,3] = new
	IF new THEN
		XuiSendMessage (grid, #GetColor, @oldColor,  0,  0,  0, new, 0)
		XuiSendMessage (grid, #SetColor, thisColor, -1, -1, -1, new, 0)
		XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, new, 0)
	END IF
END SUB
'
'
' *****  Paint  *****
'
SUB Paint
	XuiSendMessage (paintGrid, #SetColor, color, -1, -1, -1, 0, 0)
	XuiSendMessage (paintGrid, #SetFocusColor, color, -1, -1, -1, 0, 0)
	XuiSendMessage (paintGrid, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Update  *****
'
SUB Update
	GOSUB UpdateDesign
	GOSUB UpdateAppearanceWindow
END SUB
'
'
' *****  UpdateColor  *****
'
SUB UpdateColor
	GOSUB SetGridAttributes
	GOSUB UpdatePalette
END SUB
'
'
' *****  UpdateDesign  *****
'
SUB UpdateDesign
	g = values[grid,0]
	XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineGridName,   @name$)
	XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineHelpString, @help$)
	XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineHintString, @hint$)
	XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, $TextLineTextString, @tt$)
	XuiSendMessage (appearanceTextGrid, #GetTextArray, 0, 0, 0, 0, 0, @tt$[])
	XuiSendMessage (appearanceTextGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
	XstBackArrayToBinArray (@tt$[], @text$[])
	text$ = XstBackStringToBinString$ (@tt$)
	GOSUB QualifyGridName
	GOSUB SetGridAttributes
END SUB
'
'
' *****  UpdatePalette  *****
'
SUB UpdatePalette
	XuiSendMessage (grid, #SetColor, back,     -1, -1, -1, $AreaBackground, 0)
	XuiSendMessage (grid, #SetColor, draw,     -1, -1, -1, $AreaDrawing,    0)
	XuiSendMessage (grid, #SetColor, low,      -1, -1, -1, $AreaLowlight,   0)
	XuiSendMessage (grid, #SetColor, high,     -1, -1, -1, $AreaHighlight,  0)
	XuiSendMessage (grid, #SetColor, acc,      -1, -1, -1, $AreaAccent,     0)
	XuiSendMessage (grid, #SetColor, dull,     -1, -1, -1, $AreaDull,       0)
	XuiSendMessage (grid, #SetColor, lowtext,  -1, -1, -1, $AreaLowtext,    0)
	XuiSendMessage (grid, #SetColor, hightext, -1, -1, -1, $AreaHightext,   0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaBackground, 0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaDrawing,    0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaLowlight,   0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaHighlight,  0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaAccent,     0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaDull,       0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaLowtext,    0)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $AreaHightext,   0)
END SUB
'
'
' *****  QualifyGridName  *****
'
SUB QualifyGridName
	IFZ name$ THEN name$ = gridName$
	DO WHILE (name$ != gridName$)
		found = FindGridName (designGrid, @name$)
		IF found THEN
			XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineGridName, @gridName$)
			XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $TextLineGridName, 0)
			XuiGetResponse (@"XuiDialog2B", @"Error Dialog", "Appearance() : SetGridName\nError: Duplicate GridName\n\nEnter Another Name", name$, 0, 0, @reply, @name$)
			IFZ name$ THEN name$ = gridName$
			IF (reply = 4) THEN EXIT SUB
		ELSE
			gridName$ = name$
		END IF
	LOOP WHILE found
	XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, $TextLineGridName, @gridName$)
	XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, $TextLineGridName, 0)
END SUB
'
' *****  Initialize  *****
'
SUB Initialize
	thisColor = $$LightGreen
	DIM helpStrings$[$UpperKid]
	helpStrings$[$Appearance]								= "pde.hlp:AppearanceWindow"
	helpStrings$[$Menu]											= "pde.hlp:AppearanceMenu"
	helpStrings$[$LabelGridType]						= "pde.hlp:AppearanceGridTypeLabel"
	helpStrings$[$LabelGridTypeText]				= "pde.hlp:AppearanceGridTypeText"
	helpStrings$[$LabelGridFunc]						= "pde.hlp:AppearanceGridFuncLabel"
	helpStrings$[$LabelGridFuncText]				= "pde.hlp:AppearanceGridFuncText"
	helpStrings$[$LabelGridName]						= "pde.hlp:AppearanceGridNameLabel"
	helpStrings$[$TextLineGridName]					= "pde.hlp:AppearanceGridNameText"
	helpStrings$[$LabelHintString]					= "pde.hlp:AppearanceHintStringLabel"
	helpStrings$[$TextLineHintString]				= "pde.hlp:AppearanceHintStringText"
	helpStrings$[$LabelHelpString]					= "pde.hlp:AppearanceHelpStringLabel"
	helpStrings$[$TextLineHelpString]				= "pde.hlp:AppearanceHelpStringText"
	helpStrings$[$ButtonBackground]					= "pde.hlp:AppearanceBackgroundColorButton"
	helpStrings$[$AreaBackground]						= "pde.hlp:AppearanceBackgroundColor"
	helpStrings$[$Color]										= "pde.hlp:AppearanceColorPalette"
	helpStrings$[$ButtonDrawing]						= "pde.hlp:AppearanceDrawingColorButton"
	helpStrings$[$AreaDrawing]							= "pde.hlp:AppearanceDrawingColor"
	helpStrings$[$ButtonLowlight]						= "pde.hlp:AppearanceLowlightColorButton"
	helpStrings$[$AreaLowlight]							= "pde.hlp:AppearanceLowlightColor"
	helpStrings$[$ButtonHighlight]					= "pde.hlp:AppearanceHightlightColorButton"
	helpStrings$[$AreaHighlight]						= "pde.hlp:AppearanceHighlightColor"
	helpStrings$[$ButtonDull]								= "pde.hlp:AppearanceDullColorButton"
	helpStrings$[$AreaDull]									= "pde.hlp:AppearanceDullColor"
	helpStrings$[$SolidColor]								= "pde.hlp:AppearanceSolidColor"
	helpStrings$[$AreaBorders]							= "pde.hlp:AppearanceBorders"
	helpStrings$[$AreaNone]									= "pde.hlp:AppearanceBorderNone"
	helpStrings$[$AreaFlat1]								= "pde.hlp:AppearanceBorderFlat1"
	helpStrings$[$AreaFlat2]								= "pde.hlp:AppearanceBorderFlat2"
	helpStrings$[$AreaFlat4]								= "pde.hlp:AppearanceBorderFlat4"
	helpStrings$[$AreaHiLine1]							= "pde.hlp:AppearanceBorderHiLine1"
	helpStrings$[$AreaHiLine2]							= "pde.hlp:AppearanceBorderHiLine2"
	helpStrings$[$AreaHiLine4]							= "pde.hlp:AppearanceBorderHiLine4"
	helpStrings$[$AreaRaise1]								= "pde.hlp:AppearanceBorderRaise1"
	helpStrings$[$AreaRaise2]								= "pde.hlp:AppearanceBorderRaise2"
	helpStrings$[$AreaRaise4]								= "pde.hlp:AppearanceBorderRaise4"
	helpStrings$[$ButtonAccent]							= "pde.hlp:AppearanceAccentColorButton"
	helpStrings$[$AreaAccent]								= "pde.hlp:AppearanceAccentColor"
	helpStrings$[$ButtonLowtext]						= "pde.hlp:AppearanceLowtextColorButton"
	helpStrings$[$AreaLowtext]							= "pde.hlp:AppearanceLowtextColor"
	helpStrings$[$AreaRidge]								= "pde.hlp:AppearanceBorderRidge"
	helpStrings$[$AreaValley]								= "pde.hlp:AppearanceBorderValley"
	helpStrings$[$AreaFrame]								= "pde.hlp:AppearanceBorderFrame"
	helpStrings$[$AreaDrain]								= "pde.hlp:AppearanceBorderDrain"
	helpStrings$[$AreaLoLine1]							= "pde.hlp:AppearanceBorderLoLine1"
	helpStrings$[$AreaLoLine2]							= "pde.hlp:AppearanceBorderLoLine2"
	helpStrings$[$AreaLoLine4]							= "pde.hlp:AppearanceBorderLoLine4"
	helpStrings$[$AreaLower1]								= "pde.hlp:AppearanceBorderLower1"
	helpStrings$[$AreaLower2]								= "pde.hlp:AppearanceBorderLower2"
	helpStrings$[$AreaLower4]								= "pde.hlp:AppearanceBorderLower4"
	helpStrings$[$ButtonHightext]						= "pde.hlp:AppearanceHightextColorButton"
	helpStrings$[$AreaHightext]							= "pde.hlp:AppearanceHightextColor"
	helpStrings$[$LabelTextString]					= "pde.hlp:AppearanceTextStringLabel"
	helpStrings$[$TextLineTextString]				= "pde.hlp:AppearanceTextStringText"
	helpStrings$[$LabelTextTexture]					= "pde.hlp:AppearanceTextTextureLabel"
	helpStrings$[$ButtonFlat]								= "pde.hlp:AppearanceFlatButton"
	helpStrings$[$ButtonLower]							= "pde.hlp:AppearanceLowerButton"
	helpStrings$[$ButtonRaise]							= "pde.hlp:AppearanceRaiseButton"
	helpStrings$[$ButtonShadow]							= "pde.hlp:AppearanceShadowButton"
	helpStrings$[$LabelJustify]							= "pde.hlp:AppearanceJustifyLabel"
	helpStrings$[$ButtonJustifyLeft]				= "pde.hlp:AppearanceJustifyLeftButton"
	helpStrings$[$ButtonJustifyCenter]			= "pde.hlp:AppearanceJustifyCenterButton"
	helpStrings$[$ButtonJustifyRight]				= "pde.hlp:AppearanceJustifyRightButton"
	helpStrings$[$ButtonJustifyBoth]				= "pde.hlp:AppearanceJustifyBothButton"
	helpStrings$[$ButtonAlignUpperLeft]			= "pde.hlp:AppearanceAlignUpperLeftButton"
	helpStrings$[$ButtonAlignUpperCenter]		= "pde.hlp:AppearanceAlignUpperCenterButton"
	helpStrings$[$ButtonAlignUpperRight]		= "pde.hlp:AppearanceAlignUpperRightButton"
	helpStrings$[$ButtonFont]								= "pde.hlp:AppearanceFontButton"
	helpStrings$[$LabelStyle]								= "pde.hlp:AppearanceStyleLabel"
	helpStrings$[$RangeStyle]								= "pde.hlp:AppearanceStyleRange"
	helpStrings$[$RangeIndentLeft]					= "pde.hlp:AppearanceIndentLeftRange"
	helpStrings$[$RangeIndentRight]					= "pde.hlp:AppearanceIndentRightRange"
	helpStrings$[$ButtonAlignMiddleLeft]		= "pde.hlp:AppearanceAlignMiddleLeftButton"
	helpStrings$[$ButtonAlignMiddleCenter]	= "pde.hlp:AppearanceAlignMiddleCenterButton"
	helpStrings$[$ButtonAlignMiddleRight]		= "pde.hlp:AppearanceAlignMiddleRightButton"
	helpStrings$[$ButtonTextArray]					= "pde.hlp:AppearanceTextArrayButton"
	helpStrings$[$LabelTimer]								= "pde.hlp:AppearanceTimerLabel"
	helpStrings$[$RangeTimer]								= "pde.hlp:AppearanceTimerRange"
	helpStrings$[$RangeIndentTop]						= "pde.hlp:AppearanceIndentTopRange"
	helpStrings$[$RangeIndentBottom]				= "pde.hlp:AppearanceIndentBottomRange"
	helpStrings$[$ButtonAlignLowerLeft]			= "pde.hlp:AppearanceAlignLowerLeftButton"
	helpStrings$[$ButtonAlignLowerCenter]		= "pde.hlp:AppearanceAlignLowerCenterButton"
	helpStrings$[$ButtonAlignLowerRight]		= "pde.hlp:AppearanceAlignLowerRightButton"
	helpStrings$[$ButtonImage]							= "pde.hlp:AppearanceImageButton"
	helpStrings$[$ButtonEnter]							= "pde.hlp:AppearanceEnterButton"
	helpStrings$[$ButtonRestore]						= "pde.hlp:AppearanceRestoreButton"
	helpStrings$[$ButtonDefaults]						= "pde.hlp:AppearanceDefaultsButton"
	helpStrings$[$ButtonCancel]							= "pde.hlp:AppearanceCancelButton"
	XuiSetHelpStrings (grid, #SetHelpStrings, -1, 0, 0, 0, 0, @helpStrings$[])
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiHelp ()  #####
' ########################
'
FUNCTION  XuiHelp (grid, message, v0, v1, v2, v3, r0, (r1, r1$))
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED  sysSetFile$
	SHARED	userSetFile$
	SHARED	helpfile$
	SHARED	helpText$[]
	SHARED	GRID	grid[]
	STATIC	SUBADDR  sub[]
	STATIC	helpStrings$[]
	STATIC	helpDisplayed
	STATIC	helpEnabled
	STATIC	helpWindow
	STATIC	helpGrid
	STATIC	downGrid
	STATIC	textGrid
	STATIC	posted
	STATIC	XuiHelp
	STATIC	file$,  entry$,  header,  first,  count
  STATIC	designX,  designY,  designWidth,  designHeight
'
	$XuiHelp	= 0
	$Label		= 1
	$Text			= 2
	$Button0	= 3
	$Button1	= 4
	$Button2	= 5
	$upperKid	= 5
'
	IFZ helpStrings$[] THEN GOSUB Initialize
	IF (grid < 0) THEN PRINT "XuiHelp() : error : (grid < 0)" : RETURN ($$TRUE)
	IF (message <= 0) THEN PRINT "XuiHelp() : error : (message <= 0)" : RETURN ($$TRUE)
	IF (grid > upperGrid) THEN PRINT "XuiHelp() : error : (grid > upperGrid)" : RETURN ($$TRUE)
	IF (message > upperMessage) THEN PRINT "XuiHelp() : error : (message > upperMessage)" : RETURN ($$TRUE)
	IF ((grid = 0) AND (message != #CreateWindow)) THEN grid = helpGrid
'
	whomask = ##WHOMASK
	##WHOMASK = 0
'
	SELECT CASE message
		CASE #Callback			:	GOSUB Callback
		CASE #Create				:	GOSUB Create
		CASE #CreateWindow	:	GOSUB CreateWindow
		CASE #Destroy				:	GOSUB Destroy
		CASE #Disable				:	GOSUB Disable
		CASE #Enable				:	GOSUB Enable
		CASE #DisplayWindow	:	GOSUB DisplayWindow
		CASE #GetHelpFile		:	GOSUB GetHelpFile
		CASE #Help					:	GOSUB Help
		CASE #HideWindow		:	GOSUB HideWindow
		CASE #MouseDown			:	GOSUB MouseDown
		CASE #MouseDrag			:	GOSUB MouseDrag
		CASE #MouseEnter		:	GOSUB MouseEnter
		CASE #MouseUp				:	GOSUB MouseUp
		CASE #Selection			:	GOSUB Selection
		CASE #SetHelp				:	GOSUB SetHelp
		CASE #SetHelpFile		:	GOSUB SetHelpFile
		CASE #ShowWindow		:	GOSUB ShowWindow
		CASE ELSE						:	XuiPassOn (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
	END SELECT
'
	##WHOMASK = whomask
	RETURN ($$FALSE)
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	SELECT CASE message
		CASE #Help				: GOSUB Help
		CASE #Selection		: GOSUB Selection
'		CASE #TextEvent		: GOSUB TextEvent
		CASE #CloseWindow	: GOSUB HideWindow
	END SELECT
END SUB
'
'
' *****  Create  *****
'
SUB Create
	IFZ helpGrid THEN
		IF (v0 <= 0) THEN v0 = 0
		IF (v1 <= 0) THEN v1 = 0
		IF (v2 <= 0) THEN v2 = designWidth
		IF (v3 <= 0) THEN v3 = designHeight
'		XuiCreateGrid (@grid, XuiHelp, 0, 0, 0, 0, r0, r1, &XuiHelp())
		XuiTextArea3B (@grid, #Create, @v0, @v1, @v2, @v3, r0, grid)
		XuiSendMessage (grid, #SetGridName, 0, 0, 0, 0, 0, @"Help")
		XuiSendMessage (grid, #SetCallback, grid, &XuiHelp(), -1, -1, -1, grid)
		XuiSendMessage (grid, #GetGridNumber, @g, 0, 0, 0, $Text, 0)
		XuiSendMessage (grid, #SetWindowTitle,  0, 0, 0, 0, 0, @" instant help ")
		XuiSendMessage (grid, #SetHelpStrings, -1, 0, 0, 0, 0, @helpStrings$[])
		XuiSendMessage (grid, #GetWindow, @helpWindow, 0, 0, 0, 0, 0)
		XuiMonitorHelp (grid, #MonitorHelp, grid, &XuiHelp(), 0, 0, 0, $$TRUE)
		XuiSendMessage (g, #SetHelpString,  -1, 0, 0, 0, 0, @"pde.hlp:HelpText")
		XuiSendMessage (g, #SetHelpString,   0, 0, 0, 0, 1, @"pde.hlp:HelpText")
		XuiSendMessage (g, #SetHelpString,   0, 0, 0, 0, 2, @"pde.hlp:HelpScrollBarH")
		XuiSendMessage (g, #SetHelpString,   0, 0, 0, 0, 3, @"pde.hlp:HelpScrollBarV")
		XxxXgrSetHelpWindow (helpWindow)
		helpEnabled = $$TRUE
		textGrid = $$FALSE
		downGrid = $$FALSE
		posted = $$FALSE
		helpGrid = grid
	END IF
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, helpGrid, -1, v2, v3, @r0, @"Help")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	IF helpGrid THEN
'		PRINT "XuiHelp() : Destroy"
		XuiSendMessage (helpGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiMonitorHelp (grid, #MonitorHelp, helpGrid, &XuiHelp(), 0, 0, 0, $$FALSE)
		helpDisplayed = $$FALSE
		helpEnabled = $$FALSE
		helpWindow = 0
		helpGrid = 0
		textGrid = 0
		posted = 0
	END IF
END SUB
'
'
' *****  Disable  *****
'
SUB Disable
	IF helpGrid THEN
'		PRINT "XuiHelp() : Disable"
		XuiMonitorHelp (grid, #MonitorHelp, helpGrid, &XuiHelp(), 0, 0, 0, $$FALSE)
		XuiSendMessage (helpGrid, #Disable, 0, 0, 0, 0, 0, 0)
		helpDisplayed = $$FALSE
		helpEnabled = $$FALSE
		textGrid = 0
		posted = 0
	END IF
END SUB
'
'
' *****  Enable  *****
'
SUB Enable
	IF helpGrid THEN
'		PRINT "XuiHelp() : Enable"
		XuiMonitorHelp (grid, #MonitorHelp, helpGrid, &XuiHelp(), 0, 0, 0, $$TRUE)
		XuiSendMessage (helpGrid, #Enable, 0, 0, 0, 0, 0, 0)
		helpEnabled = $$TRUE
	END IF
END SUB
'
'
' *****  DisplayWindow  *****
'
SUB DisplayWindow
	IF helpGrid THEN
		IF helpEnabled THEN
'			PRINT "XuiHelp() : DisplayWindow"
			XuiSendMessage (helpGrid, #DisplayWindow, 0, 0, 0, 0, 0, 0)
			XuiSendMessage (helpGrid, #SetTextString, 0, 0, 0, 0, $Button0, @" post ")
			XuiSendMessage (helpGrid, #Redraw, 0, 0, 0, 0, 0, 0)
			helpDisplayed = $$TRUE
			posted = $$FALSE
		END IF
	END IF
END SUB
'
'
' *****  ShowWindow  *****
'
SUB ShowWindow
	IF helpGrid THEN
		IF helpEnabled THEN
'			PRINT "XuiHelp() : ShowWindow"
			XuiSendMessage (helpGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
			XuiSendMessage (helpGrid, #SetTextString, 0, 0, 0, 0, $Button0, @" post ")
			XuiSendMessage (helpGrid, #Redraw, 0, 0, 0, 0, 0, 0)
			XuiSendMessage (helpGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
			helpDisplayed = $$TRUE
			posted = $$FALSE
		END IF
	END IF
END SUB
'
'
' *****  HideWindow  *****
'
SUB HideWindow
	IFZ posted THEN
		IF helpGrid THEN
			IF helpEnabled THEN
'				PRINT "XuiHelp() : HideWindow"
				XuiSendMessage (helpGrid, #SetTextString, 0, 0, 0, 0, $Button0, @" post ")
				XuiSendMessage (helpGrid, #SetTextArray, 0, 0, 0, 0, $Text, @empty$[])
				XuiSendMessage (helpGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
				helpDisplayed = $$FALSE
				textGrid = 0
				downGrid = 0
				DIM empty$[]
			END IF
		END IF
	END IF
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : MouseDown"
	IFZ (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} != $$HelpButtonNumber) THEN EXIT SUB
	IF (v2 AND $$ControlBit) THEN EXIT SUB
	IF (v2 AND $$ShiftBit) THEN EXIT SUB
	IF (r1 > upperGrid) THEN EXIT SUB
	IF (r1 <= 0) THEN EXIT SUB
	r0 = -1
	GOSUB DisplayEntry
	downGrid = r1
	r0 = -1
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : MouseDrag"
	IFZ (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (r1 > upperGrid) THEN EXIT SUB
	IF (r1 <= 0) THEN EXIT SUB
	r0 = -1
	IF (r1 = textGrid) THEN EXIT SUB
	IF (r1 != downGrid) THEN downGrid = 0
	IF helpDisplayed THEN EXIT SUB
	GOSUB DisplayEntry
	r0 = -1
END SUB
'
'
' *****  MouseEnter  *****
'
SUB MouseEnter
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : MouseEnter"
	IFZ (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (r1 > upperGrid) THEN EXIT SUB
	IF (r1 <= 0) THEN EXIT SUB
	r0 = -1
	GOSUB DisplayEntry
	downGrid = 0
	r0 = -1
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
	IFZ helpDisplayed THEN EXIT SUB
'	PRINT "XuiHelp() : MouseUp"
	IF (v2{$$ButtonNumber} != $$HelpButtonNumber) THEN EXIT SUB
	IF (r1 > upperGrid) THEN EXIT SUB
	IF (r1 <= 0) THEN EXIT SUB
	r0 = -1
	IF (r1 != downGrid) THEN GOSUB HideWindow
	r0 = -1
END SUB
'
'
' *****  Help  *****  Testing mouse x,y generated Help
'
SUB Help
	EXIT SUB
	IF (r0 != $Text) THEN EXIT SUB
	XuiSendMessage (grid, #GetTextPosition, v0, v1, @char, @line, r0, @out)
	XuiSendMessage (grid, #GetTextArrayLine, line, 0, 0, 0, r0, @line$)
	PRINT line$
	PRINT SPACE$ (char); "*"
	r1 = 0
	r0 = -1
	r1$ = "[Your Mother Eats Peanuts]\nHer fate is to live\nwith Jimmy Carter."
	GOSUB SetHelp
END SUB
'
'
' *****  GetHelpFile  *****
'
SUB GetHelpFile
'	PRINT "XuiHelp() : GetHelpFile"
	r1$ = helpfile$
END SUB
'
'
' *****  SetHelpFile  *****
'
SUB SetHelpFile
'	PRINT "XuiHelp() : SetHelpFile"
'
	IFZ r1$ THEN						' free help text (blowback)
		file$ = ""
		entry$ = ""
		helpFile$ = ""
		sysSetFile$ = ""
		userSetFile$ = ""
		DIM helpText$[]
		EXIT SUB
	END IF
'
	##ERROR = $$FALSE
	h$ = r1$
	IF h$ THEN
		##ERROR = $$FALSE
		helpfile = OPEN (h$, $$RD)
		IF (helpfile <= 0) THEN helpfile = 0 : h$ = ""
		IF ##ERROR THEN h$ = ""
		helpfile$ = h$
	END IF
'
	IF (helpfile > 0) THEN
		helpSize = LOF(helpfile)
		helpText$ = NULL$(helpSize)
		READ [helpfile], helpText$
		XstStringToStringArray (@helpText$, @helpText$[])
		IF whomask THEN userSetFile$ = helpfile$ ELSE sysSetFile$ = helpfile$
		CLOSE (helpfile)
		helpText$ = ""
		helpfile = 0
	END IF
END SUB
'
'
' *****  DisplayEntry  *****
'
SUB DisplayEntry
	cancel = 0
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : DisplayEntry"
	IF (r1 <= 0) THEN EXIT SUB
	IF (r1 > upperGrid) THEN EXIT SUB
	IF (r1 = textGrid) THEN
		XuiSendMessage (helpGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (helpGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
		EXIT SUB
	END IF
	XuiSendMessage (r1, #GetHelp, v0, v1, 0, 0, @cancel, @help$)
	IF (cancel < 0) THEN EXIT SUB
	GetHelpEntry (r1, @help$, @file$, @entry$, @header, @first, @count, @text$[])
	IFZ file$ THEN
		IFZ text$[] THEN GOSUB HideWindow : EXIT SUB
	END IF
	IFZ entry$ THEN GOSUB HideWindow : EXIT SUB
	GOSUB DisplayHelp
	textGrid = r1
END SUB
'
'
' *****  SetHelp  *****		Display this help string for me, HelpWindow.
'
SUB SetHelp
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : SetHelp"
	help$ = r1$
	GetHelpEntry (0, @help$, @file$, @entry$, @header, @first, @count, @text$[])
	IFZ file$ THEN
		IFZ text$[] THEN GOSUB HideWindow : EXIT SUB
	END IF
	IFZ entry$ THEN GOSUB HideWindow : EXIT SUB
	GOSUB DisplayHelp
	textGrid = 0
END SUB
'
'
' *****  DisplayHelp  *****
'
SUB DisplayHelp
	IFZ helpGrid THEN EXIT SUB
	IFZ helpEnabled THEN EXIT SUB
'	PRINT "XuiHelp() : DisplayHelp"
	label$ = file$ + entry$
	showMessage = #ShowWindow
'	XgrGetSelectedWindow (@selectedWindow)
'	XgrGetWindowState (@helpWindow, @state)
'	IF ((state != $$WindowDisplayed) AND (state != $$WindowMaximized)) THEN showMessage = #DisplayWindow
	XuiSendMessage (helpGrid, showMessage, 0, 0, 0, 0, 0, 0)
	XuiSendMessage (helpGrid, #SetTextString, 0, 0, 0, 0, $Label, @label$)
	XuiSendMessage (helpGrid, #SetTextArray, 0, 0, 0, 0, $Text, @text$[])
	XuiSendMessage (helpGrid, #Redraw, 0, 0, 0, 0, $Label, 0)
	XuiSendMessage (helpGrid, #RedrawText, 0, 0, 0, 0, $Text, 0)
	XuiSendMessage (helpGrid, showMessage, 0, 0, 0, 0, 0, 0)
'	IF (selectedWindow AND (showMessage = #DisplayWindow)) THEN XgrSetSelectedWindow (selectedWindow)
	helpDisplayed = $$TRUE
	posted = $$FALSE
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
'	PRINT "XuiHelp() : Selection"
	SELECT CASE r0
		CASE $Button0:	GOSUB Post
		CASE $Button1:	GOSUB UpdateHelpText
		CASE $Button2:	GOSUB HideWindow
	END SELECT
END SUB
'
'
' *****  Post  *****
'
SUB Post
'	PRINT "XuiHelp() : Post"
	IF posted THEN
		posted = $$FALSE
		GOSUB HideWindow
	ELSE
		posted = $$TRUE
		XuiSendMessage (helpGrid, #SetTextString, 0, 0, 0, 0, $Button0, @" hide ")
		XuiSendMessage (helpGrid, #Redraw, 0, 0, 0, 0, $Button0, 0)
	END IF
END SUB
'
'
' *****  UpdateHelpText  *****
'
SUB UpdateHelpText
'	PRINT "XuiHelp() : UpdateHelpText"
	IFZ entry$ THEN EXIT SUB
	IF (entry${0} != ':') THEN EXIT SUB
	IF (file$ != helpfile$) THEN EXIT SUB
	XuiSendMessage (helpGrid, #GetTextArray, 0, 0, 0, 0, $Text, @text$[])
	TrimStringArrayUpper (@text$[])
	IF (header < 0) THEN
		DIM entry$[0]
		entry$[0] = entry$
		XstReplaceLines (@helpText$[], @entry$[], first, 0, 0, 1)
		header = first
		INC first
	END IF
	newCount = UBOUND (text$[]) + 1
	XstReplaceLines (@helpText$[], @text$[], first, count, 0, newCount)
	XstStringArrayToString (@helpText$[], @helptext$)
	IFZ helpfile$ THEN PRINT "XuiHelp() : UpdateHelpText : error : (helpfile$ is empty)" : EXIT SUB
	IFZ helptext$ THEN PRINT "XuiHelp() : UpdateHelpText : error : (helptext$ is empty)" : EXIT SUB
'
	count = newCount
	##ERROR = $$FALSE
	dot = RINSTR(helpfile$, ".")
	IF dot THEN
		backfile$ = LEFT$(helpfile$, dot-1) + ".hhh"
	ELSE
		backfile$ = helpfile$ + ".hhh"
	END IF
'
	##ERROR = $$FALSE
	backfile = OPEN (backfile$, $$RD)
	IF (backfile <= 0) THEN
		XstRenameFile (helpfile$, backfile$)
	ELSE
		CLOSE (backfile)
	END IF
'
	##ERROR = $$FALSE
	helpfile = OPEN (helpfile$, $$WRNEW)
	IF (helpfile <= 0) THEN
		IF whomask THEN helpfile$ = userSetFile$ ELSE helpfile$ = sysSetFile$
		helptext$ = ""
		EXIT SUB
	END IF
'
	IF ##ERROR THEN
		IF (helpfile > 0) THEN CLOSE (helpfile)
		IF whomask THEN helpfile$ = userSetFile$ ELSE helpfile$ = sysSetFile$
		helptext$ = ""
		EXIT SUB
	END IF
'
	WRITE [helpfile], helptext$
	CLOSE (helpfile)
	helpfile = 0
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	designX = 128
	designY =  23
	designWidth = 512
	designHeight = 256
'
	DIM helpStrings$[$upperKid]
	helpStrings$[$XuiHelp] = "pde.hlp:HelpWindow"
	helpStrings$[$Label] = "pde.hlp:HelpLabel"
	helpStrings$[$Text] = "pde.hlp:HelpText"
	helpStrings$[$Button0] = "pde.hlp:HelpPostHide"
	helpStrings$[$Button1] = "pde.hlp:HelpUpdate"
	helpStrings$[$Button2] = "pde.hlp:HelpCancel"
	XuiRegisterGridType (@XuiHelp, @"XuiHelp", &XuiHelp(), @func[], @sub[])
END SUB
END FUNCTION
'
'
' #######################
' #####  Report ()  #####
' #######################
'
FUNCTION  Report (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC  designX,  designY,  designWidth,  designHeight
  STATIC  SUBADDR  sub[]
  STATIC  upperMessage
  STATIC  Report
'
  $Report         =  0  ' kid  0 grid type = Report
  $gridLabel      =  1  ' kid  1 grid type = XuiLabel
  $gridNumber     =  2  ' kid  2 grid type = XuiLabel
  $gridTypeName   =  3  ' kid  3 grid type = XuiLabel
  $messageLabel   =  4  ' kid  4 grid type = XuiLabel
  $messageNumber  =  5  ' kid  5 grid type = XuiLabel
  $messageName    =  6  ' kid  6 grid type = XuiLabel
  $v0Label        =  7  ' kid  7 grid type = XuiLabel
  $v0Number       =  8  ' kid  8 grid type = XuiLabel
  $v0Hex          =  9  ' kid  9 grid type = XuiLabel
  $v1Label        = 10  ' kid 10 grid type = XuiLabel
  $v1Number       = 11  ' kid 11 grid type = XuiLabel
  $v1Hex          = 12  ' kid 12 grid type = XuiLabel
  $v2Label        = 13  ' kid 13 grid type = XuiLabel
  $v2Number       = 14  ' kid 14 grid type = XuiLabel
  $v2Hex          = 15  ' kid 15 grid type = XuiLabel
  $v3Label        = 16  ' kid 16 grid type = XuiLabel
  $v3Number       = 17  ' kid 17 grid type = XuiLabel
  $v3Hex          = 18  ' kid 18 grid type = XuiLabel
  $r0Label        = 19  ' kid 19 grid type = XuiLabel
  $r0Number       = 20  ' kid 20 grid type = XuiLabel
  $r0Hex          = 21  ' kid 21 grid type = XuiLabel
  $r1Label        = 22  ' kid 22 grid type = XuiLabel
  $r1Number       = 23  ' kid 23 grid type = XuiLabel
  $r1Info         = 24  ' kid 24 grid type = XuiLabel
  $ReportCancel   = 25  ' kid 25 grid type = XuiPushButton
  $UpperKid       = 25  ' kid maximum
'
'
  IFZ sub[] THEN GOSUB Initialize
  IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, Report) THEN RETURN
  IF (message <= upperMessage) THEN GOSUB @sub[message]
  RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
  IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
  IF (v0 <= 0) THEN v0 = 0
  IF (v1 <= 0) THEN v1 = 0
  IF (v2 <= 0) THEN v2 = designWidth
  IF (v3 <= 0) THEN v3 = designHeight
  XuiCreateGrid (@grid, Report, @v0, @v1, @v2, @v3, r0, r1, &Report())
  XuiSendMessage (grid, #SetGridName, 0, 0, 0, 0, 0, @"Report")
  XuiLabel      (@g, #Create, 4, 4, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"gridLabel")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"wingrid")
  XuiLabel      (@g, #Create, 68, 4, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"gridNumber")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 4, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"gridTypeName")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 28, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"messageLabel")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"message")
  XuiLabel      (@g, #Create, 68, 28, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"messageNumber")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 28, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"messageName")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 52, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v0Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"v0")
  XuiLabel      (@g, #Create, 68, 52, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v0Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 52, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v0Hex")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 76, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v1Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"v1")
  XuiLabel      (@g, #Create, 68, 76, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v1Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 76, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v1Hex")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 100, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v2Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"v2")
  XuiLabel      (@g, #Create, 68, 100, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v2Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 100, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v2Hex")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 124, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v3Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"v3")
  XuiLabel      (@g, #Create, 68, 124, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v3Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 124, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"v3Hex")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 148, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r0Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"kid/r0")
  XuiLabel      (@g, #Create, 68, 148, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r0Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 148, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r0Hex")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 4, 172, 64, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r1Label")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"ANY r1")
  XuiLabel      (@g, #Create, 68, 172, 96, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r1Number")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleRight, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiLabel      (@g, #Create, 164, 172, 192, 24, r0, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"r1Info")
  XuiSendMessage (g, #SetAlign, $$AlignMiddleLeft, $$JustifyCenter, -1, -1, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureNone, 0, 0, 0, 0, 0)
  XuiPushButton (@g, #Create, 4, 196, 352, 24, r0, grid)
  XuiSendMessage (g, #SetCallback, grid, &Report(), -1, -1, $ReportCancel, grid)
  XuiSendMessage (g, #SetGridName, 0, 0, 0, 0, 0, @"ReportCancel")
  XuiSendMessage (g, #SetColor, $$BrightRed, $$Black, $$Black, $$White, 0, 0)
  XuiSendMessage (g, #SetTexture, $$TextureShadow, 0, 0, 0, 0, 0)
  XuiSendMessage (g, #SetTextString, 0, 0, 0, 0, 0, @"cancel")
  GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
  IF (v0  = 0) THEN v0 = designX
  IF (v1  = 0) THEN v1 = designY
  IF (v2 <= 0) THEN v2 = designWidth
  IF (v3 <= 0) THEN v3 = designHeight
  XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
  v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
  GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"Report")
END SUB
'
'
' *****  GetSmallestSize  *****  See "Anatomy of Grid Functions"
'
SUB GetSmallestSize
END SUB
'
'
' *****  Resize  *****  See "Anatomy of Grid Functions"
'
SUB Resize
END SUB
'
'
' *****  Selection  *****  See "Anatomy of Grid Functions"
'
SUB Selection
  SELECT CASE r0
    CASE $Report         :
    CASE $gridLabel      :
    CASE $gridNumber     :
    CASE $gridTypeName   :
    CASE $messageLabel   :
    CASE $messageNumber  :
    CASE $messageName    :
    CASE $v0Label        :
    CASE $v0Number       :
    CASE $v0Hex          :
    CASE $v1Label        :
    CASE $v1Number       :
    CASE $v1Hex          :
    CASE $v2Label        :
    CASE $v2Number       :
    CASE $v2Hex          :
    CASE $v3Label        :
    CASE $v3Number       :
    CASE $v3Hex          :
    CASE $r0Label        :
    CASE $r0Number       :
    CASE $r0Hex          :
    CASE $r1Label        :
    CASE $r1Number       :
    CASE $r1Info         :
    CASE $ReportCancel   : XuiHideWindow (grid, #HideWindow, 0, 0, 0, 0, 0, 0)
  END SELECT
END SUB
'
'
' *****  Initialize  *****  ' see "Anatomy of Grid Functions"
'
SUB Initialize
  XuiGetDefaultMessageFuncArray (@func[])
  XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
' func[#Callback]           = &XuiCallback ()               ' disable to handle Callback messages internally
' func[#GetSmallestSize]    = 0                             ' enable to add internal GetSmallestSize routine
' func[#Resize]             = 0                             ' enable to add internal Resize routine
'
  DIM sub[upperMessage]
  sub[#Callback]            = SUBADDRESS (Callback)         ' enable to handle Callback messages internally
  sub[#Create]              = SUBADDRESS (Create)           ' must be internal routine
  sub[#CreateWindow]        = SUBADDRESS (CreateWindow)     ' must be internal routine
' sub[#GetSmallestSize]     = SUBADDRESS (GetSmallestSize)  ' enable to add internal GetSmallestSize routine
' sub[#Resize]              = SUBADDRESS (Resize)           ' enable to add internal Resize routine
  sub[#Selection]           = SUBADDRESS (Selection)        ' routes Selection callbacks to subroutine
'
  IF sub[0] THEN PRINT "Report() : Initialize : error ::: (undefined message)"
  IF func[0] THEN PRINT "Report() : Initialize : error ::: (undefined message)"
  XuiRegisterGridType (@Report, "Report", &Report(), @func[], @sub[])
'
' Don't remove the following 4 lines, or WindowFromFunction/WindowToFunction will not work
'
  designX = 4
  designY = 23
  designWidth = 360
  designHeight = 224
'
  gridType = Report
  XuiSetGridTypeProperty (gridType, @"x",                designX)
  XuiSetGridTypeProperty (gridType, @"y",                designY)
  XuiSetGridTypeProperty (gridType, @"width",            designWidth)
  XuiSetGridTypeProperty (gridType, @"height",           designHeight)
  XuiSetGridTypeProperty (gridType, @"maxWidth",         designWidth)
  XuiSetGridTypeProperty (gridType, @"maxHeight",        designHeight)
  XuiSetGridTypeProperty (gridType, @"minWidth",         designWidth)
  XuiSetGridTypeProperty (gridType, @"minHeight",        designHeight)
  XuiSetGridTypeProperty (gridType, @"border",           $$BorderFrame)
  XuiSetGridTypeProperty (gridType, @"can",              $$Focus OR $$Respond OR $$Callback)
  XuiSetGridTypeProperty (gridType, @"focusKid",         $ReportCancel)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiHint ()  #####
' ########################
'
FUNCTION  XuiHint (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiHint
	STATIC	display
	STATIC	timout
	STATIC	hint
	STATIC	xDisp
	STATIC	yDisp
	SHARED  hintGrid
	SHARED  gridMouseMessage
'
'	XgrMessageNumberToName (message, @message$)
'	PRINT "XuiHint().a : "; ##WHOMASK, grid, r1, message$
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiHint) THEN RETURN
	GOSUB @sub[message]
'	PRINT "XuiHint().z : "; ##WHOMASK, grid, r1, message$
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	grid = hintGrid
	IF hintGrid THEN EXIT SUB
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiHint, @v0, @v1, @v2, @v3, r0, r1, &XuiHint())
	GOSUB Configure
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	grid = hintGrid
	IF hintGrid THEN EXIT SUB
	IF (v0 == 0) THEN v0 = designX
	IF (v1 == 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiHint")
END SUB
'
'
' *****  Configure  *****
'
SUB Configure
	hintFont = 0
	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Hint")
	XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @"Hint")
	XuiSendMessage ( grid, #SetTexture, $$TextureFlat, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #SetColor, $$BrightYellow, $$Black, -1, -1, 0, 0)
	XuiSendMessage ( grid, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderLower1, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"Comic Sans MS")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"MS Sans Serif")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"Arial")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"utopia")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"helvetica")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	IFZ hintFont THEN XuiSendMessage ( grid, #SetFont, 240, 400, 0, 0, 0, @"helv")
	IFZ hintFont THEN XuiSendMessage ( grid, #GetFontNumber, @hintFont, 0, 0, 0, 0, 0)
	hintGrid = grid
END SUB
'
'
' *****  Mouse  *****
'
SUB Mouse
'	GOSUB HideHint
	IF (message != #MouseMove) THEN GOSUB HideHint
	IF (message == #MouseMove) THEN GOSUB StartWait
	IF (message == #MouseEnter) THEN GOSUB StartWait
END SUB
'
'
' *****  StartWait  *****
'
SUB StartWait
	hint = r1
	IFZ hint THEN EXIT SUB
	XgrConvertLocalToDisplay (hint, v0, v1, @xDisp, @yDisp)
'
	whomask = ##WHOMASK
	##WHOMASK = $$FALSE
	XgrSetGridTimer (grid, 800)
	##WHOMASK = whomask
END SUB
'
'
' *****  DisplayHint  *****
'
SUB DisplayHint
	IF display THEN EXIT SUB
	IF (hint <= 0) THEN EXIT SUB
	XuiSendMessage (hint, #GetHintString, 0, 0, 0, 0, 0, @hint$)
	hint$ = TRIM$(hint$)
	GOSUB SetTextString
	IFZ hint$ THEN EXIT SUB
	XgrGetMouseInfo (window, @g, @x, @y, @state, @timer)
	XgrConvertLocalToDisplay (hint, 0, 0, @xDisp, @yDisp)
	XuiSendMessage (grid, #GetSmallestSize, 0, 0, @w, @h, 0, 0)
	XuiSendMessage (grid, #Resize, 0, 0, w+2, h+2, 0, 0)
	IF (g == hint) THEN
		XgrConvertLocalToDisplay (g, x, y, @xx, @yy)
		IF ((yy-h-4) < 0) THEN xx = xx + 12 : yy = yy + 24 ELSE yy = yy - h - 4
		IF ((xx+w+2) > #displayWidth) THEN xx = #displayWidth - w - 2
'		XuiSendMessage (grid, #ResizeWindow, xDisp, yDisp-h-2, w+2, h+2, 0, 0)
		XuiSendMessage (grid, #ResizeWindow, xx, yy, w+2, h+2, 0, 0)
		XuiSendMessage (grid, #ShowWindow, 0, 0, 0, 0, 0, 0)
		display = $$TRUE
	END IF
'
	whomask = ##WHOMASK
	##WHOMASK = $$FALSE
	XgrSetGridTimer (grid, 4096)
	##WHOMASK = whomask
END SUB
'
'
' *****  HideHint  *****
'
SUB HideHint
	IF display THEN XuiSendMessage (grid, #HideWindow, 0, 0, 0, 0, 0, 0)
	IF hint THEN XgrSetGridTimer (grid, 0)
	display = $$FALSE
	timeout = $$FALSE
	hint = 0
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	whomask = ##WHOMASK
	##WHOMASK = $$FALSE
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @hint$)
	##WHOMASK = whomask
END SUB
'
'
' *****  TimeOut  *****
'
SUB TimeOut
	hide = $$FALSE
	XgrGetGridWindow (hint, @w)
	XgrGetMouseInfo (w, @g, @x, @y, @s, @t)
	XgrConvertLocalToDisplay (hint, x, y, @xxxx, @yyyy)
	IF (xxxx != xDisp) THEN hide = $$TRUE
	IF (yyyy != yDisp) THEN hide = $$TRUE
'
	IFZ display THEN
		IFZ timeout THEN
			IFZ hide THEN GOSUB DisplayHint
		END IF
	ELSE
		timeout = $$TRUE
		GOSUB HideHint
	END IF
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#MouseDown]          = 0
	func[#MouseDrag]          = 0
	func[#MouseEnter]         = 0
	func[#MouseExit]          = 0
	func[#MouseMove]          = 0
	func[#MouseUp]            = 0
	func[#SetTextArray]       = 0
	func[#SetTextString]      = 0
	func[#SetHintString]      = 0
	func[#SetValuesArray]     = 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (Mouse)
	sub[#MouseDrag]						= SUBADDRESS (Mouse)
	sub[#MouseEnter]					= SUBADDRESS (Mouse)
	sub[#MouseExit]						= SUBADDRESS (Mouse)
	sub[#MouseMove]						= SUBADDRESS (Mouse)
	sub[#MouseUp]							= SUBADDRESS (Mouse)
	sub[#TimeOut]							= SUBADDRESS (TimeOut)
'
	IF func[0] THEN PRINT "XuiHint() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiHint() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiHint, @"XuiHint", &XuiHint(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiHint
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",          8)
	XuiSetGridTypeProperty (gridType, @"minHeight",         8)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleCenter)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderUp",        $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderDown",      $$BorderLower1)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureFlat)
	XuiSetGridTypeProperty (gridType, @"can",             $$FALSE)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #############################
' #####  XxxXuiReport ()  #####
' #############################
'
FUNCTION  XxxXuiReport (state)
	SHARED	report
'
	old = report
	report = state
	RETURN (old)
END FUNCTION
'
'
' ###############################
' #####  XxxXuiBlowback ()  #####
' ###############################
'
FUNCTION  XxxXuiBlowback ()
	SHARED	helpGrid									'
	SHARED	modalUser									'
	SHARED	modalUserGrid							'
	SHARED	modalUserResponse					'
	SHARED  userTextFilename$					'
	SHARED  keyboardFocusGrid					'
	SHARED	upperGrid									' highest grid number
	SHARED	upperWindow								' highest window number
	SHARED	upperGridType							' highest grid type number
	SHARED	messageSub[]							' gridType
	SHARED	gridTypeMessageFunc[]			' gridType
	SHARED	GRID  gridType[]					' gridType
'	SHARED	gridTypeImage$[]					' gridType
	SHARED	gridTypeName$[]						' gridType
	SHARED	gridTypeFunc$[]						' gridType
	SHARED	help$[]										' grid
	SHARED	hint$[]										' grid
	SHARED	image$[]									' grid
	SHARED	kids[]										' grid
	SHARED	array[]										' grid
	SHARED	values[]									' grid
	SHARED	tabArray[]								' grid
	SHARED	gridName$[]								' grid
	SHARED	gridType$[]								' grid
	SHARED	gridFunc$[]								' grid
	SHARED	textArray$[]							' grid
	SHARED	textString$[]							' grid
	SHARED  MENUENTRY  menuentry[]		' grid : XuiMenu()
	SHARED	gridMessageFunc[]					' grid
	SHARED	CALLBACK	callback[]			' grid
	SHARED	GRID	grid[]							' grid
	SHARED	winkid[]									' window
	SHARED	window[]									' window
	SHARED	window$[]									' window
	SHARED  windowDisplay$[]					' window
	SHARED	WINDOW	windowInfo[]			' window
	SHARED	CALLBACK	monitor[]				' window
	SHARED	/cb/  CALLBACKS  callbacks[]
	STATIC	CALLBACK	zipCallback			' initialized (zeros)
	STATIC	GRID	zipGrid							' initialized (zeros)
	STATIC	WINDOW	zipWindow					' initialized (zeros)
	STATIC  MENUENTRY  hhhh[]					' initialized (empty)
	FUNCADDR  func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	DIM callbacks[]										' XuiQueueCallbacks
	modalUser = $$FALSE
	modalGridUser = $$FALSE
	modalResponseUser = $$FALSE
'
	IF keyboardFocusGrid THEN
		IF grid[keyboardFocusGrid].whomask THEN keyboardFocusGrid = 0
	END IF
'
	userTextFilename$ = ""
	GOSUB CleanMonitorArray
	GOSUB CleanGridInfoArrays
	GOSUB CleanGridTypeArrays
	GOSUB CleanWindowInfoArray
	XuiHelp (helpGrid, #SetHelpFile, 0, 0, 0, 0, 0, "")
	XuiHelp (helpGrid, #SetHelpFile, 0, 0, 0, 0, 0, @"$XBDIR/help/pde.hlp")
	RETURN
'
'
' *****  CleanMonitorArray  *****
'
' keep only those monitor entries that contain:
'		valid grid #
'		valid monitor device #
'		a grid with a system whomask = 0
'		monitor function in system code space - not user code space
'
SUB CleanMonitorArray
	entry = 0
	IF monitor[] THEN
		ugrid = UBOUND(grid[])
		FOR i = 0 TO UBOUND(monitor[])
			keep = $$FALSE
			grid = monitor[i].grid
			func = monitor[i].func
			device = monitor[i].r0
			IF func THEN
				IF grid THEN
					IF device THEN
						IF (grid < ugrid) THEN
							IFZ grid[grid].whomask THEN
								IF ((func > ##CODE0) AND (func < ##CODEZ)) THEN keep = $$TRUE
							END IF
						END IF
					END IF
				END IF
			END IF
			monitor[i].grid = 0
			monitor[i].func = 0
			monitor[i].v0 = 0
			monitor[i].v1 = 0
			monitor[i].r0 = 0
			IF keep THEN
				monitor[entry].grid = grid
				monitor[entry].func = func
				monitor[entry].v0 = 0
				monitor[entry].v1 = 0
				monitor[entry].r0 = device
				INC entry
			END IF
		NEXT i
	END IF
END SUB
'
'
' *****  CleanGridInfoArrays  *****
'
SUB CleanGridInfoArrays
	DIM temp[]
	DIM text$[]
	FOR grid = 0 TO UBOUND(grid[])
		whomask = grid[grid].whomask
		func = grid[grid].gridFunc
		name$ = gridName$[grid]
		IF whomask THEN
			@func (grid, #Blowback, 0, 0, 0, 0, 0, 0)
			grid[grid] = zipGrid
			callback[grid] = zipCallback
			help$[grid] = ""
			hint$[grid] = ""
			image$[grid] = ""
			gridName$[grid] = ""
			gridType$[grid] = ""
			gridFunc$[grid] = ""
			textString$[grid] = ""
			ATTACH kids[grid, ] TO temp[] : DIM temp[]
			ATTACH array[grid, ] TO temp[] : DIM temp[]
			ATTACH values[grid, ] TO temp[] : DIM temp[]
			ATTACH tabArray[grid, ] TO temp[] : DIM temp[]
			ATTACH menuentry[grid, ] TO hhhh[] : DIM hhhh[]
			ATTACH textArray$[grid, ] TO text$[] : DIM text$[]
			ATTACH gridMessageFunc[grid, ] TO temp[] : DIM temp[]
		ELSE
			ReportUserWhomask (grid, @name$, &help$[grid], @"help$[grid]")
			ReportUserWhomask (grid, @name$, &hint$[grid], @"hint$[grid]")
			ReportUserWhomask (grid, @name$, &image$[grid], @"image$[grid]")
			ReportUserWhomask (grid, @name$, &gridName$[grid], @"gridName$[grid]")
			ReportUserWhomask (grid, @name$, &gridFunc$[grid], @"gridFunc$[grid]")
			ReportUserWhomask (grid, @name$, &gridType$[grid], @"gridType$[grid]")
			ReportUserWhomask (grid, @name$, &textString$[grid], @"textString[grid]")
			ReportUserWhomask (grid, @name$, kids[grid,], @"kids[grid,]")
			ReportUserWhomask (grid, @name$, values[grid,], @"values[grid,]")
			ReportUserWhomask (grid, @name$, tabArray[grid,], @"tabArray[grid,]")
			ReportUserWhomask (grid, @name$, menuentry[grid,], @"menuentry[grid,]")
			ReportUserWhomask (grid, @name$, textArray$[grid,], @"textArray$[grid,]")
			ReportUserWhomask (grid, @name$, gridMessageFunc[grid,], @"gridMessageFunc[grid,]")
		END IF
	NEXT grid
END SUB
'
'
' *****  CleanGridTypeArrays  *****
'
SUB CleanGridTypeArrays
	DIM temp[]
	FOR gridType = 0 TO UBOUND(gridType[])
		whomask = gridType[gridType].whomask
		func = gridType[gridType].gridFunc
		name$ = gridTypeName$[gridType]
		IF whomask THEN
			SWAP gridTypeMessageFunc[gridType, ], temp[] : DIM temp[]
			SWAP messageSub[gridType, ], temp[] : DIM temp[]
			gridType[gridType] = zipGrid
			gridTypeName$[gridType] = ""
			gridTypeFunc$[gridType] = ""
'			gridTypeImage$[gridType] = ""
		ELSE
			ReportUserWhomask (gridType, @name$, gridTypeMessageFunc[gridType,], @"gridTypeMessageFunc[grid,Type,]")
			ReportUserWhomask (gridType, @name$, &gridTypeName$[gridType], @"gridTypeName$[gridType]")
			ReportUserWhomask (gridType, @name$, &gridTypeFunc$[gridType], @"gridTypeFunc$[gridType]")
			ReportUserWhomask (gridType, @name$, messageSub[gridType,], @"messageSub[gridType,]")
		END IF
	NEXT gridType
END SUB
'
'
' *****  CleanWindowInfoArray  *****
'
SUB CleanWindowInfoArray
	DIM temp[]
	FOR window = 0 TO UBOUND(windowInfo[])
		whomask = windowInfo[window].whomask
		name$ = window$[window]
		IF whomask THEN
			DIM temp[]
			SWAP window[window, ], temp[]
			DIM temp[]
			SWAP winkid[window, ], temp[]
			DIM temp[]
			window$[window] = ""
			windowDisplay$[window] = ""
			windowInfo[window] = zipWindow
		ELSE
			ReportUserWhomask (window, @name$, window[window,], @"window[window,]")
		END IF
	NEXT window
END SUB
END FUNCTION
'
'
' ####################################
' #####  XxxGuiDesignerOnOff ()  #####
' ####################################
'
FUNCTION  XxxGuiDesignerOnOff (state)
	SHARED  appearanceTextGrid
	SHARED  appearanceGrid
	SHARED  behaviorGrid
	SHARED	fontGrid
	SHARED  toolkitGrid
	SHARED  designGrid
	SHARED  reportGrid
	SHARED  helpGrid
	STATIC  currentState
'
	IFZ (state OR currentState) THEN RETURN
	IF (state = 1) THEN state = NOT currentState
	IF state THEN state = -1
	IF state THEN
		IF (state = currentState) THEN RETURN
		IFZ toolkitGrid THEN GOSUB CreateWindows
		XuiSendMessage (toolkitGrid, #DisplayWindow, 0, 0, 0, 0, 0, 0)
	ELSE
		XuiSendMessage (helpGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (reportGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (toolkitGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (behaviorGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (appearanceGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (appearanceTextGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
		IF designGrid THEN XuiSendMessage (designGrid, #HideWindow, 0, 0, 0, 0, 0, 0)
	END IF
	currentState = state

SUB CreateWindows
'
' Create a multi-purpose XuiFont Window
'
	IFZ fontGrid THEN
		wt = $$WindowTypeModal
		XuiFont        (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Font")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" font ")
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		fontGrid = grid
	END IF
'
' Create and Display the Toolkit Window
'
	IFZ (standalone OR toolkitGrid) THEN
		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
		tx1 = #windowBorderWidth : ty1 = #displayHeight - 300
		Toolkit        (@grid, #CreateWindow, tx1, ty1, 0, 0, wt, 0)
		XuiSendMessage ( grid, #SetCallback, grid, &ToolkitCode(), -1, -1, -1, grid)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Toolkit")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" toolkit ")
		XuiSendMessage ( grid, #GetValues, 0, 0, @pw, @pg, 2, 0)
		XuiSendMessage ( grid, #GetSize, 0, 0, @w, @h, 0, 0)
		tx2 = tx1 + w
		ty1 = #displayHeight - h - #windowBorderWidth
		ty2 = #displayHeight - #windowBorderWidth
		XuiSendMessage ( grid, #ResizeWindow, tx1, ty1, w, h, 0, 0)
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		toolkitGrid = grid
	END IF
'
' Create the Appearance Window
'
	IFZ (standalone OR appearanceGrid) THEN
		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
		ax1 = tx2 + #windowBorderWidth + #windowBorderWidth : ay1 = ty1
		Appearance     (@grid, #CreateWindow, ax1, ay1, 0, 0, wt, 0)
	  XuiSendMessage ( grid, #SetCallback, grid, &AppearanceCode(), -1, -1, -1, grid)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Appearance")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" appearance ")
		XuiSendMessage ( grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
		ax2 = ax1 + ww
		ay1 = #displayHeight - hh - #windowBorderWidth
		ay2 = ay1 + hh
		XuiSendMessage ( grid, #ResizeWindow, ax1, ay1, ww, hh, 0, 0)
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		appearanceGrid = grid
	END IF
'
	IFZ (standalone OR appearanceTextGrid) THEN
		wt = $$WindowTypeFixedSize
		atx1 = ax2 + #windowBorderWidth + #windowBorderWidth
		aty1 = #displayHeight - 128 - #windowBorderWidth
		XuiTextArea    (@grid, #CreateWindow, atx1, aty1, 256, 128, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"AppearanceTextArray")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" appearance text array ")
		XuiSendMessage ( grid, #SetHelpString, -1, 0, 0, 0, -1, @"pde.hlp:AppearanceTextArray")
		XuiSendMessage ( grid, #GetSize, 0, 0, @www, @hhh, 0, 0)
		atx2 = atx1 + www
		aty1 = #displayHeight - hhh - #windowBorderWidth
		aty2 = aty1 + hhh
		XuiSendMessage ( grid, #ResizeWindow, atx1, aty1, www, hhh, 0, 0)
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		appearanceTextGrid = grid
	END IF
'
' Create the Behavior Window
'
	IFZ (standalone OR behaviorGrid) THEN
		wt = $$WindowTypeFixedSize OR $$WindowTypeSystemMenu OR $$WindowTypeCloseHide
		XuiListDialog2B (@grid, #CreateWindow, w + #windowBorderWidth + #windowBorderWidth + #windowBorderWidth, #windowTitleHeight + #windowBorderWidth, 440, 440, wt, 0)
		XuiSendMessage  ( grid, #SetCallback, grid, &BehaviorCode(), -1, -1, -1, grid)
		XuiSendMessage  ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Behavior")
		XuiSendMessage  ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" behavior ")
		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 0, @"pde.hlp:Behavior")
		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 1, @"pde.hlp:BehaviorList")
		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 2, @"pde.hlp:BehaviorText")
		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 3, @"pde.hlp:BehaviorEnter")
		XuiSendMessage  ( grid, #SetHelpString, 0, 0, 0, 0, 4, @"pde.hlp:BehaviorCancel")
		XuiSendMessage  ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		behaviorGrid = grid
	END IF
'
' Create the ReportMessage window
'
	IFZ reportGrid THEN
		wt = $$WindowTypeFixedSize
		x = #windowBorderWidth
		y = #windowBorderWidth + #windowTitleHeight
		Report         (@grid, #CreateWindow, x, y, 360, 224, wt, 0)
		XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Report")
		XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @" report message ")
		XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
		reportGrid = grid
	END IF
END SUB
END FUNCTION
'
'
' #################################
' #####  XxxXuiTextCursor ()  #####
' #################################
'
FUNCTION  XxxXuiTextCursor (color)
	SHARED	GRID	grid[]
'
	XgrGridTypeNameToNumber (@"XuiTextArea", @XuiTextArea)
	XgrGridTypeNameToNumber (@"XuiTextLine", @XuiTextLine)
'
	upper = UBOUND (grid[])
	FOR g = 1 TO upper
		change = $$FALSE
		gridType = grid[g].gridType
		IF (gridType = XuiTextArea) THEN change = $$TRUE
		IF (gridType = XuiTextLine) THEN change = $$TRUE
		IF change THEN
			XuiSendMessage (g, #SetColorExtra, color, -1, -1, -1, 0, 0)
			XuiSendMessage (g, #SetColorExtra, color, -1, -1, -1, 1, 0)
			XuiSendMessage (g, #Redraw, 0, 0, 0, 0, 0, 0)
		END IF
	NEXT g
END FUNCTION
'
'
' ###########################
' #####  XuiMessage ()  #####
' ###########################
'
FUNCTION  XuiMessage (prompt$)
	SHARED	messageFont
'
	IFZ prompt$ THEN RETURN
	newline = INSTR (prompt$, "\n")
'
	IF newline THEN
		left = INSTR (prompt$, "[")
		right = INSTR (prompt$, "]")
		IF ((left = 1) AND (right = (newline-1))) THEN
			title$ = MID$ (prompt$, 2, right-2)
			prompt$ = MID$ (prompt$, newline+1)
		END IF
	END IF
'
' Message Window  ( generic message window )
'
	wt = $$WindowTypeModal
	XuiMessage1B (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
	XuiMessage1B ( grid, #SetGridName, 0, 0, 0, 0, 0, @"Message")
	XuiMessage1B ( grid, #SetFontNumber, messageFont, 0, 0, 0, 1, 0)
	XuiMessage1B ( grid, #SetColor, $$BrightBlue, $$Yellow, -1, -1, 1, 0)
	XuiMessage1B ( grid, #SetColorExtra, -1, -1, $$Black, $$Yellow, 1, 0)
	XuiMessage1B ( grid, #SetTexture, $$TextureShadow, 0, 0, 0, 1, 0)
'
	IFZ title$ THEN title$ = " message "
	XuiMessage1B ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @title$)
	XuiMessage1B ( grid, #SetTextString, 0, 0, 0, 0, 1, @prompt$)
	XuiMessage1B ( grid, #GetSmallestSize, 0, 0, @ww, @hh, 0, 0)
	ww = ww + 16 : hh = hh + 16
'
	width = #displayWidth >> 1
	height = #displayHeight >> 1
	IF (ww > width) THEN width = ww
	IF (hh > height) THEN height = hh
	xDisp = (#displayWidth >> 1) - (width >> 1) - #windowBorderWidth
	yDisp = (#displayHeight >> 1) - (height >> 1) - #windowBorderWidth - (#windowTitleHeight >> 1)
	XuiMessage1B ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	XuiMessage1B ( grid, #ResizeWindow, xDisp, yDisp, width, height, 0, 0)
	XuiMessage1B ( grid, #GetModalInfo, 0, 0, 0, 0, @reply, 0)
	XuiMessage1B ( grid, #Destroy, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ##########################
' #####  XuiDialog ()  #####
' ##########################
'
FUNCTION  XuiDialog (prompt$, default$, reply, reply$)
	SHARED	dialogFont
'
	IFZ prompt$ THEN RETURN
	newline = INSTR (prompt$, "\n")
'
	title$ = ""
	IF newline THEN
		left = INSTR (prompt$, "[")
		right = INSTR (prompt$, "]")
		IF ((left = 1) AND (right = (newline-1))) THEN
			title$ = MID$ (prompt$, 2, right-2)
			prompt$ = MID$ (prompt$, newline+1)
		END IF
	END IF
'
' Dialog Window  ( generic dialog window )
'
	wt = $$WindowTypeModal
	XuiDialog2B (@grid, #CreateWindow, 0, 0, 0, 0, wt, 0)
	XuiDialog2B ( grid, #SetGridName, 0, 0, 0, 0, 0, @title$)
	XuiDialog2B ( grid, #SetFontNumber, dialogFont, 0, 0, 0, 1, 0)
	XuiDialog2B ( grid, #SetTexture, $$TextureShadow, 0, 0, 0, 1, 0)
	XuiDialog2B ( grid, #SetColor, $$BrightBlue, $$Yellow, -1, -1, 1, 0)
	XuiDialog2B ( grid, #SetColorExtra, -1, -1, $$Black, $$Yellow, 1, 0)
'
	IFZ title$ THEN title$ = " dialog "
	XuiDialog2B ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @title$)
	XuiDialog2B ( grid, #SetTextString, 0, 0, 0, 0, 1, @prompt$)
	XuiDialog2B ( grid, #SetTextString, 0, 0, 0, 0, 2, @default$)
	XuiDialog2B ( grid, #GetSmallestSize, 0, 0, @ww, @hh, 0, 0)
	ww = ww + 16 : hh = hh + 16
'
	length = LEN(default$)
	width = #displayWidth >> 1
	height = #displayHeight >> 1
	IF (ww > width) THEN width = ww
	IF (hh > height) THEN height = hh
	xDisp = (#displayWidth >> 1) - (width >> 1) - #windowBorderWidth
	yDisp = (#displayHeight >> 1) - (height >> 1) - #windowBorderWidth - (#windowTitleHeight >> 1)
	XuiDialog2B ( grid, #ResizeWindow, xDisp, yDisp, width, height, 0, 0)
	XuiDialog2B ( grid, #SetTextString, 0, 0, 0, 0, 2, @default$)
	XuiDialog2B ( grid, #SetTextCursor, 0, 0, 0, 0, 2, 0)
	XuiDialog2B ( grid, #SetTextCursor, length, 0, 0, 0, 2, 0)
	XuiDialog2B ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	XuiDialog2B ( grid, #GetModalInfo, @v0, 0, 0, 0, @reply, 0)
	XuiDialog2B ( grid, #GetTextString, 0, 0, 0, 0, 2, @reply$)
	IF (v0{8,0} = $$KeyEscape) THEN reply = 4 : reply$ = ""
	XuiDialog2B ( grid, #Destroy, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ###############################
' #####  XuiGetResponse ()  #####
' ###############################
'
FUNCTION  XuiGetResponse (gridType$, title$, prompt$, grids$, v0, v1, reply, reply$)
	SHARED	GRID	grid[]
	SHARED	GRID	gridType[]
	FUNCADDR	f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
	STATIC	XuiLabel
'
	IFZ XuiLabel THEN XgrGridTypeNameToNumber (@"XuiLabel", @XuiLabel)
	XgrGridTypeNameToNumber (gridType$, @gridType)
	IF (gridType <= 0) THEN RETURN
	IF (gridType > UBOUND(gridType[])) THEN RETURN
	IFZ (gridType[gridType].can AND $$Respond) THEN RETURN
	f = gridType[gridType].gridFunc
	IFZ f THEN RETURN
'
' Get window title out of prompt string
'
	newline = INSTR (prompt$, "\n")
	IF newline THEN
		left = INSTR (prompt$, "[")
		right = INSTR (prompt$, "]")
		IF ((left = 1) AND (right = (newline-1))) THEN
			title$ = MID$ (prompt$, 2, right-2)
			prompt$ = MID$ (prompt$, newline+1)
		END IF
	END IF
	XstStringToStringArray (@prompt$, @prompt$[])
'
' Create window containing grid of the specified grid type
'
	wt = $$WindowTypeModal
	width = #displayWidth - (#windowBorderWidth >> 1)
	height = #displayHeight - #windowTitleHeight - (#windowBorderWidth >> 1)
	@f ( @grid, #CreateWindow, #windowBorderWidth, #windowTitleHeight + #windowBorderWidth, width, height, $$WindowTypeModal, 0)
	XuiSendMessage ( grid, #SetGridName, 0, 0, 0, 0, 0, @"GetResponse")
	XuiSendMessage ( grid, #GetKidArray, 0, 0, 0, 0, 0, @kid[])
'
' Find Label grid : that's where the prompt$ string goes
'
	upper = 0
	labelKid = 0
	IF kid[] THEN
		upper = UBOUND (kid[])
		FOR i = 0 TO upper
			XuiSendMessage ( grid, #GetGridType, @gt, 0, 0, 0, i, 0)
			IF (gt = XuiLabel) THEN labelKid = i : EXIT FOR
		NEXT i
	END IF
'
' Change any button strings requested in grid$
'
	gg = 0
	IF grids$ THEN
		XstStringToStringArray (@grids$, @grids$[])
		upperGrid = UBOUND (grids$[])
		gridString = 0
		IF (upper > labelKid) THEN
			FOR i = labelKid + 1 TO upper
				IF kid[i] THEN
					IF (gridString > upperGrid) THEN EXIT FOR
					IF grids$[gridString] THEN XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, i, grids$[gridString])
				END IF
				INC gridString
			NEXT i
		END IF
	END IF
'
' Set the size and look of the reply window grid
'
	v0 = 0
	v1 = 0
	reply = 0
	reply$ = ""
	IFZ title$ THEN title$ = gridType$
	XuiSendMessage ( grid, #SetTexture, $$TextureShadow, 0, 0, 0, labelKid, 0)
	XuiSendMessage ( grid, #SetColorExtra, -1, -1, $$Black, $$Yellow, labelKid, 0)
	XuiSendMessage ( grid, #SetColor, $$Green, $$Yellow, -1, -1, labelKid, 0)
	XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @title$)
	XuiSendMessage ( grid, #GetSmallestSize, 0, 0, @ww, @hh, 0, 0)
	IF prompt$ THEN
		XuiSendMessage ( grid, #SetTextString, 0, 0, 0, 0, labelKid, @prompt$)
	END IF
'
	width = #displayWidth >> 1
	height = #displayHeight >> 1
	IF (ww > width) THEN width = ww
	IF (hh > height) THEN height = hh
	xDisp = (#displayWidth >> 1) - (width >> 1) - #windowBorderWidth
	yDisp = (#displayHeight >> 1) - (height >> 1) - #windowBorderWidth - (#windowTitleHeight >> 1)
	XuiSendMessage ( grid, #ResizeWindow, xDisp, yDisp, width, height, 0, 0)
'
' Get modal response
'
	XuiSendMessage ( grid, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #GetModalInfo, @v0, @v1, 0, 0, @reply, 0)
	inString = gridType[gridType].can AND $$InputTextString
	inArray = gridType[gridType].can AND $$InputTextArray
'
	SELECT CASE TRUE
		CASE inString	:	inString = gridType[gridType].inputTextString
										XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, inString, @reply$)
		CASE inArray	:	inArray = gridType[gridType].inputTextArray
										XuiSendMessage (grid, #GetTextArray, 0, 0, 0, 0, inArray, @text$[])
										XstStringArrayToString (@text$[], @reply$)
	END SELECT
	XuiSendMessage (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ############################
' #####  XuiGetReply ()  #####
' ############################
'
FUNCTION  XuiGetReply (grid, title$, prompt$, grids$, v0, v1, reply, reply$)
	SHARED	upperGrid
	SHARED	GRID	grid[]
	STATIC	entry
	STATIC	XuiLabel
	FUNCADDR	f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IFZ entry THEN GOSUB Initialize
	IF (grid <= 0) THEN RETURN
	IF (grid > upperGrid) THEN RETURN
	IFZ (grid[grid].can AND $$Respond) THEN RETURN
'
' Get window title out of prompt string
'
	newline = INSTR (prompt$, "\n")
	IF newline THEN
		left = INSTR (prompt$, "[")
		right = INSTR (prompt$, "]")
		IF ((left = 1) AND (right = (newline-1))) THEN
			title$ = MID$ (prompt$, 2, right-2)
			prompt$ = MID$ (prompt$, newline+1)
		END IF
	END IF
	XstStringToStringArray (@prompt$, @prompt$[])
	XuiSendMessage ( grid, #GetKidArray, 0, 0, 0, 0, 0, @kid[])
'
' Find Label grid : that's where the prompt$ string goes
'
	upper = 0
	labelKid = 0
	IF kid[] THEN
		upper = UBOUND (kid[])
		FOR i = 0 TO upper
			IF kid[i] THEN
				XuiSendMessage ( grid, #GetGridType, @gt, 0, 0, 0, i, 0)
				IF (gt = XuiLabel) THEN labelKid = i : EXIT FOR
			END IF
		NEXT i
	END IF
'
' Change any button strings requested in grid$
'
	gg = 0
	IF grids$ THEN
		XstStringToStringArray (@grids$, @grids$[])
		upperString = UBOUND (grids$[])
		gridString = 0
		IF (upper > labelKid) THEN
			FOR i = labelKid + 1 TO upper
				IF kid[i] THEN
					kid = kid[i]
					IF (kid > 0) THEN
						IF (kid < upperGrid) THEN
							IF (gridString <= upperString) THEN
								IF grids$[gridString] THEN XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, i, grids$[gridString])
							END IF
						END IF
					END IF
				END IF
				INC gridString
			NEXT i
		END IF
	END IF
'
' Set the size and look of the reply window grid
'
	v0 = 0
	v1 = 0
	reply = 0
	reply$ = ""
	XuiSendMessage ( grid, #SetWindowTitle, 0, 0, 0, 0, 0, @title$)
	XuiSendMessage ( grid, #GetSmallestSize, 0, 0, @ww, @hh, 0, 0)
	IF prompt$ THEN
		XuiSendMessage ( grid, #SetTextString, 0, 0, 0, 0, labelKid, @prompt$)
	END IF
'
	width = #displayWidth >> 1
	height = #displayHeight >> 1
	IF (ww > width) THEN width = ww
	IF (hh > height) THEN height = hh
	xDisp = (#displayWidth >> 1) - (width >> 1) - #windowBorderWidth
	yDisp = (#displayHeight >> 1) - (height >> 1) - #windowBorderWidth - (#windowTitleHeight >> 1)
	XuiSendMessage ( grid, #ResizeWindow, xDisp, yDisp, width, height, 0, 0)
'
' Get modal response
'
	inString = grid[grid].can AND $$InputTextString
	inArray = grid[grid].can AND $$InputTextArray
	XuiSendMessage ( grid, #GetModalInfo, @v0, @v1, 0, 0, @reply, 0)
'
	SELECT CASE TRUE
		CASE inString
					inString = grid[grid].inputTextString
					XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, inString, @reply$)
		CASE inArray
					inArray = grid[grid].inputTextArray
					XuiSendMessage (grid, #GetTextArray, 0, 0, 0, 0, inArray, @text$[])
					XstStringArrayToString (@text$[], @reply$)
	END SELECT
	RETURN
'
'
' *****  Initialize  *****
'
SUB Initialize
	entry = $$TRUE
	XgrGridTypeNameToNumber (@"XuiLabel", @XuiLabel)
END SUB
END FUNCTION
'
'
' ################################
' #####  XuiCreateWindow ()  #####
' ################################
'
FUNCTION  XuiCreateWindow (grid, gridType$, xDisp, yDisp, width, height, winType, display$)
	SHARED	GRID	gridType[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, ANY)
'
	IFZ gridType$ THEN RETURN ($$TRUE)
	upper = UBOUND(gridType[])
	IFZ winFunc THEN winFunc = &XuiWindow()
	XgrGridTypeNameToNumber (@gridType$, @gridType)
	IF (gridType > upper) THEN RETURN ($$TRUE)
	IF (gridType <= 0) THEN RETURN ($$TRUE)
	IF (gridType != gridType[gridType].gridType) THEN RETURN ($$TRUE)
	func = gridType[gridType].gridFunc
	IFZ func THEN RETURN ($$TRUE)
	@func (@grid, #CreateWindow, @xDisp, @yDisp, @width, @height, @winType, @display$)
'	IF grid THEN XuiSetCallback (grid, #SetCallback, grid, &XuiQueueCallbacks(), -1, -1, -1, -1)
END FUNCTION
'
'
' #################################
' #####  XuiReportMessage ()  #####
' #################################
'
FUNCTION  XuiReportMessage (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	UBYTE	messageType[]
	SHARED	upperMessage
	SHARED	reportGrid
	STATIC	message$[]
	ULONG  ##DYNO0, ##DYNO, ##DYNOX, ##DYNOZ
	ULONG  addr
'
  $Report         =  0  ' kid  0 grid type = Report
  $gridLabel      =  1  ' kid  1 grid type = XuiLabel
  $gridNumber     =  2  ' kid  2 grid type = XuiLabel
  $gridTypeName   =  3  ' kid  3 grid type = XuiLabel
  $messageLabel   =  4  ' kid  4 grid type = XuiLabel
  $messageNumber  =  5  ' kid  5 grid type = XuiLabel
  $messageName    =  6  ' kid  6 grid type = XuiLabel
  $v0Label        =  7  ' kid  7 grid type = XuiLabel
  $v0Number       =  8  ' kid  8 grid type = XuiLabel
  $v0Hex          =  9  ' kid  9 grid type = XuiLabel
  $v1Label        = 10  ' kid 10 grid type = XuiLabel
  $v1Number       = 11  ' kid 11 grid type = XuiLabel
  $v1Hex          = 12  ' kid 12 grid type = XuiLabel
  $v2Label        = 13  ' kid 13 grid type = XuiLabel
  $v2Number       = 14  ' kid 14 grid type = XuiLabel
  $v2Hex          = 15  ' kid 15 grid type = XuiLabel
  $v3Label        = 16  ' kid 16 grid type = XuiLabel
  $v3Number       = 17  ' kid 17 grid type = XuiLabel
  $v3Hex          = 18  ' kid 18 grid type = XuiLabel
  $r0Label        = 19  ' kid 19 grid type = XuiLabel
  $r0Number       = 20  ' kid 20 grid type = XuiLabel
  $r0Hex          = 21  ' kid 21 grid type = XuiLabel
  $r1Label        = 22  ' kid 22 grid type = XuiLabel
  $r1Number       = 23  ' kid 23 grid type = XuiLabel
  $r1Info         = 24  ' kid 24 grid type = XuiLabel
  $Cancel         = 25  ' kid 25 grid type = XuiPushButton
  $UpperKid       = 25  ' kid maximum
'
'
' *****  Display Message in reportGrid  *****
'
	whomask = ##WHOMASK
	##WHOMASK = 0
'
	IF (reportGrid <= 0) THEN
		PRINT "XuiReportMessage() : error : (reportGrid = "; STRING$(reportGrid); ")"
		##WHOMASK = whomask
		RETURN
	END IF
'
	name$ = "$XBDIR" + $$PathSlash$ + "templates" + $$PathSlash$ + "message.xxx"
	IFZ message$[] THEN XstLoadStringArray (@name$, @message$[])
'
	IF (message > upperMessage) THEN
		PRINT "XuiReportMessage() : error : (message > upperMessage)"
		##WHOMASK = whomask
		RETURN
	END IF
'
	gridNumber$ = STRING$ (grid)
	messageNumber$ = STRING$ (message)
	XgrGetMessageType (message, @messageType)
	XgrMessageNumberToName (message, @message$)
	IF (message = #Callback) THEN XgrMessageNumberToName (r1, @r1Info$)
	IF r1Info$ THEN r1Info$ = r1Info$ + " (message)"
'
	SELECT CASE messageType
		CASE $$Grid			: XgrGetGridType (grid, @gridType)
											XgrGridTypeNumberToName (gridType, @gridType$)
		CASE $$Window		:	XgrGetWindowTitle (grid, @gridType$)
		CASE ELSE				: PRINT "XuiReportMessage() : error : (messageType != $$Window or $$Grid)" : RETURN
	END SELECT
'
	IFZ r1Info$ THEN
		addr = r1
		ucode = ((addr > ##UCODE) AND (addr < ##UCODEZ))
		dyno = ((addr > ##DYNO) AND (addr < ##DYNOZ))
		IF (dyno OR ucode) THEN
			addr3 = r1 - 4
			word3 = XLONGAT (addr3)
			IFZ (word3 AND 0x40000000) THEN
				IF ((word3 AND 0x0000FFFF) = 1) THEN
					type = (word3 >> 16) AND 0x000000FF
					IF (type = $$STRING) THEN
						IF dyno THEN
							r1Info$ = CSTRING$ (r1)
						ELSE
							addr1 = r1 - 12
							word1 = XLONGAT (addr1)
							IFZ word1 THEN r1Info$ = CSTRING$ (r1)
						END IF
					END IF
				END IF
			END IF
		END IF
	END IF
'
	v0Number$ = STRING$ (v0)
	v0Hex$ = HEX$(v0,8)
'
	v1Number$ = STRING$ (v1)
	v1Hex$ = HEX$(v1,8)
'
	v2Number$ = STRING$ (v2)
	v2Hex$ = HEX$(v2,8)
'
	v3Number$ = STRING$ (v3)
	v3Hex$ = HEX$(v3,8)
'
	r0Number$ = STRING$ (r0)
	r0Hex$ = HEX$(r0,8)
'
	r1Number$ = STRING$ (r1)
	IFZ r1Info$ THEN r1Info$ = HEX$(r1,8)
'
	found = -1
	m$ = "#" + message$
	FOR i = 0 TO UBOUND (message$[])
		found = INSTR (message$[i], m$)
		IF found THEN found = i : EXIT FOR
	NEXT i
'
	upper = -1
	DIM arg$[]
	IF (found >= 0) THEN
		arg$ = message$[found]
		ParseLine (@arg$, @arg$[])
		IF arg$[] THEN
			upper = UBOUND (arg$[])
			FOR i = 2 TO upper
				IF (i > 7) THEN EXIT FOR
				IF arg$[i] THEN
					SELECT CASE i
						CASE 2	: v0Hex$ = v0Hex$  + "  " + arg$[i]
						CASE 3	: v1Hex$ = v1Hex$  + "  " + arg$[i]
						CASE 4	: v2Hex$ = v2Hex$  + "  " + arg$[i]
						CASE 5	: v3Hex$ = v3Hex$  + "  " + arg$[i]
						CASE 6	: r0Hex$ = r0Hex$  + "  " + arg$[i]
						CASE 7	: r1Hex$ = r1Info$ + "  " + arg$[i]
					END SELECT
				END IF
			NEXT i
		END IF
	END IF
'
'
' Update and Redraw and label that's changed
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $gridNumber,		@test$)
	IF (test$ != gridNumber$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $gridNumber, @gridNumber$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $gridNumber, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $gridTypeName, @test$)
	IF (test$ != gridType$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $gridTypeName, @gridType$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $gridTypeName, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $messageNumber,	@test$)
	IF (test$ != messageNumber$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $messageNumber,	@messageNumber$)
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $messageName, @message$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $messageNumber, 0)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $messageName, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v0Number, @test$)
	IF (test$ != v0Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v0Number, @v0Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v0Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v0Hex, @test$)
	IF (test$ != v0Hex$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v0Hex, @v0Hex$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v0Hex, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v1Number, @test$)
	IF (test$ != v1Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v1Number, @v1Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v1Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v1Hex, @test$)
	IF (test$ != v1Hex$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v1Hex, @v1Hex$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v1Hex, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v2Number, @test$)
	IF (test$ != v2Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v2Number, @v2Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v2Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v2Hex, @test$)
	IF (test$ != v2Hex$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v2Hex, @v2Hex$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v2Hex, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v3Number, @test$)
	IF (test$ != v3Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v3Number, @v3Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v3Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $v3Hex, @test$)
	IF (test$ != v3Hex$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $v3Hex, @v3Hex$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $v3Hex, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $r0Number, @test$)
	IF (test$ != r0Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $r0Number, @r0Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $r0Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $r0Hex, @test$)
	IF (test$ != r0Hex$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $r0Hex, @r0Hex$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $r0Hex, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $r1Number, @test$)
	IF (test$ != r1Number$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $r1Number, @r1Number$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $r1Number, 0)
	END IF
'
	XuiSendMessage (reportGrid, #GetTextString, 0, 0, 0, 0, $r1Info, @test$)
	IF (test$ != r1Info$) THEN
		XuiSendMessage (reportGrid, #SetTextString, 0, 0, 0, 0, $r1Info, @r1Info$)
		XuiSendMessage (reportGrid, #RedrawGrid, 0, 0, 0, 0, $r1Info, 0)
	END IF
'
	XuiSendMessage (reportGrid, #ShowWindow, 0, 0, 0, 0, 0, 0)
	##WHOMASK = whomask
END FUNCTION
'
'
' #####################################
' #####  XuiSendStringMessage ()  #####
' #####################################
'
FUNCTION  XuiSendStringMessage (grid, message$, v0, v1, v2, v3, r0, r1)
	IFZ message$ THEN PRINT "XuiSendStringMessage() : error : (message$ is empty)" : RETURN
	XgrMessageNameToNumber (@message$, @message)
	IF (message <= 0) THEN PRINT "XuiSendMessage() : error : (unregistered message)" : RETURN
	XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END FUNCTION
'
'
' ###################################
' #####  XuiGetNextCallback ()  #####
' ###################################
'
FUNCTION  XuiGetNextCallback (grid, message$, v0, v1, v2, v3, r0, r1$)
	SHARED	/cb/  CALLBACKS  callbacks[]
	SHARED	/cb/  upper
	SHARED	/cb/  count
	SHARED	/cb/  out
	SHARED	/cb/  in
'
	IF (count <= 0) THEN
		count = 0
		grid = 0
		message = 0
		v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r0 = 0 : r1 = 0
		RETURN (count)
	END IF
'
	IFZ callbacks[] THEN
		count = 0
		grid = 0
		message = 0
		v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r0 = 0 : r1 = 0
		RETURN (count)
	END IF
'
	return = count
	grid = callbacks[out].grid
	message = callbacks[out].message
	v0 = callbacks[out].v0
	v1 = callbacks[out].v1
	v2 = callbacks[out].v2
	v3 = callbacks[out].v3
	r0 = callbacks[out].r0
	r1 = callbacks[out].r1
	vv2 = callbacks[out].vv2
	vv3 = callbacks[out].vv3
	rr0 = callbacks[out].rr0
	rr1 = callbacks[out].rr1
	XgrMessageNumberToName (message, @message$)
	XuiSendMessage (grid, #GetGridName, 0, 0, 0, 0, r0, @r1$)
	r0 = (rr0 << 16) OR r0
'
	INC out
	DEC count
	IF (out > upper) THEN out = 0
	RETURN (return)
END FUNCTION
'
'
' ##################################
' #####  XuiQueueCallbacks ()  #####
' ##################################
'
FUNCTION  XuiQueueCallbacks (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	/cb/  CALLBACKS  callbacks[]
	SHARED	/cb/  upper
	SHARED	/cb/  count
	SHARED	/cb/  out
	SHARED	/cb/  in
'
	whomask = ##WHOMASK
'
	IF (message != #Callback) THEN RETURN
	message = r1
'
	IFZ callbacks[] THEN
		in = 0
		out = 0
		count = 0
		upper = 63
		##WHOMASK = 0
		DIM callbacks[upper]
		##WHOMASK = whomask
	END IF
'
	XuiCallback (grid, #GetCallbackArgs, 0, 0, @vv2, @vv3, @rr0, @rr1)
	SWAP r0, rr0
'
	callbacks[in].grid = grid
	callbacks[in].message = message
	callbacks[in].v0 = v0
	callbacks[in].v1 = v1
	callbacks[in].v2 = v2
	callbacks[in].v3 = v3
	callbacks[in].r0 = r0
	callbacks[in].r1 = r1
	callbacks[in].vv2 = vv2
	callbacks[in].vv3 = vv3
	callbacks[in].rr0 = rr0
	callbacks[in].rr1 = rr1
'
	INC in															' next in slot
	INC count
	IF (in > upper) THEN in = 0					' wrap to bottom of queue
	IF (count >= 64) THEN								' no more than 64 in queue
		Beep (2000,20)										' warn user of queue overflow
		count = 64												' 64 queued callbacks max
	END IF
'
'	PRINT "a: "; in, out, count, upper
'	PRINT "b: "; grid, message, v0, v1, v2, v3, r0, r1
'	PRINT "c: "; grid, message, v0, v1, v2, v2, r0, r1, vv2, vv3, rr0, rr1
END FUNCTION
'
'
' #####################################
' #####  XuiAlignNameToNumber ()  #####
' #####################################
'
FUNCTION  XuiAlignNameToNumber (align$, align)
	SHARED	align$[]
'
	align = XLONG (align$)
	IF align THEN RETURN
	a$ = TRIM$ (align$)
	IFZ a$ THEN RETURN
	c = a${0}
'
	IF ((c >= '0') AND (c <= '9')) THEN RETURN		' "0" or "0x00" ...
	IF (c != '$') THEN a$ = "$$" + a$
'
	align = -1
	upper = UBOUND (align$[])
	FOR i = 0 TO upper
		IF (a$ = align$[i]) THEN
			align = i
			RETURN
		END IF
	NEXT i
	RETURN ($$TRUE)
END FUNCTION
'
'
' ###################################
' #####  XuiCanNameToNumber ()  #####
' ###################################
'
FUNCTION  XuiCanNameToNumber (can$, can)
	SHARED	can$[]
'
	can = XLONG (can$)
	IF can THEN RETURN
	c$ = TRIM$ (can$)
	IFZ c$ THEN RETURN
	c = c${0}
'
	IF ((c >= '0') AND (c <= '9')) THEN RETURN		' "0" or "0x00" ...
	IF (c != '$') THEN c$ = "$$" + c$
'
	one = 1
	upper = UBOUND (can$[])
	FOR i = 0 TO upper
		IF can$[i] THEN
			IF (c$ = can$[i]) THEN
				IFZ i THEN can = 1 : EXIT FOR
				can = one << i
				RETURN
			END IF
		END IF
	NEXT i
	RETURN ($$TRUE)
END FUNCTION
'
'
' #####################################
' #####  XuiCanStringToNumber ()  #####
' #####################################
'
FUNCTION  XuiCanStringToNumber (can$, can)
'
	c = 0
	can = 0
	c$ = TRIM$ (can$)
	IFZ c$ THEN RETURN
'
	DO
		cc$ = XstNextField$ (@c$, @c, @done)
		XuiCanNameToNumber (@cc$, @cc)
		can = can OR cc
	LOOP UNTIL done
END FUNCTION
'
'
' #######################################
' #####  XuiJustifyNameToNumber ()  #####
' #######################################
'
FUNCTION  XuiJustifyNameToNumber (justify$, justify)
	SHARED	justify$[]
'
	justify = XLONG (justify$)
	IF justify THEN RETURN
	j$ = TRIM$ (justify$)
	IFZ j$ THEN RETURN
	c = j${0}
'
	IF ((c >= '0') AND (c <= '9')) THEN RETURN		' "0" or "0x00" ...
	IF (c != '$') THEN j$ = "$$" + j$
'
	justify = -1
	upper = UBOUND (justify$[])
	FOR i = 0 TO upperX
		IF (j$ = justify$[i]) THEN
			justify = i
			RETURN
		END IF
	NEXT i
	RETURN ($$TRUE)
END FUNCTION
'
'
' #######################################
' #####  XuiTextureNameToNumber ()  #####
' #######################################
'
FUNCTION  XuiTextureNameToNumber (texture$, texture)
	SHARED	texture$[]
'
	texture = XLONG (texture$)
	IF texture THEN RETURN
	t$ = TRIM$ (texture$)
	IFZ t$ THEN RETURN
	c = t${0}
'
	IF ((c >= '0') AND (c <= '9')) THEN RETURN		' "0" or "0x00" ...
	IF (c != '$') THEN t$ = "$$" + t$
'
	texture = -1
	upper = UBOUND (texture$[])
	FOR i = 0 TO upper
		IF (t$ = texture$[i]) THEN
			texture = i
			RETURN
		END IF
	NEXT i
	RETURN ($$TRUE)
END FUNCTION
'
'
' #####################################
' #####  XuiAlignNumberToName ()  #####
' #####################################
'
FUNCTION  XuiAlignNumberToName (align, align$)
	SHARED	align$[]
'
	align$ = ""
	upper = UBOUND (align$[])
	IF (align < 0) THEN RETURN
	IF (align > upper) THEN RETURN
	align$ = align$[align]
END FUNCTION
'
'
' ###################################
' #####  XuiCanNumberToName ()  #####
' ###################################
'
FUNCTION  XuiCanNumberToName (can, can$)
	SHARED	can$[]
'
	one = 1
	can$ = ""
	IF (can AND 0x01) THEN can$ = can$[0]
	FOR i = 1 TO 31
		IF (can AND (one << i)) THEN
			IF can$ THEN can$ = can$ + " OR "
			can$ = can$ + can$[i]
		END IF
	NEXT i
END FUNCTION
'
'
' #####################################
' #####  XuiCanNumberToString ()  #####
' #####################################
'
FUNCTION  XuiCanNumberToString (can, can$)
	SHARED	can$[]
'
	one = 1
	can$ = ""
	IF (can AND 0x01) THEN can$ = can$[0]
	FOR i = 1 TO 31
		IF (can AND (one << i)) THEN
			IF can$ THEN can$ = can$ + " OR "
			can$ = can$ + can$[i]
		END IF
	NEXT i
END FUNCTION
'
'
' #######################################
' #####  XuiJustifyNumberToName ()  #####
' #######################################
'
FUNCTION  XuiJustifyNumberToName (justify, justify$)
	SHARED	justify$[]
'
	justify$ = ""
	upper = UBOUND (justify$[])
	IF (justify < 0) THEN RETURN
	IF (justify > upper) THEN RETURN
	justify$ = justify$[justify]
END FUNCTION
'
'
' #######################################
' #####  XuiTextureNumberToName ()  #####
' #######################################
'
FUNCTION  XuiTextureNumberToName (texture, texture$)
	SHARED	texture$[]
'
	texture$ = ""
	upper = UBOUND (texture$[])
	IF (texture < 0) THEN RETURN
	IF (texture > upper) THEN RETURN
	texture$ = texture$[texture]
END FUNCTION
'
'
' #############################################
' #####  XuiPropertyValueNameToNumber ()  #####
' #############################################
'
'
FUNCTION  XuiPropertyValueNameToNumber (property$, value$, value)
'
	n$ = TRIM$(LCASE$(property$))
	return = $$FALSE
'
	SELECT CASE n$
		CASE "focusbackground"	: GOSUB Color
		CASE "focusdrawing"			: GOSUB Color
		CASE "focuslowlight"		: GOSUB Color
		CASE "focushighlight"		: GOSUB Color
		CASE "focusdull"				: GOSUB Color
		CASE "focusaccent"			: GOSUB Color
		CASE "focuslowtext"			: GOSUB Color
		CASE "focushightext"		: GOSUB Color
		CASE "backgroundcolor"	: GOSUB Color
		CASE "drawingcolor"			: GOSUB Color
		CASE "lowlightcolor"		: GOSUB Color
		CASE "highlightcolor"		: GOSUB Color
		CASE "dullcolor"				: GOSUB Color
		CASE "accentcolor"			: GOSUB Color
		CASE "lowtextcolor"			: GOSUB Color
		CASE "hightextcolor"		: GOSUB Color
		CASE "align"						: GOSUB Align
		CASE "justify"					: GOSUB Justify
		CASE "texture"					: GOSUB Texture
		CASE "border"						: GOSUB Border
		CASE "borderup"					: GOSUB Border
		CASE "borderdown"				: GOSUB Border
		CASE "can"							: GOSUB Can
		CASE ELSE								: value = XLONG (value$)
	END SELECT
	RETURN (return)
'
'
' *****  Align  *****
'
SUB Align
	return = XuiAlignNameToNumber (@value$, @value)
END SUB
'
'
' *****  Border  *****
'
SUB Border
	return = XgrBorderNameToNumber (@value$, @value)
END SUB
'
'
' *****  Can  *****
'
SUB Can
	return = XuiCanNameToNumber (@value$, @value)
END SUB
'
'
' *****  Color  *****
'
SUB Color
	return = XgrColorNameToNumber (@value$, @value)
END SUB
'
'
' *****  Justify  *****
'
SUB Justify
	return = XuiJustifyNameToNumber (@value$, @value)
END SUB
'
'
' *****  Texture  *****
'
SUB Texture
	return = XuiTextureNameToNumber (@value$, @value)
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiCreateGrid ()  #####
' ##############################
'
' NOTE: Negative grid types to XgrCreateGrid() and XuiCreateGrid()
'				create grids in the disabled state.  They can be enabled
'				later with XgrSetGridState (grid, $$TRUE) or #Enable.
'
FUNCTION  XuiCreateGrid (grid, gt, x, y, width, height, window, parent, func)
	SHARED	imbedded
	SHARED	defaultFont
	SHARED	window[]
	SHARED	help$[]
	SHARED	hint$[]
	SHARED	image$[]
	SHARED	kids[]
	SHARED	array[]
	SHARED	values[]
	SHARED	tabArray[]
	SHARED	textArray$[]
	SHARED	textString$[]
	SHARED	upperGrid
	SHARED	upperWindow
	SHARED	gridMessageFunc[]
	SHARED  MENUENTRY  menuentry[]
	SHARED	WINDOW	windowInfo[]
	SHARED	CALLBACK  callback[]
	SHARED	GRID  gridType[]
	SHARED	GRID  grid[]
	SHARED	gridName$[]
	SHARED	gridType$[]
	SHARED	gridFunc$[]
	SHARED	gridTypeName$[]
	SHARED	gridTypeFunc$[]
	SHARED  property$[]
	STATIC	CALLBACK	zero
	STATIC	GRID  proto
'
	gridType = gt
	grid = 0 : f = func : state = $$TRUE
	IF (gridType < 0) THEN gridType = -gridType : state = $$FALSE
	IF (gridType < 0) THEN PRINT "XuiCreateGrid() : (gridType < 0)" : grid = 0 : RETURN
	IF (window > UBOUND(window[])) THEN PRINT "XuiCreateGrid() : error : (window > upperWindow)" : grid = 0 : RETURN
	IFZ windowInfo[window].window THEN PRINT "XuiCreateGrid() : error : (no such window)" : grid = 0 : RETURN
	IF (gridType > UBOUND(gridType[])) THEN PRINT "XuiCreateGrid() : error : (gridType > upperGridType)" : grid = 0 : RETURN
	IF ((parent < 0) OR (parent > upperGrid)) THEN PRINT "XuiCreateGrid() : error : (bad parent)" : grid = 0 : RETURN
'
	XgrCreateGrid (@grid, gt, x, y, width, height, window, parent, func)
	IF (grid <= 0) THEN PRINT "XuiCreateGrid() : (grid <= 0)" : grid = 0 : RETURN
'
	IF (grid > upperGrid) THEN
		upperGrid = (grid + 256) OR 255
		REDIM grid[upperGrid]
		REDIM help$[upperGrid]
		REDIM hint$[upperGrid]
		REDIM image$[upperGrid]
		REDIM gridName$[upperGrid]
		REDIM gridType$[upperGrid]
		REDIM gridFunc$[upperGrid]
		REDIM kids[upperGrid, ]
		REDIM array[upperGrid, ]
		REDIM values[upperGrid, ]
		REDIM callback[upperGrid]
		REDIM tabArray[upperGrid, ]
		REDIM menuentry[upperGrid, ]
		REDIM textString$[upperGrid]
		REDIM textArray$[upperGrid, ]
		REDIM gridMessageFunc[upperGrid, ]
	END IF
'
	IF grid[grid].grid THEN
		PRINT "XuiCreateGrid() : error : (grid number)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF gridMessageFunc[grid, ] THEN
		PRINT "XuiCreateGrid() : error : (gridMessageFunc[grid,] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF help$[grid] THEN
		PRINT "XuiCreateGrid() : error : (help$[grid] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF hint$[grid] THEN
		PRINT "XuiCreateGrid() : error : (hint$[grid] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF image$[grid] THEN
		PRINT "XuiCreateGrid() : error : (image$[grid] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF kids[grid, ] THEN
		PRINT "XuiCreateGrid() : error : (kids[grid,] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF array[grid, ] THEN
		PRINT "XuiCreateGrid() : error : (array[grid,] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF values[grid,] THEN
		PRINT "XuiCreateGrid() : error : (values[grid,] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF callback[grid].grid THEN
		PRINT "XuiCreateGrid() : error : (callback[grid].grid != 0)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF textString$[grid] THEN
		PRINT "XuiCreateGrid() : error : (textString$[grid] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF textArray$[grid, ] THEN
		PRINT "XuiCreateGrid() : error : (textArray$[grid,] not empty)"
		XgrDestroyGrid (grid)
		RETURN
	END IF
'
	IF parent THEN GOSUB AddKidToParent ELSE GOSUB AddParentToWindow
	DIM temp[3] : SWAP values[grid, ], temp[] : DIM temp[]
'
	proto							= gridType[gridType]
	gridFunc$					= gridTypeFunc$[gridType]
	gridType$					= gridTypeName$[gridType]
	gridName$[grid]		= gridType$ + STRING$(grid)
	gridType$[grid]		= gridType$
	gridFunc$[grid] 	= gridFunc$
	help$[grid]				= ""
	hint$[grid]				= ""
	image$[grid]			= ""
	proto.whomask			= $$FALSE
	IF ##WHOMASK THEN proto.whomask = $$TRUE
	proto.window			= window
	proto.parent			= parent
	proto.grid				= grid
	proto.font				= defaultFont
	proto.state				= state
	proto.mouse				= $$TRUE
	proto.redraw			= $$TRUE
	proto.keyboard		= $$TRUE
	grid[grid]				= proto
	XgrSetGridFont (grid, defaultFont)
	XgrSetGridBorder (grid, proto.border, proto.borderUp, proto.borderDown, proto.borderFlags)
	XgrSetGridColors (grid, proto.backgroundColor, proto.drawingColor, proto.lowlightColor, proto.highlightColor, proto.dullColor, proto.accentColor, proto.lowtextColor, proto.hightextColor)
	RETURN
'
'
' *****  AddParentToWindow  *****
'
SUB AddParentToWindow
	IFZ window[window, ] THEN PRINT "XuiCreateGrid() : AddParentToWindow : error : (window[window,] is empty)" : EXIT SUB
	maxGrid = UBOUND(window[window, ])
	FOR i = 0 TO maxGrid
		g = window[window,i]
		IF (g = grid) THEN
			PRINT "XuiCreateGrid() : AddParentToWindow : error : (grid already in window[window, ])" : RETURN
		END IF
		IFZ g THEN EXIT FOR
	NEXT i
	IF (i > maxGrid) THEN
		ATTACH window[window, ] TO temp[]
		maxGrid = maxGrid + 16
		REDIM temp[maxGrid]
		ATTACH temp[] TO window[window, ]
	END IF
	window[window,i] = grid
'
' comment out the following test code eventually
'
	IF kids[grid, ] THEN
		FOR i = 0 TO UBOUND(kids[grid,])
			IF kids[grid,i] THEN PRINT "XuiCreateGrid() : AddParentToWindow : error ::: (ErrantKid #"; kids[grid,i]; ")"
		NEXT i
	END IF
END SUB
'
'
' *****  AddKidToParent  *****
'
SUB AddKidToParent
	IF (parent > upperGrid) THEN PRINT "XuiCreateGrid() : AddKidToParent : error : (parent > upperGrid)" : EXIT SUB
	IFZ kids[parent, ] THEN
		DIM temp[7]
		temp[0] = parent
		temp[1] = grid
		ATTACH temp[] TO kids[parent, ]
	ELSE
		IF (kids[parent, 0] != parent) THEN PRINT "XuiCreateGrid() : AddKidToParent: Error1" : EXIT SUB
		upper = UBOUND(kids[parent, ])
		FOR i = 0 TO upper
			IFZ kids[parent,i] THEN kids[parent,i] = grid : EXIT SUB
		NEXT i
		entry = upper + 1
		upper = upper + 8
		ATTACH kids[parent, ] TO temp[]
		REDIM temp[upper]
		ATTACH temp[] TO kids[parent, ]
		kids[parent,i] = grid
	END IF
END SUB
END FUNCTION
'
'
' ####################################
' #####  XuiGetDefaultColors ()  #####
' ####################################
'
FUNCTION  XuiGetDefaultColors (back, draw, low, high, dull, acc, lowtext, hightext)
	SHARED	backgroundColor
	SHARED	drawingColor
	SHARED	lowlightColor
	SHARED	highlightColor
	SHARED	accentColor
	SHARED	dullColor
	SHARED	lowtextColor
	SHARED	hightextColor
'
	back			= backgroundColor
	draw			= drawingColor
	low				= lowlightColor
	high			= highlightColor
	dull			= dullColor
	acc				= accentColor
	lowtext		= lowtextColor
	hightext	= hightextColor
END FUNCTION
'
'
' ####################################
' #####  XuiGetDefaultCursor ()  #####
' ####################################
'
FUNCTION  XuiGetDefaultCursor (cursor)
	cursor = #defaultCursor
END FUNCTION
'
'
' ##############################################
' #####  XuiGetDefaultMessageFuncArray ()  #####
' ##############################################
'
FUNCTION  XuiGetDefaultMessageFuncArray (func[])
'
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
	DIM func[upperMessage+31]
'
'	func[#Callback]								= &XuiCallback ()
	func[#CloseWindow]						= &XuiCloseWindow ()
	func[#CreateValueArray]				= &XuiCreateValueArray ()
	func[#Destroy]								= &XuiDestroy ()
	func[#DestroyWindow]					= &XuiDestroyWindow ()
	func[#Disable]								= &XuiDisable ()
	func[#Displayed]							= &XuiDisplayed ()
	func[#DisplayWindow]					= &XuiDisplayWindow ()
	func[#Enable]									= &XuiEnable ()
	func[#GetAlign]								= &XuiGetAlign ()
	func[#GetBorder]							= &XuiGetBorder ()
	func[#GetBorderOffset]				= &XuiGetBorderOffset ()
	func[#GetCallback]						= &XuiGetCallback ()
	func[#GetCharacterMapArray]		= &XuiGetCharacterMapArray ()
	func[#GetCharacterMapEntry]		= &XuiGetCharacterMapEntry ()
	func[#GetColor]								= &XuiGetColor ()
	func[#GetColorExtra]					= &XuiGetColorExtra ()
	func[#GetCursor]							= &XuiGetCursor ()
	func[#GetFocusColor]					= &XuiGetFocusColor ()
	func[#GetFocusColorExtra]			= &XuiGetFocusColorExtra ()
	func[#GetFont]								= &XuiGetFont ()
	func[#GetFontMetrics]					= &XuiGetFontMetrics ()
	func[#GetFontNumber]					= &XuiGetFontNumber ()
	func[#GetGridFunction]				= &XuiGetGridFunction ()
	func[#GetGridFunctionName]		= &XuiGetGridFunctionName ()
	func[#GetGridName]						= &XuiGetGridName ()
	func[#GetGridNumber]					= &XuiGetGridNumber ()
	func[#GetGridProperties]			= &XuiGetGridProperties ()
	func[#GetGridType]						= &XuiGetGridType ()
	func[#GetGridTypeName]				= &XuiGetGridTypeName ()
	func[#GetGroup]								= &XuiGetGroup ()
	func[#GetHelp]								= &XuiGetHelp ()
	func[#GetHelpFile]						= &XuiGetHelpFile ()
	func[#GetHelpString]					= &XuiGetHelpString ()
	func[#GetHelpStrings]					= &XuiGetHelpStrings ()
	func[#GetHintString]					= &XuiGetHintString ()
	func[#GetImage]								= &XuiGetImage ()
	func[#GetImageCoords]					= &XuiGetImageCoords ()
	func[#GetInfo]								= &XuiGetInfo ()
	func[#GetIndent]							= &XuiGetIndent ()
	func[#GetJustify]							= &XuiGetJustify ()
	func[#GetKeyboardFocus]				= &XuiGetKeyboardFocus ()
	func[#GetKeyboardFocusGrid]		= &XuiGetKeyboardFocusGrid ()
	func[#GetKidNumber]						= &XuiGetKidNumber ()
	func[#GetKids]								= &XuiGetKids ()
	func[#GetKidArray]						= &XuiGetKidArray ()
	func[#GetMaxMinSize]					= &XuiGetMaxMinSize ()
	func[#GetMessageFunc]					= &XuiGetMessageFunc ()
	func[#GetMessageFuncArray]		= &XuiGetMessageFuncArray ()
	func[#GetMessageSub]					= &XuiGetMessageSub ()
	func[#GetMessageSubArray]			= &XuiGetMessageSubArray ()
	func[#GetModalInfo]						= &XuiGetModalInfo ()
	func[#GetModalWindow]					= &XuiGetModalWindow ()
	func[#GetParent]							= &XuiGetParent ()
	func[#GetRedrawFlags]					= &XuiGetRedrawFlags ()
	func[#GetSize]								= &XuiGetSize ()
	func[#GetSmallestSize]				= &XuiGetSmallestSize ()
	func[#GetState]								= &XuiGetState ()
	func[#GetStyle]								= &XuiGetStyle ()
	func[#GetTabArray]						= &XuiGetTabArray ()
	func[#GetTabWidth]						= &XuiGetTabWidth ()
	func[#GetTextArray]						= &XuiGetTextArray ()
	func[#GetTextArrayLine]				= &XuiGetTextArrayLine ()
	func[#GetTextArrayLines]			= &XuiGetTextArrayLines ()
	func[#GetTextFilename]				= &XuiGetTextFilename ()
	func[#GetTextSpacing]					= &XuiGetTextSpacing ()
	func[#GetTextString]					= &XuiGetTextString ()
	func[#GetTextStrings]					= &XuiGetTextStrings ()
	func[#GetTexture]							= &XuiGetTexture ()
	func[#GetTimer]								= &XuiGetTimer ()
	func[#GetValue]								= &XuiGetValue ()
	func[#GetValues]							= &XuiGetValues ()
	func[#GetValueArray]					= &XuiGetValueArray ()
	func[#GetWindow]							= &XuiGetWindow ()
	func[#GetWindowGrid]					= &XuiGetWindowGrid ()
	func[#GetWindowIcon]					= &XuiGetWindowIcon ()
	func[#GetWindowSize]					= &XuiGetWindowSize ()
	func[#GetWindowTitle]					= &XuiGetWindowTitle ()
	func[#GotKeyboardFocus]				= &XuiGotKeyboardFocus ()
	func[#GrabArray]							= &XuiGrabArray ()
	func[#GrabTextArray]					= &XuiGrabTextArray ()
	func[#GrabTextString]					= &XuiGrabTextString ()
	func[#GrabValueArray]					= &XuiGrabValueArray ()
	func[#Hidden]									= &XuiHidden ()
	func[#HideWindow]							= &XuiHideWindow ()
	func[#Initialize]							= &XuiInitialize ()
	func[#KeyboardFocusBackward]	= &XuiKeyboardFocusBackward ()
	func[#KeyboardFocusForward]		= &XuiKeyboardFocusForward ()
	func[#LostKeyboardFocus]			= &XuiLostKeyboardFocus ()
	func[#Maximized]							= &XuiMaximized ()
	func[#MaximizeWindow]					= &XuiMaximizeWindow ()
	func[#Minimized]							= &XuiMinimized ()
	func[#MinimizeWindow]					= &XuiMinimizeWindow ()
	func[#MouseDown]							= &XuiMouseDownSetKeyboardFocus ()
	func[#MouseEnter]							= &XuiMouseEnter ()
	func[#PokeArray]							= &XuiPokeArray ()
	func[#PokeTextArray]					= &XuiPokeTextArray ()
	func[#PokeTextString]					= &XuiPokeTextString ()
	func[#PokeValueArray]					= &XuiPokeValueArray ()
	func[#Redraw]									= &XuiRedraw ()
	func[#RedrawGrid]							= &XuiRedrawGrid ()
	func[#RedrawWindow]						= &XuiRedrawWindow ()
	func[#Resize]									= &XuiResize ()
	func[#ResizeNot]							= &XuiResizeNot ()
	func[#ResizeWindow]						= &XuiResizeWindow ()
	func[#ResizeWindowToGrid]			= &XuiResizeWindowToGrid ()
	func[#SetAlign]								= &XuiSetAlign ()
	func[#SetBorder]							= &XuiSetBorder ()
	func[#SetBorderOffset]				= &XuiSetBorderOffset ()
	func[#SetCallback]						= &XuiSetCallback ()
	func[#SetCharacterMapArray]		= &XuiSetCharacterMapArray ()
	func[#SetCharacterMapEntry]		= &XuiSetCharacterMapEntry ()
	func[#SetColor]								= &XuiSetColor ()
	func[#SetColorAll]						= &XuiSetColorAll ()
	func[#SetColorExtra]					= &XuiSetColorExtra ()
	func[#SetColorExtraAll]				= &XuiSetColorExtraAll ()
	func[#SetCursor]							= &XuiSetCursor ()
	func[#SetFocusColor]					= &XuiSetFocusColor ()
	func[#SetFocusColorExtra]			= &XuiSetFocusColorExtra ()
	func[#SetFont]								= &XuiSetFont ()
	func[#SetFontNumber]					= &XuiSetFontNumber ()
	func[#SetGridFunction]				= &XuiSetGridFunction ()
	func[#SetGridFunctionName]		= &XuiSetGridFunctionName ()
	func[#SetGridName]						= &XuiSetGridName ()
	func[#SetGridProperties]			= &XuiSetGridProperties ()
	func[#SetGridType]						= &XuiSetGridType ()
	func[#SetGridTypeName]				= &XuiSetGridTypeName ()
	func[#SetGroup]								= &XuiSetGroup ()
	func[#SetHelp]								= &XuiSetHelp ()
	func[#SetHelpFile]						= &XuiSetHelpFile ()
	func[#SetHelpString]					= &XuiSetHelpString ()
	func[#SetHelpStrings]					= &XuiSetHelpStrings ()
	func[#SetHintString]					= &XuiSetHintString ()
	func[#SetImage]								= &XuiSetImage ()
	func[#SetImageCoords]					= &XuiSetImageCoords ()
	func[#SetIndent]							= &XuiSetIndent ()
	func[#SetInfo]								= &XuiSetInfo ()
	func[#SetJustify]							= &XuiSetJustify ()
	func[#SetKeyboardFocus]				= &XuiSetKeyboardFocus ()
	func[#SetKeyboardFocusGrid]		= &XuiSetKeyboardFocusGrid ()
	func[#SetKidArray]						= &XuiSetKidArray ()
	func[#SetMaxMinSize]					= &XuiSetMaxMinSize ()
	func[#SetMessageFunc]					= &XuiSetMessageFunc ()
	func[#SetMessageFuncArray]		= &XuiSetMessageFuncArray ()
	func[#SetMessageSub]					= &XuiSetMessageSub ()
	func[#SetMessageSubArray]			= &XuiSetMessageSubArray ()
	func[#SetModalWindow]					= &XuiSetModalWindow ()
	func[#SetRedrawFlags]					= &XuiSetRedrawFlags ()
	func[#SetSize]								= &XuiSetSize ()
	func[#SetState]								= &XuiSetState ()
	func[#SetStyle]								= &XuiSetStyle ()
	func[#SetTabArray]						= &XuiSetTabArray ()
	func[#SetTabWidth]						= &XuiSetTabWidth ()
	func[#SetTextArray]						= &XuiSetTextArray ()
	func[#SetTextArrayLine]				= &XuiSetTextArrayLine ()
	func[#SetTextArrayLines]			= &XuiSetTextArrayLines ()
	func[#SetTextFilename]				= &XuiSetTextFilename ()
	func[#SetTextSpacing]					= &XuiSetTextSpacing ()
	func[#SetTextString]					= &XuiSetTextString ()
	func[#SetTextStrings]					= &XuiSetTextStrings ()
	func[#SetTexture]							= &XuiSetTexture ()
	func[#SetTimer]								= &XuiSetTimer ()
	func[#SetWindowIcon]					= &XuiSetWindowIcon ()
	func[#SetWindowTitle]					= &XuiSetWindowTitle ()
	func[#SetValue]								= &XuiSetValue ()
	func[#SetValues]							= &XuiSetValues ()
	func[#SetValueArray]					= &XuiSetValueArray ()
	func[#ShowWindow]							= &XuiShowWindow ()
	func[#StartTimer]							= &XuiStartTimer ()
	func[#SystemMessage]					= &XuiSystemMessage ()
	IF func[0] THEN PRINT "XuiGetDefaultMessageFuncArray() : error : (one or more messages = 0)"
END FUNCTION
'
'
' #################################
' #####  XuiGetGridRegion ()  #####
' #################################
'
FUNCTION  XuiGetGridRegion (grid, x, y, region, cursor, default)
	SHARED	GRID	grid[]
'
	region = 0
	cursor = 0
	default = #cursorArrow
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
'
	SELECT CASE TRUE
		CASE (x < x1): RETURN
		CASE (x > x2): RETURN
		CASE (y < y1): RETURN
		CASE (y > y2): RETURN
	END SELECT
'
	IF (x < (x1 + 5)) THEN gotLeft = $$TRUE
	IF (y < (y1 + 5)) THEN gotTop = $$TRUE
	IF (x > (x2 - 5)) THEN gotRight = $$TRUE
	IF (y > (y2 - 5)) THEN gotBottom = $$TRUE
'
	SELECT CASE TRUE
		CASE gotTop AND gotLeft			: region = 8 : cursor = #cursorArrowsNWSE
		CASE gotTop AND gotRight		: region = 2 : cursor = #cursorArrowsNESW
		CASE gotBottom AND gotLeft	: region = 6 : cursor = #cursorArrowsNESW
		CASE gotBottom AND gotRight	: region = 4 : cursor = #cursorArrowsNWSE
		CASE gotTop									: region = 1 : cursor = #cursorArrowsNS
		CASE gotLeft								: region = 7 : cursor = #cursorArrowsWE
		CASE gotRight								: region = 3 : cursor = #cursorArrowsWE
		CASE gotBottom							: region = 5 : cursor = #cursorArrowsNS
		CASE ELSE										: region = 9 : cursor = #cursorArrowsAll
	END SELECT
END FUNCTION
'
'
' ###################################
' #####  XuiGetGridProperty ()  #####
' ###################################
'
FUNCTION  XuiGetGridProperty (grid, kid, property$, (v, v[], v$, v$[]))
	SHARED	GRID	grid[]
	SHARED	upperGrid
	SHARED  kids[]
'
	IF (kid < 0) THEN PRINT "XuiGetGridProperty() : error : (kid < 0)" : RETURN
	IF (grid < 0) THEN PRINT "XuiGetGridProperty() : error : (grid < 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridProperty() : error : (grid > upperGrid)" : RETURN
	IF (kid > UBOUND (kids[grid,])) THEN PRINT "XuiGetGridProperty() : error : (kid > upperKid)" : RETURN
	IFZ property$ THEN PRINT "XuiGetGridProperty() : error : (property$ is empty)" : RETURN
	g = kids[grid,kid]
	IF (g <= 0) THEN PRINT "XuiGetGridProperty() : error : (grid,kid <= 0)" : RETURN
'
	n$ = LCASE$ (property$)
'
	SELECT CASE n$
		CASE "grid"							: v = grid[g].grid
		CASE "gridtype"					: v = grid[g].gridType
		CASE "gridfunc"					: v = grid[g].gridFunc
		CASE "gridwindow"				: v = grid[g].gridWindow
		CASE "window"						: v = grid[g].window
		CASE "parent"						: v = grid[g].parent
		CASE "cursor"						: v = grid[g].cursor
		CASE "clip"							: v = grid[g].clip
		CASE "image"						: v = grid[g].image
		CASE "imagealign"				: v = grid[g].imageAlign
		CASE "imageindentx"			: v = grid[g].imageIndentX
		CASE "imageindenty"			: v = grid[g].imageIndentY
		CASE "imagestartx"			: v = grid[g].imageStartX
		CASE "imagestarty"			: v = grid[g].imageStartY
		CASE "imagewidth"				: v = grid[g].imageWidth
		CASE "imageheight"			: v = grid[g].imageHeight
		CASE "x"								: v = grid[g].x
		CASE "y"								: v = grid[g].y
		CASE "width"						: v = grid[g].width
		CASE "height"						: v = grid[g].height
		CASE "maxwidth"					: v = grid[g].maxWidth
		CASE "maxheight"				: v = grid[g].maxHeight
		CASE "minwidth"					: v = grid[g].minWidth
		CASE "minheight"				: v = grid[g].minHeight
		CASE "focusbackground"	: v = grid[g].focusBackground
		CASE "focusdrawing"			: v = grid[g].focusDrawing
		CASE "focuslowlight"		: v = grid[g].focusLowlight
		CASE "focushighlight"		: v = grid[g].focusHighlight
		CASE "focusdull"				: v = grid[g].focusDull
		CASE "focusaccent"			: v = grid[g].focusAccent
		CASE "focuslowtext"			: v = grid[g].focusLowtext
		CASE "focushightext"		: v = grid[g].focusHightext
		CASE "backgroundcolor"	: v = grid[g].backgroundColor
		CASE "drawingcolor"			: v = grid[g].drawingColor
		CASE "lowlightcolor"		: v = grid[g].lowlightColor
		CASE "highlightcolor"		: v = grid[g].highlightColor
		CASE "dullcolor"				: v = grid[g].dullColor
		CASE "accentcolor"			: v = grid[g].accentColor
		CASE "lowtextcolor"			: v = grid[g].lowtextColor
		CASE "hightextcolor"		: v = grid[g].hightextColor
		CASE "cursorx"					: v = grid[g].cursorX
		CASE "cursory"					: v = grid[g].cursorY
		CASE "cursorpos"				: v = grid[g].cursorPos
		CASE "cursorline"				: v = grid[g].cursorLine
		CASE "left"							: v = grid[g].left
		CASE "top"							: v = grid[g].top
		CASE "right"						: v = grid[g].right
		CASE "bottom"						: v = grid[g].bottom
		CASE "redrawflags"			: v = grid[g].redrawFlags
		CASE "buffer"						: v = grid[g].buffer
		CASE "timer"						: v = grid[g].timer
		CASE "font"							: v = grid[g].font
		CASE "indentleft"				: v = grid[g].indentLeft
		CASE "indenttop"				: v = grid[g].indentTop
		CASE "indentright"			: v = grid[g].indentRight
		CASE "indentbottom"			: v = grid[g].indentBottom
		CASE "style"						: v = grid[g].style
		CASE "stylemax"					: v = grid[g].styleMax
		CASE "align"						: v = grid[g].align
		CASE "justify"					: v = grid[g].justify
		CASE "texture"					: v = grid[g].texture
		CASE "tabwidth"					: v = grid[g].tabWidth
		CASE "border"						: v = grid[g].border
		CASE "borderup"					: v = grid[g].borderUp
		CASE "borderdown"				: v = grid[g].borderDown
		CASE "borderflags"			: v = grid[g].borderFlags
		CASE "group"						: v = grid[g].group
		CASE "xgap"							: v = grid[g].xgap
		CASE "ygap"							: v = grid[g].ygap
		CASE "zzz"							: v = grid[g].zzz
		CASE "can"							: v = grid[g].can
		CASE "kind"							: v = grid[g].kind
		CASE "focus"						: v = grid[g].focus
		CASE "focuskid"					: v = grid[g].focusKid
		CASE "inputtextarray"		: v = grid[g].inputTextArray
		CASE "inputtextstring"	: v = grid[g].inputTextString
		CASE "selectable"				: v = grid[g].selectable
		CASE "whomask"					: v = grid[g].whomask
		CASE "state"						: v = grid[g].state
		CASE "keyboard"					: v = grid[g].keyboard
		CASE "mouse"						: v = grid[g].mouse
		CASE "redraw"						: v = grid[g].redraw
		CASE ELSE								: PRINT "XuiGetGridProperty() : error ::: (unknown property name)"
	END SELECT
END FUNCTION
'
'
' ####################################
' #####  XuiGetGridTypeGrids ()  #####
' ####################################
'
FUNCTION  XuiGetGridTypeGrids (gridType, @g[])
	SHARED  GRID  grid[]
'
	DIM g[]
	IF (gridType < 0) THEN RETURN ($$TRUE)
'
	u = 255
	DIM g[u]
	upper = UBOUND (grid[])
'
	entry = -1
	FOR i = 1 TO upper
		IF (gridType = grid[i].gridType) THEN
			INC entry
			IF (entry > u) THEN
				u = u + 255
				REDIM g[u]
			END IF
			g[entry] = i
		END IF
	NEXT i
'
	IF (entry < 0) THEN DIM g[] ELSE REDIM g[entry]
END FUNCTION
'
'
' ###############################################
' #####  XuiGetGridTypeMessageFuncArray ()  #####
' ###############################################
'
FUNCTION  XuiGetGridTypeMessageFuncArray (gridType, func[])
	SHARED	gridTypeMessageFunc[]
	SHARED	upperGridType
'
	IF (gridType < 0) THEN PRINT "XuiGetGridTypeMessageFuncArray() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "XuiGetGridTypeMessageFuncArray() : error : (gridType > upperGrid)" : RETURN
'
	DIM func[]
	IF gridTypeMessageFunc[gridType, ] THEN
		upper = UBOUND (gridTypeMessageFunc[gridType, ])
		DIM func[upper]
		FOR i = 0 TO upper
			func[i] = gridTypeMessageFunc[gridType,i]
		NEXT i
	END IF
END FUNCTION
'
'
' ##############################################
' #####  XuiGetGridTypeMessageSubArray ()  #####
' ##############################################
'
FUNCTION  XuiGetGridTypeMessageSubArray (gridType, SUBADDR sub[])
	SHARED	messageSub[]
	SHARED	upperGridType
'
	IF (gridType < 0) THEN PRINT "XuiGetGridTypeMessageSubArray() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "XuiGetGridTypeMessageSubArray() : error : (gridType > upperGrid)" : RETURN
'
	DIM sub[]
	IF messageSub[gridType, ] THEN
		upper = UBOUND (messageSub[gridType, ])
		DIM sub[upper]
		FOR i = 0 TO upper
			sub[i] = messageSub[gridType,i]
		NEXT i
	END IF
END FUNCTION
'
'
' #######################################
' #####  XuiGetGridTypeProperty ()  #####
' #######################################
'
FUNCTION  XuiGetGridTypeProperty (gridType, property$, value)
	SHARED	GRID	gridType[]
	SHARED	upperGridType
'
	IF (gridType < 0) THEN PRINT "XuiGetGridTypeProperty() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "XuiGetGridTypeProperty() : error : (gridType > upperGridType)" : RETURN
	IFZ property$ THEN PRINT "XuiGetGridTypeProperty() : error : (property$ is empty)" : RETURN
'
	n$ = LCASE$ (property$)
'
	SELECT CASE n$
		CASE "grid"							: value = gridType[gridType].grid
		CASE "gridtype"					: value = gridType[gridType].gridType
		CASE "gridfunc"					: value = gridType[gridType].gridFunc
		CASE "gridwindow"				: value = gridType[gridType].gridWindow
		CASE "window"						: value = gridType[gridType].window
		CASE "parent"						: value = gridType[gridType].parent
		CASE "cursor"						: value = gridType[gridType].cursor
		CASE "clip"							: value = gridType[gridType].clip
		CASE "image"						: value = gridType[gridType].image
		CASE "imagealign"				: value = gridType[gridType].imageAlign
		CASE "imageindentx"			: value = gridType[gridType].imageIndentX
		CASE "imageindenty"			: value = gridType[gridType].imageIndentY
		CASE "imagestartx"			: value = gridType[gridType].imageStartX
		CASE "imagestarty"			: value = gridType[gridType].imageStartY
		CASE "imagewidth"				: value = gridType[gridType].imageWidth
		CASE "imageheight"			: value = gridType[gridType].imageHeight
		CASE "x"								: value = gridType[gridType].x
		CASE "y"								: value = gridType[gridType].y
		CASE "width"						: value = gridType[gridType].width
		CASE "height"						: value = gridType[gridType].height
		CASE "maxwidth"					: value = gridType[gridType].maxWidth
		CASE "maxheight"				: value = gridType[gridType].maxHeight
		CASE "minwidth"					: value = gridType[gridType].minWidth
		CASE "minheight"				: value = gridType[gridType].minHeight
		CASE "focusbackground"	: value = gridType[gridType].focusBackground
		CASE "focusdrawing"			: value = gridType[gridType].focusDrawing
		CASE "focuslowlight"		: value = gridType[gridType].focusLowlight
		CASE "focushighlight"		: value = gridType[gridType].focusHighlight
		CASE "focusdull"				: value = gridType[gridType].focusDull
		CASE "focusaccent"			: value = gridType[gridType].focusAccent
		CASE "focuslowtext"			: value = gridType[gridType].focusLowtext
		CASE "focushightext"		: value = gridType[gridType].focusHightext
		CASE "backgroundcolor"	: value = gridType[gridType].backgroundColor
		CASE "drawingcolor"			: value = gridType[gridType].drawingColor
		CASE "lowlightcolor"		: value = gridType[gridType].lowlightColor
		CASE "highlightcolor"		: value = gridType[gridType].highlightColor
		CASE "dullcolor"				: value = gridType[gridType].dullColor
		CASE "accentcolor"			: value = gridType[gridType].accentColor
		CASE "lowtextcolor"			: value = gridType[gridType].lowtextColor
		CASE "hightextcolor"		: value = gridType[gridType].hightextColor
		CASE "cursorx"					: value = gridType[gridType].cursorX
		CASE "cursory"					: value = gridType[gridType].cursorY
		CASE "cursorpos"				: value = gridType[gridType].cursorPos
		CASE "cursorline"				: value = gridType[gridType].cursorLine
		CASE "left"							: value = gridType[gridType].left
		CASE "top"							: value = gridType[gridType].top
		CASE "right"						: value = gridType[gridType].right
		CASE "bottom"						: value = gridType[gridType].bottom
		CASE "redrawflags"			: value = gridType[gridType].redrawFlags
		CASE "buffer"						: value = gridType[gridType].buffer
		CASE "timer"						: value = gridType[gridType].timer
		CASE "font"							: value = gridType[gridType].font
		CASE "indentleft"				: value = gridType[gridType].indentLeft
		CASE "indenttop"				: value = gridType[gridType].indentTop
		CASE "indentright"			: value = gridType[gridType].indentRight
		CASE "indentbottom"			: value = gridType[gridType].indentBottom
		CASE "style"						: value = gridType[gridType].style
		CASE "stylemax"					: value = gridType[gridType].styleMax
		CASE "align"						: value = gridType[gridType].align
		CASE "justify"					: value = gridType[gridType].justify
		CASE "texture"					: value = gridType[gridType].texture
		CASE "tabwidth"					: value = gridType[gridType].tabWidth
		CASE "border"						: value = gridType[gridType].border
		CASE "borderup"					: value = gridType[gridType].borderUp
		CASE "borderdown"				: value = gridType[gridType].borderDown
		CASE "borderflags"			: value = gridType[gridType].borderFlags
		CASE "group"						: value = gridType[gridType].group
		CASE "xgap"							: value = gridType[gridType].xgap
		CASE "ygap"							: value = gridType[gridType].ygap
		CASE "zzz"							: value = gridType[gridType].zzz
		CASE "can"							: value = gridType[gridType].can
		CASE "kind"							: value = gridType[gridType].kind
		CASE "focus"						: value = gridType[gridType].focus
		CASE "focuskid"					: value = gridType[gridType].focusKid
		CASE "inputtextarray"		: value = gridType[gridType].inputTextArray
		CASE "inputtextstring"	: value = gridType[gridType].inputTextString
		CASE "selectable"				: value = gridType[gridType].selectable
		CASE "whomask"					: value = gridType[gridType].whomask
		CASE "state"						: value = gridType[gridType].state
		CASE "keyboard"					: value = gridType[gridType].keyboard
		CASE "mouse"						: value = gridType[gridType].mouse
		CASE "redraw"						: value = gridType[gridType].redraw
		CASE ELSE								: PRINT "XuiGetGridTypeProperty() : error ::: (unknown property name)"
	END SELECT
END FUNCTION
'
'
' ####################################
' #####  XuiGetGridTypeValue ()  #####
' ####################################
'
FUNCTION  XuiGetGridTypeValue (gridType, property$, value)
'
	XuiGetGridTypeProperty (gridType, @property$, @value)
END FUNCTION
'
'
' ################################
' #####  XuiGetGridValue ()  #####
' ################################
'
FUNCTION  XuiGetGridValue (grid, property$, value)
'
	XuiGetGridProperty (grid, 0, @property$, @value)
END FUNCTION
'
'
' #####################################
' #####  XuiGetHelpWindowGrid ()  #####
' #####################################
'
FUNCTION  XuiGetHelpWindowGrid (window, grid)
	SHARED	helpWindow
	SHARED	helpGrid
'
	window = helpWindow
	grid = helpGrid
END FUNCTION
'
'
' #######################################
' #####  XuiGetPropertyDatabase ()  #####
' #######################################
'
FUNCTION  XuiGetPropertyDatabase (text$[])
	SHARED  property$[]
'
	DIM text$[]
	IFZ property$[] THEN RETURN
	upper = UBOUND (property$[])
	DIM text$[upper]
'
	FOR i = 0 TO upper
		text$[i] = property$[i]
	NEXT i
END FUNCTION
'
'
' ####################################
' #####  XuiGetTextArraySize ()  #####
' ####################################
'
FUNCTION  XuiGetTextArraySize (text$[], font, w, h, width, height, extraX, extraY)
'
	empty = $$FALSE
	IFZ text$[] THEN GOSUB Empty
'
	found = $$FALSE
	upper = UBOUND (text$[])
	FOR i = upper TO 0 STEP -1
		IF text$[i] THEN
			found = $$TRUE
			final = i
			EXIT FOR
		END IF
	NEXT i
'
	IFZ found THEN GOSUB Empty
'
	IF (final < upper) THEN
		REDIM text$[final]
		upper = final
	END IF
'
	XgrGetFontInfo (font, @name$, @size, @weight, @italic, @angle)
	XgrGetTextImageSize (font, @"W", 0, 0, @ww, @hh, @gg, @ss)
	ww = ww + extraX
	hh = hh + extraY
'
	width = 0
	height = 0
	FOR i = 0 TO upper
		IFZ text$[i] THEN
			width = MAX (width, ww)
			height = height + hh
		ELSE
			text$ = text$[i]
			XgrGetTextImageSize (font, @text$, 0, 0, @w, @h, @g, @s)
			w = w + extraX : h = h + extraY
			width = MAX (width, w)
			height = height + h
		END IF
	NEXT i
'
	w = width
	h = height
	IFZ angle THEN
		IF empty THEN DIM text$[]
		RETURN
	END IF
'
' Now take angle into account
'
	w# = width >> 1									' w# = 1/2 width
	h# = height >> 1								' h# = 1/2 height
	r# = SQRT (w#*w# + h#*h#)				' r# = radius of text box
	a# = angle * .1# * $$DEGTORAD		' a# = tilt angle in radians
	na# = ASIN (h# / r#)						' na# = natural angle to corner
	ax = r# * COS (a# - na# + $$PI)	' final x coord of upper-left corner
	ay = r# * SIN (a# - na# + $$PI)	' final y coord of upper-left corner
	bx = r# * COS (a# + na#)				' final x coord of upper-right corner
	by = r# * SIN (a# + na#)				' final y coord of upper-right corner
	cx = r# * COS (a# + na# + $$PI)	' final x coord of lower-left corner
	cy = r# * SIN (a# + na# + $$PI)	' final y coord of lower-left corner
	dx = r# * COS (a# - na#)				' final x coord of lower-right corner
	dy = r# * SIN (a# - na#)				' final y coord of lower-right corner
'
' Find highest and lowest x and y values
'
	minX = +r#
	minY = +r#
	maxX = -r#
	maxY = -r#
'
	IF (ax < minX) THEN minX = ax
	IF (bx < minX) THEN minX = bx
	IF (cx < minX) THEN minX = cx
	IF (dx < minX) THEN minX = dx
	IF (ax > maxX) THEN maxX = ax
	IF (bx > maxX) THEN maxX = bx
	IF (cx > maxX) THEN maxX = cx
	IF (dx > maxX) THEN maxX = dx
	IF (ay < minY) THEN minY = ay
	IF (by < minY) THEN minY = by
	IF (cy < minY) THEN minY = cy
	IF (dy < minY) THEN minY = dy
	IF (ay > maxY) THEN maxY = ay
	IF (by > maxY) THEN maxY = by
	IF (cy > maxY) THEN maxY = cy
	IF (dy > maxY) THEN maxY = dy
'
	width = maxX - minX + 1
	height = maxY - minY + 1
	IF empty THEN DIM text$[]
	RETURN
'
'
' *****  Empty  *****
'
SUB Empty
	empty = $$TRUE
	DIM text$[0]
	text$[0] = "W"
END SUB
END FUNCTION
'
'
' #########################################
' #####  XuiGridContainsGridCoord ()  #####
' #########################################
'
FUNCTION  XuiGridContainsGridCoord (grid, messageGrid, x, y, xx, yy)
'
	XgrConvertLocalToDisplay (messageGrid, x, y, @xDisp, @yDisp)
	XgrConvertDisplayToLocal (grid, xDisp, yDisp, @xx, @yy)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
'
	return = $$FALSE
	IF (xx >= x1) THEN
		IF (xx <= x2) THEN
			IF (yy >= y1) THEN
				IF (yy <= y2) THEN return = $$TRUE
			END IF
		END IF
	END IF
	RETURN (return)
END FUNCTION
'
'
' ######################################
' #####  XuiGridFuncNameToAddr ()  #####
' ######################################
'
FUNCTION  XuiGridFuncNameToAddr (name$, address)
	SHARED	GRID	gridType[]
	SHARED	gridTypeFunc$[]
'
	upper = UBOUND(gridType[])
	FOR i = 0 TO upper
		IF (name$ = gridTypeFunc$[i]) THEN
			address = gridType[i].gridFunc
			EXIT FOR
		END IF
	NEXT i
END FUNCTION
'
'
' ###########################
' #####  XuiGridKid ()  #####
' ###########################
'
FUNCTION  XuiGridKid (grid, other)
	SHARED	upperGrid
	SHARED	kids[]
'
	IF (other <= 0) THEN RETURN ($$FALSE)
	IF (grid <= 0) THEN PRINT "XuiGridKid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGridKid() : error : (grid > upperGrid)" : RETURN
	IF (other > upperGrid) THEN PRINT "XuiGridKid() : error : (other > upperGrid)" : RETURN
'
	IF (grid = other) THEN RETURN ($$TRUE)
	IFZ kids[grid,] THEN RETURN ($$FALSE)
	upper = UBOUND(kids[grid,])
	FOR i = 1 TO upper
		kid = kids[grid,i]
		IF (kid = other) THEN RETURN ($$TRUE)
		IF kid THEN found = XuiGridKid (kid, other)
		IF found THEN RETURN ($$TRUE)
	NEXT i
	RETURN ($$FALSE)
END FUNCTION
'
'
' ######################################
' #####  XuiGridTypeToGridFunc ()  #####
' ######################################
'
FUNCTION  XuiGridTypeToGridFunc (gridType, gridFunc)
	SHARED	GRID	gridType[]
'
	gridFunc = 0
	upper = UBOUND(gridType[])
	IF (gridType <= upper) THEN gridFunc = gridType[gridType].gridFunc
END FUNCTION
'
'
' ###############################
' #####  XuiHelpDisable ()  #####
' ###############################
'
FUNCTION  XuiHelpDisable ()
'
	whomask = ##WHOMASK
	XuiGetHelpWindowGrid (@hw, @hg)
	XuiHelp (hg, #Disable, 0, 0, 0, 0, 0, 0)
	##WHOMASK = whomask
END FUNCTION
'
'
' ##############################
' #####  XuiHelpEnable ()  #####
' ##############################
'
FUNCTION  XuiHelpEnable ()
'
	whomask = ##WHOMASK
	XuiGetHelpWindowGrid (@hw, @hg)
	XuiHelp (hg, #Enable, 0, 0, 0, 0, 0, 0)
	##WHOMASK = whomask
END FUNCTION
'
'
' ##########################
' #####  XuiPassOn ()  #####
' ##########################
'
FUNCTION  XuiPassOn (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (message = #Callback) THEN RETURN
	IF (grid < 0) THEN PRINT "XuiPassOn() : error : (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "XuiPassOn() : error : (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPassOn() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "XuiPassOn() : error ::: (message > upperMessage)"
'
	IF kids[grid, ] THEN
		IF (kids[grid, 0] != grid) THEN PRINT "XuiPassOn() : error : (kids[grid,0] != grid)" : RETURN
		upper = UBOUND (kids[grid, ])
		IF (upper >= 1) THEN
			g = kids[grid, 1]
			func = grid[g].gridFunc
			IF func THEN
				@func (g, message, @v0, @v1, @v2, @v3, @kid, @r1)
			END IF
		END IF
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiPlaceWindow ()  #####
' ###############################
'
FUNCTION  XuiPlaceWindow (window, mode, xDisp, yDisp, width, height)
'
	IF (xDisp < #windowBorderWidth) THEN xDisp = #windowBorderWidth
	IF (yDisp < (#windowBorderWidth + #windowTitleHeight)) THEN yDisp = #windowBorderWidth + #windowTitleHeight
	IF (#displayWidth < (xDisp + width + #windowBorderWidth + #windowBorderWidth)) THEN
		xDisp = #displayWidth - #windowBorderWidth - width
		IF (xDisp < #windowBorderWidth) THEN
			xDisp = #windowBorderWidth
			width = #displayWidth - #windowBorderWidth - #windowBorderWidth
		END IF
	END IF
	IF (#displayHeight < (yDisp + #windowBorderWidth + #windowTitleHeight + height + #windowBorderWidth)) THEN
		yDisp = #displayHeight - #windowBorderWidth - height
		IF (yDisp < (#windowBorderWidth + #windowTitleHeight)) THEN
			yDisp = #windowBorderWidth + #windowTitleHeight
			height = #displayHeight - #windowTitleHeight - #windowBorderWidth - #windowBorderWidth
		END IF
	END IF
END FUNCTION
'
'
' ################################
' #####  XuiPositionGrid ()  #####
' ################################
'
FUNCTION  XuiPositionGrid (grid, x, y, width, height)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (grid <= 0) THEN PRINT "XuiPositionGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPositionGrid() : error : (grid > upperGrid)" : RETURN
'
	IF (x < 0) THEN x = 0
	IF (y < 0) THEN y = 0
	minX = grid[grid].minWidth
	maxX = grid[grid].maxWidth
	minY = grid[grid].minHeight
	maxY = grid[grid].maxHeight
	IF (width < minX) THEN width = minX
	IF (width > maxX) THEN width = maxX
	IF (height < minY) THEN height = minY
	IF (height > maxY) THEN height = maxY
	XgrSetGridPositionAndSize (grid, x, y, width, height)
END FUNCTION
'
'
' ##################################
' #####  XuiProcessMessage ()  #####
' ##################################
'
FUNCTION  XuiProcessMessage (grid, message, v0, v1, v2, v3, kid, r1, gridType)
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	messageSub[]
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	upperGridType
	SHARED	gridType$[]					' one per grid
	SHARED	gridFunc$[]					' one per grid
	SHARED	gridTypeName$[]			' one per grid type
	SHARED	gridTypeFunc$[]			' one per grid type
	SHARED	GRID	grid[]
	SHARED	GRID	gridType[]
	STATIC	GRID	info
	STATIC	e$
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IFZ e$ THEN e$ = "XuiProcessMessage() : error : "
	IF (gridType < 0) THEN
		PRINT e$; "(gridType < 0) : "; gridType
		RETURN ($$XuiError)
	END IF
'
	SELECT CASE message
		CASE #Create				: RETURN ($$FALSE)
		CASE #CreateWindow	: RETURN ($$FALSE)
	END SELECT
'
	IF (grid <= 0) THEN
		IFZ (grid OR message) THEN RETURN ($$FALSE)
		GOSUB ReportFrames
		PRINT e$; "(grid <= 0) to "; gridTypeFunc$[gridType];; grid;; message$; v0; v1; v2; v3; kid; r1; " = "; HEX$(r1); gridType
		RETURN ($$XuiError)
	END IF
'
	IF (grid > upperGrid) THEN
		GOSUB ReportFrames
		PRINT e$; "(grid > upperGrid) to "; gridTypeFunc$[gridType];; grid;; message$; v0; v1; v2; v3; kid; r1; " = "; HEX$(r1); gridType
		RETURN ($$XuiError)
	END IF
'
	IF (message <= 0) THEN
		GOSUB ReportFrames
		PRINT e$; "(message <= 0) to "; gridTypeFunc$[gridType];; grid;; message$; v0; v1; v2; v3; kid; r1; " = "; HEX$(r1); gridType
		RETURN ($$XuiError)
	END IF
'
	IF (grid[grid].gridType != gridType) THEN
		GOSUB ReportFrames
		gt1$ = gridType$[grid]
		gt2$ = gridTypeName$[gridType]
		PRINT e$; "(grid = wrong grid type : "; gt1$; " to "; gt2$; " grid function)";; grid;; message$; v0; v1; v2; v3; kid; r1; " = "; HEX$(r1); gridType
		RETURN ($$XuiError)
	END IF
'
' if kid # not 0 then redirect to the specified kid grid
'
	SELECT CASE message
		CASE #Callback, #GetCallback, #SetCallback
		CASE ELSE
					IF (kid > 0) THEN
						IFZ kids[grid, ] THEN RETURN			' asked for kid but grid has no kids
						upper = UBOUND (kids[grid, ])
						IF (kid > upper) THEN							' asked for too high kid number
							XgrMessageNumberToName (message, @message$)
							PRINT "XuiProcessMessage() : error : (kid > UBOUND(kids[grid,]) : "; grid; kid; upper;; message$
							RETURN
						END IF
						g = kids[grid,kid]
						IFZ g THEN												' asked for kid that does not exist
							XgrMessageNumberToName (message, @message$)
							PRINT "XuiProcessMessage() : error : (kids[grid,kid] = 0) : "; grid; kid; g;; message$
							RETURN
						END IF
						func = grid[g].gridFunc
						IFZ func THEN
							XgrGetGridFunction (g, @func)
							XgrMessageNumberToName (message, @message$)
							IF func THEN PRINT "XuiProcessMessage() : error : (grid[g].gridFunc = 0, but not XgrGetGridFunction(g,@func)) : "; grid; kid; g;; HEX$(func,8);; message$
							RETURN
						END IF
						@func (g, message, @v0, @v1, @v2, @v3, 0, @r1)
						RETURN (kid)
					END IF
	END SELECT
'
' (grid,message) are OK, so call the appropriate function for (grid,message)
'
	IF gridMessageFunc[grid, ] THEN
		IF (message <= UBOUND(gridMessageFunc[grid, ])) THEN
			func = gridMessageFunc[grid,message]
			IF func THEN
				IF (func != $$TRUE) THEN
					@func (grid, message, @v0, @v1, @v2, @v3, @kid, @r1)
				END IF
			END IF
		END IF
	ELSE
		IF (message <= UBOUND(gridTypeMessageFunc[gridType, ])) THEN
			func = gridTypeMessageFunc[gridType, message]
			IF func THEN
				IF (func != $$TRUE) THEN
					@func (grid, message, @v0, @v1, @v2, @v3, @kid, @r1)
				END IF
			END IF
		END IF
	END IF
	RETURN ($$FALSE)
'
'
' *****  ReportFrames  *****   Debug Information
'
SUB ReportFrames
'	IF ##WHOMASK THEN
		XxxGetEbpEsp (@ebp, @esp)
		PRINT "  ebp = "; HEX$(  ebp,8); "    esp = "; HEX$(  esp,8)
		xebp = XLONGAT (ebp) : xesp = XLONGAT (ebp,4)
		PRINT " xebp = "; HEX$( xebp,8); "   xesp = "; HEX$( xesp,8)
		xxebp = XLONGAT (xebp) : xxesp = XLONGAT (xebp,4)
		PRINT "xxebp = "; HEX$(xxebp,8); "  xxesp = "; HEX$(xxesp,8)
'	END IF
	XgrMessageNumberToName (message, @message$)
END SUB
END FUNCTION
'
'
' ####################################
' #####  XuiRegisterGridType ()  #####
' ####################################
'
FUNCTION  XuiRegisterGridType (gridType, gridType$, gridFunc, func[], SUBADDR sub[])
	SHARED	upperGridType
	SHARED	GRID  gridType[]
	SHARED	gridTypeName$[]
	SHARED	gridTypeFunc$[]
'	SHARED	gridTypeImage$[]
	SHARED	gridTypeMessageFunc[]
	SHARED	messageSub[]
	STATIC	GRID	proto
'
	gridType$ = TRIM$(gridType$)
	IFZ gridType$ THEN PRINT "XuiRegisterGridType() : error : (gridType$ = \"\")" : RETURN
'
	XgrRegisterGridType (@gridType$, @gridType)
	IF (gridType > upperGridType) THEN
		upperGridType	= (gridType + 16) OR 15
		REDIM gridType[upperGridType]
		REDIM gridTypeName$[upperGridType]
		REDIM gridTypeFunc$[upperGridType]
'		REDIM gridTypeImage$[upperGridType]
		REDIM messageSub[upperGridType, ]
		REDIM gridTypeMessageFunc[upperGridType, ]
	END IF
'
	GetDefaultGridInfo (@proto)
	gridTypeName$[gridType] = gridType$
	gridTypeFunc$[gridType] = gridType$
	proto.gridType					= gridType
	proto.gridFunc					= gridFunc
	proto.whomask						= $$FALSE
	IF ##WHOMASK THEN proto.whomask = $$TRUE
	gridType[gridType]			= proto
	XstCopyArray (@func[], @copy[])
	SWAP copy[], gridTypeMessageFunc[gridType, ]
	DIM copy[]
	upper = UBOUND (sub[])
	DIM temp[upper]
	FOR i = 0 TO upper
		temp[i] = sub[i]
	NEXT i
	SWAP temp[], messageSub[gridType, ]
	DIM temp[]
END FUNCTION
'
'
' ###############################
' #####  XuiSendMessage ()  #####
' ###############################
'
FUNCTION  XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperWindow
	SHARED	upperMessage
	SHARED	GRID	grid[]
	SHARED	WINDOW  windowInfo[]
	SHARED	UBYTE  messageType[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (grid <= 0) THEN
		PRINT "XuiSendMessage() : Error : (grid <= 0) : "; grid, message, v0, v1, v2, v3, kid, r1; " = "; HEX$(r1)
		GOSUB ReportFrames
		RETURN
	END IF
	IF (grid > upperGrid) THEN
		PRINT "XuiSendMessage() : Error : (grid > upperGrid) : ";  grid, message, v0, v1, v2, v3, kid, r1; " = "; HEX$(r1)
		GOSUB ReportFrames
		RETURN
	END IF
	IF (message <= 0) THEN
		PRINT "XuiSendMessage() : Error : (message <= 0) : "; grid, message, v0, v1, v2, v3, kid, r1; " = "; HEX$(r1)
		GOSUB ReportFrames
		RETURN
	END IF
'
	IF (message > upperMessage) THEN
		NewMessage (message)
		IF (message > upperMessage) THEN
			GOSUB ReportFrames
			PRINT "XuiSendMessage() : Error : (message > upperMessage) : "; grid, message, v0, v1, v2, v3, kid, r1; " = "; HEX$(r1)
			RETURN
		END IF
	END IF
	messageType = messageType[message]
	IFZ messageType THEN
		NewMessage (message)
		messageType = messageType[message]
		IFZ messageType THEN
			PRINT "XuiSendMessage() : Error : (messageType = 0) : "; grid, message, v0, v1, v2, v3, kid, r1; " = "; HEX$(r1)
			RETURN
		END IF
	END IF
'
	SELECT CASE messageType
		CASE $$Window
					window = grid
					IF (window > upperWindow) THEN PRINT "XuiSendMessage() : error : (window > upperWindow)" : RETURN
					func = windowInfo[window].func
					@func (window, message, @v0, @v1, @v2, @v3, @kid, @r1)
		CASE $$Grid
					IF (grid > upperGrid) THEN PRINT "XuiSendMessage() : error : (grid > upperGrid)" : RETURN
					func = grid[grid].gridFunc
					IFZ func THEN XgrGetGridFunction (grid, @func)
					@func (grid, message, @v0, @v1, @v2, @v3, @kid, @r1)
	END SELECT
	RETURN
'
'
' *****  ReportFrames  *****   Debug Information
'
SUB ReportFrames
'	IF ##WHOMASK THEN
		XxxGetEbpEsp (@ebp, @esp)
		PRINT "  ebp = "; HEX$(  ebp,8); "    esp = "; HEX$(  esp,8)
		xebp = XLONGAT (ebp) : xesp = XLONGAT (ebp,4)
		PRINT " xebp = "; HEX$( xebp,8); "   xesp = "; HEX$( xesp,8)
		xxebp = XLONGAT (xebp) : xxesp = XLONGAT (xebp,4)
		PRINT "xxebp = "; HEX$(xxebp,8); "  xxesp = "; HEX$(xxesp,8)
'	END IF
	XgrMessageNumberToName (message, @message$)
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiSendToKid ()  #####
' #############################
'
FUNCTION  XuiSendToKid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (grid < 0) THEN PRINT "XuiSendToKid() : error : (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "XuiSendToKid() : error : (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSendToKid() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "XuiSendToKid() : error ::: (message > upperMessage)"
	IF (kid <= 0) THEN
		PRINT "XuiSendToKid() : error : (kid # <= 0)"
		RETURN
	ENDIF
'
' if kid # > 0 then redirect to the specified kid grid
'
	IF (kid > 0) THEN
		IFZ kids[grid, ] THEN RETURN			' asked for kid but grid has no kids
		upper = UBOUND (kids[grid, ])
		IF (kid > upper) THEN RETURN			' asked for too high kid number
		grid = kids[grid,kid]
		IFZ grid THEN RETURN							' asked for kid that does not exist
	END IF
	func = grid[grid].gridFunc
	@func (grid, message, @v0, @v1, @v2, @v3, 0, @r1)
END FUNCTION
'
'
' ##############################
' #####  XuiSendToKids ()  #####
' ##############################
'
FUNCTION  XuiSendToKids (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (grid < 0) THEN PRINT "XuiSendToKids() : error : (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "XuiSendToKids() : error : (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSendToKids() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "XuiSendToKids() : error ::: (message > upperMessage)"
'
	IF (kid > 0) THEN
		IFZ kids[grid, ] THEN RETURN	' asked for kid but grid has no kids
		upper = UBOUND (kids[grid, ])
		IF (kid > upper) THEN RETURN	' asked for too high kid number
		grid = kids[grid,kid]
		IFZ grid THEN RETURN					' asked for kid that does not exist
	END IF
'
	IF kids[grid, ] THEN
		upper = UBOUND (kids[grid, ])
		IF (kids[grid, 0] != grid) THEN PRINT "XuiSendToKids() : error : (kids[grid,0] != grid)" : RETURN
		FOR i = 1 TO upper
			g = kids[grid, i]
			IF g THEN XuiSendMessage (g, message, v0, v1, v2, v3, 0, @r1)
		NEXT i
	END IF
END FUNCTION
'
'
' ####################################
' #####  XuiSetDefaultColors ()  #####
' ####################################
'
FUNCTION  XuiSetDefaultColors (back, draw, low, high, dull, acc, lowtext, hightext)
	SHARED	backgroundColor
	SHARED	drawingColor
	SHARED	lowlightColor
	SHARED	highlightColor
	SHARED	accentColor
	SHARED	dullColor
	SHARED	lowtextColor
	SHARED	hightextColor
'
	IF (back			!= -1) THEN backgroundColor		= back
	IF (draw			!= -1) THEN drawingColor			= draw
	IF (low				!= -1) THEN lowlightColor			= low
	IF (high			!= -1) THEN highlightColor		= high
	IF (dull			!= -1) THEN dullColor					= dull
	IF (acc				!= -1) THEN accentColor				= acc
	IF (lowtext		!= -1) THEN lowtextColor			= lowtext
	IF (hightext	!= -1) THEN hightextColor			= hightext
END FUNCTION
'
'
' ####################################
' #####  XuiSetDefaultCursor ()  #####
' ####################################
'
FUNCTION  XuiSetDefaultCursor (cursor)
'
	IF (cursor >= 0) THEN #defaultCursor = cursor
END FUNCTION
'
'
' ###################################
' #####  XuiSetGridProperty ()  #####
' ###################################
'
FUNCTION  XuiSetGridProperty (grid, kid, property$, (v, v[], v$, v$[]))
	SHARED	CALLBACK	callback[]
	SHARED	GRID	grid[]
	SHARED	textArray$[]
	SHARED	textString$
	SHARED	help$[]
	SHARED	hint$[]
	SHARED  kids[]
	SHARED	upperGrid
'
	IF (kid < 0) THEN PRINT "XuiSetGridProperty() : error : (kid < 0)" : RETURN
	IF (grid < 0) THEN PRINT "XuiSetGridProperty() : error : (grid < 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridProperty() : error : (grid > upperGrid)" : RETURN
	IFZ property$ THEN PRINT "XuiSetGridProperty() : error : (property$ is empty)" : RETURN
	IF kid THEN
		uk = UBOUND (kids[grid,])
		IF (kid > uk) THEN PRINT "XuiSetGridProperty() : error : (kid > upperKid)" : RETURN
		g = kids[grid,kid]
	ELSE
		g = grid
	END IF
	IF (g <= 0) THEN PRINT "XuiSetGridProperty() : error : (grid,kid <= 0)" : RETURN
'
	n$ = LCASE$ (property$)
'
	SELECT CASE n$
		CASE "grid"							: grid[g].grid = v
		CASE "gridtype"					: grid[g].gridType = v
		CASE "gridfunc"					: grid[g].gridFunc = v
		CASE "gridwindow"				: grid[g].gridWindow = v
		CASE "window"						: grid[g].window = v
		CASE "parent"						: grid[g].parent = v
		CASE "cursor"						: grid[g].cursor = v
		CASE "clip"							: grid[g].clip = v
		CASE "image"						: grid[g].image = v
		CASE "imagealign"				: grid[g].imageAlign = v
		CASE "imageindentx"			: grid[g].imageIndentX = v
		CASE "imageindenty"			: grid[g].imageIndentY = v
		CASE "imagestartx"			: grid[g].imageStartX = v
		CASE "imagestarty"			: grid[g].imageStartY = v
		CASE "imagewidth"				: grid[g].imageWidth = v
		CASE "imageheight"			: grid[g].imageHeight = v
		CASE "x"								: grid[g].x = v
		CASE "y"								: grid[g].y = v
		CASE "width"						: grid[g].width = v
		CASE "height"						: grid[g].height = v
		CASE "maxwidth"					: grid[g].maxWidth = v
		CASE "maxheight"				: grid[g].maxHeight = v
		CASE "minwidth"					: grid[g].minWidth = v
		CASE "minheight"				: grid[g].minHeight = v
		CASE "focusbackground"	: grid[g].focusBackground = v
		CASE "focusdrawing"			: grid[g].focusDrawing = v
		CASE "focuslowlight"		: grid[g].focusLowlight = v
		CASE "focushighlight"		: grid[g].focusHighlight = v
		CASE "focusdull"				: grid[g].focusDull = v
		CASE "focusaccent"			: grid[g].focusAccent = v
		CASE "focuslowtext"			: grid[g].focusLowtext = v
		CASE "focushightext"		: grid[g].focusHightext = v
		CASE "backgroundcolor"	: grid[g].backgroundColor = v		: GOSUB Color
		CASE "drawingcolor"			: grid[g].drawingColor = v			: GOSUB Color
		CASE "lowlightcolor"		: grid[g].lowlightColor = v			: GOSUB Color
		CASE "highlightcolor"		: grid[g].highlightColor = v		: GOSUB Color
		CASE "dullcolor"				: grid[g].dullColor = v					: GOSUB Color
		CASE "accentcolor"			: grid[g].accentColor = v				: GOSUB Color
		CASE "lowtextcolor"			: grid[g].lowtextColor = v			: GOSUB Color
		CASE "hightextcolor"		: grid[g].hightextColor = v			: GOSUB Color
		CASE "cursorx"					: grid[g].cursorX = v
		CASE "cursory"					: grid[g].cursorY = v
		CASE "cursorpos"				: grid[g].cursorPos = v
		CASE "cursorline"				: grid[g].cursorLine = v
		CASE "left"							: grid[g].left = v
		CASE "top"							: grid[g].top = v
		CASE "right"						: grid[g].right = v
		CASE "bottom"						: grid[g].bottom = v
		CASE "redrawflags"			: grid[g].redrawFlags = v
		CASE "buffer"						: grid[g].buffer = v
		CASE "timer"						: grid[g].timer = v
		CASE "font"							: grid[g].font = v
		CASE "indentleft"				: grid[g].indentLeft = v
		CASE "indenttop"				: grid[g].indentTop = v
		CASE "indentright"			: grid[g].indentRight = v
		CASE "indentbottom"			: grid[g].indentBottom = v
		CASE "style"						: grid[g].style = v
		CASE "stylemax"					: grid[g].styleMax = v
		CASE "align"						: grid[g].align = v
		CASE "justify"					: grid[g].justify = v
		CASE "texture"					: grid[g].texture = v
		CASE "tabwidth"					: grid[g].tabWidth = v
		CASE "border"						: grid[g].border = v						: GOSUB Border
		CASE "borderup"					: grid[g].borderUp = v					: GOSUB Border
		CASE "borderdown"				: grid[g].borderDown = v				: GOSUB Border
		CASE "borderflags"			: grid[g].borderFlags = v				: GOSUB Border
		CASE "group"						: grid[g].group = v
		CASE "xgap"							: grid[g].xgap = v
		CASE "ygap"							: grid[g].ygap = v
		CASE "zzz"							: grid[g].zzz = v
		CASE "can"							: grid[g].can = v
		CASE "kind"							: grid[g].kind = v
		CASE "focus"						: grid[g].focus = v
		CASE "focuskid"					: grid[g].focusKid = v
		CASE "inputtextarray"		: grid[g].inputTextArray = v
		CASE "inputtextstring"	: grid[g].inputTextString = v
		CASE "selectable"				: grid[g].selectable = v
		CASE "whomask"					: grid[g].whomask = v
		CASE "state"						: grid[g].state = v
		CASE "keyboard"					: grid[g].keyboard = v
		CASE "mouse"						: grid[g].mouse = v
		CASE "redraw"						: grid[g].redraw = v
'		CASE "callgrid"					: callback[g].grid = v
'		CASE "callfunc"					: callback[g].func = v
'		CASE "gridname"					: grid$[g] = v$
'		CASE "gridfunctionname"	: gridFunc$[g] = v$
'		CASE "gridtypename"			: gridType$[g] = v$
'		CASE "helpstring"				: help$[g] = v$
'		CASE "hintstring"				: hint$[g] = v$
'		CASE "textstring"				: textString$[g] = v$
'		CASE "textarray"				: ATTACH textArray$[g, ] TO text$[]
'															XstCopyArray (@v$[], @copy$[])
'															ATTACH copy$[] TO textArray$[g, ]
'															DIM text$[]
'		CASE "valuearray"				: ATTACH value[g, ] TO trash[]
'															XstCopyArray (@v[], @copy[])
'															ATTACH copy[] TO value[g, ]
'															DIM trash[]
		CASE ELSE								: PRINT "XuiSetGridProperty() : error ::: (unknown property name)"
	END SELECT
	RETURN
'
'
' *****  Border  *****
'
SUB Border
	border = grid[g].border
	borderUp = grid[g].borderUp
	borderDown = grid[g].borderDown
	borderFlags = grid[g].borderFlags
	XgrSetGridBorder (g, border, borderUp, borderDown, borderFlags)
END SUB
'
'
' *****  Color  *****
'
SUB Color
	back = grid[g].backgroundColor
	draw = grid[g].drawingColor
	lo = grid[g].lowlightColor
	hi = grid[g].highlightColor
	dull = grid[g].dullColor
	acc = grid[g].accentColor
	low = grid[g].lowtextColor
	high = grid[g].hightextColor
	XgrSetGridColors (g, back, draw, lo, hi, dull, acc, low, high)
END SUB
END FUNCTION
'
'
' #######################################
' #####  XuiSetGridTypeProperty ()  #####
' #######################################
'
FUNCTION  XuiSetGridTypeProperty (gridType, property$, value)
	SHARED	GRID	gridType[]
	SHARED	upperGridType
'
	IF (gridType < 0) THEN PRINT "XuiSetGridTypeProperty() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "XuiSetGridTypeProperty() : error : (gridType > upperGridType)" : RETURN
	IFZ property$ THEN PRINT "XuiSetGridTypeProperty() : error : (property$ is empty)" : RETURN
'
	n$ = LCASE$ (property$)
'
	SELECT CASE n$
		CASE "grid"							: gridType[gridType].grid = value
		CASE "gridtype"					: gridType[gridType].gridType = value
		CASE "gridfunc"					: gridType[gridType].gridFunc = value
		CASE "gridwindow"				: gridType[gridType].gridWindow = value
		CASE "window"						: gridType[gridType].window = value
		CASE "parent"						: gridType[gridType].parent = value
		CASE "cursor"						: gridType[gridType].cursor = value
		CASE "clip"							: gridType[gridType].clip = value
		CASE "image"						: gridType[gridType].image = value
		CASE "imagealign"				: gridType[gridType].imageAlign = value
		CASE "imageindentx"			: gridType[gridType].imageIndentX = value
		CASE "imageindenty"			: gridType[gridType].imageIndentY = value
		CASE "imagestartx"			: gridType[gridType].imageStartX = value
		CASE "imagestarty"			: gridType[gridType].imageStartY = value
		CASE "imagewidth"				: gridType[gridType].imageWidth = value
		CASE "imageheight"			: gridType[gridType].imageHeight = value
		CASE "x"								: gridType[gridType].x = value
		CASE "y"								: gridType[gridType].y = value
		CASE "width"						: gridType[gridType].width = value
		CASE "height"						: gridType[gridType].height = value
		CASE "maxwidth"					: gridType[gridType].maxWidth = value
		CASE "maxheight"				: gridType[gridType].maxHeight = value
		CASE "minwidth"					: gridType[gridType].minWidth = value
		CASE "minheight"				: gridType[gridType].minHeight = value
		CASE "focusbackground"	: gridType[gridType].focusBackground = value
		CASE "focusdrawing"			: gridType[gridType].focusDrawing = value
		CASE "focuslowlight"		: gridType[gridType].focusLowlight = value
		CASE "focushighlight"		: gridType[gridType].focusHighlight = value
		CASE "focusdull"				: gridType[gridType].focusDull = value
		CASE "focusaccent"			: gridType[gridType].focusAccent = value
		CASE "focuslowtext"			: gridType[gridType].focusLowtext = value
		CASE "focushightext"		: gridType[gridType].focusHightext = value
		CASE "backgroundcolor"	: gridType[gridType].backgroundColor = value
		CASE "drawingcolor"			: gridType[gridType].drawingColor = value
		CASE "lowlightcolor"		: gridType[gridType].lowlightColor = value
		CASE "highlightcolor"		: gridType[gridType].highlightColor = value
		CASE "dullcolor"				: gridType[gridType].dullColor = value
		CASE "accentcolor"			: gridType[gridType].accentColor = value
		CASE "lowtextcolor"			: gridType[gridType].lowtextColor = value
		CASE "hightextcolor"		: gridType[gridType].hightextColor = value
		CASE "cursorx"					: gridType[gridType].cursorX = value
		CASE "cursory"					: gridType[gridType].cursorY = value
		CASE "cursorpos"				: gridType[gridType].cursorPos = value
		CASE "cursorline"				: gridType[gridType].cursorLine = value
		CASE "left"							: gridType[gridType].left = value
		CASE "top"							: gridType[gridType].top = value
		CASE "right"						: gridType[gridType].right = value
		CASE "bottom"						: gridType[gridType].bottom = value
		CASE "redrawflags"			: gridType[gridType].redrawFlags = value
		CASE "buffer"						: gridType[gridType].buffer = value
		CASE "timer"						: gridType[gridType].timer = value
		CASE "font"							: gridType[gridType].font = value
		CASE "indentleft"				: gridType[gridType].indentLeft = value
		CASE "indenttop"				: gridType[gridType].indentTop = value
		CASE "indentright"			: gridType[gridType].indentRight = value
		CASE "indentbottom"			: gridType[gridType].indentBottom = value
		CASE "align"						: gridType[gridType].align = value
		CASE "justify"					: gridType[gridType].justify = value
		CASE "texture"					: gridType[gridType].texture = value
		CASE "tabwidth"					: gridType[gridType].tabWidth = value
		CASE "border"						: gridType[gridType].border = value
		CASE "borderup"					: gridType[gridType].borderUp = value
		CASE "borderdown"				: gridType[gridType].borderDown = value
		CASE "borderflags"			: gridType[gridType].borderFlags = value
		CASE "style"						: gridType[gridType].style = value
		CASE "stylemax"					: gridType[gridType].styleMax = value
		CASE "group"						: gridType[gridType].group = value
		CASE "xgap"							: gridType[gridType].xgap = value
		CASE "ygap"							: gridType[gridType].ygap = value
		CASE "zzz"							: gridType[gridType].zzz = value
		CASE "can"							: gridType[gridType].can = value
		CASE "kind"							: gridType[gridType].kind = value
		CASE "focus"						: gridType[gridType].focus = value
		CASE "focuskid"					: gridType[gridType].focusKid = value
		CASE "inputtextarray"		: gridType[gridType].inputTextArray = value
		CASE "inputtextstring"	: gridType[gridType].inputTextString = value
		CASE "selectable"				: gridType[gridType].selectable = value
		CASE "whomask"					: gridType[gridType].whomask = value
		CASE "state"						: gridType[gridType].state = value
		CASE "keyboard"					: gridType[gridType].keyboard = value
		CASE "mouse"						: gridType[gridType].mouse = value
		CASE "redraw"						: gridType[gridType].redraw = value
		CASE ELSE								: PRINT "XuiSetGridTypeProperty() : error ::: (unknown property name)"
	END SELECT
END FUNCTION
'
'
' ####################################
' #####  XuiSetGridTypeValue ()  #####
' ####################################
'
FUNCTION  XuiSetGridTypeValue (gridType, property$, value)
'
	XuiSetGridTypeProperty (gridType, @property$, @value)
END FUNCTION
'
'
' ################################
' #####  XuiSetGridValue ()  #####
' ################################
'
FUNCTION  XuiSetGridValue (grid, property$, value)
'
	XuiSetGridProperty (grid, 0, @property$, @value)
END FUNCTION
'
'
' #######################################
' #####  XuiSetPropertyDatabase ()  #####
' #######################################
'
FUNCTION  XuiSetPropertyDatabase (data$[])
	SHARED  property$[]
	SHARED  prop$[]
'
	IFZ data$[] THEN
		DIM property$[]
		DIM prop$[]
		RETURN
	END IF
'
	whomask = ##WHOMASK
	##WHOMASK = $$FALSE
'
	upper = UBOUND (data$[])
	DIM property$[upper]
	DIM prop$[upper]
	entry = 0
'
	FOR i = 0 TO upper
		property$ = TRIM$(data$[i])
		property$[i] = property$
		IF property$ THEN
			IF (property${0} != ''') THEN
				prop$[entry] = property$
				INC entry
			END IF
		END IF
	NEXT i
'
	IFZ entry THEN
		DIM prop$[]
	ELSE
		DEC entry
		REDIM prop$[entry]
	END IF
'
	##WHOMASK = whomask
END FUNCTION
'
'
' ############################
' #####  XuiVersion$ ()  #####
' ############################
'
FUNCTION  XuiVersion$ ()
	version$ = VERSION$ (0)
	RETURN (version$)
END FUNCTION
'
'
' ##########################
' #####  XuiWindow ()  #####
' ##########################
'
FUNCTION  XuiWindow (wingrid, message, v0, v1, v2, v3, r0, (r1, r1$))
	SHARED	report
	SHARED	imbedded
	SHARED	upperMessage
	SHARED	upperWindow
	SHARED  hintGrid
	SHARED	window[]
	SHARED	winkid[]
	SHARED	window$[]
	SHARED  windowDisplay$[]
	SHARED	selectedWindow
	SHARED  gridMouseMessage
	SHARED	keyboardFocusGrid
	SHARED	GRID	grid[]
	SHARED	CALLBACK	monitor[]
	SHARED	WINDOW	windowInfo[]
	SHARED	UBYTE	messageType[]
	STATIC	SUBADDR  sub[]
	STATIC	enableHelp
	STATIC	mouseDown
	MESSAGE  mess[]
	FUNCADDR	f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, ANY)
'
	IFZ sub[] THEN GOSUB Initialize
	IF (message <= 0) THEN
		PRINT "XuiWindow() : error : (message <= 0) : "; message
		RETURN
	END IF
	IF (wingrid <= 0) THEN
		IF (message != #WindowCreate) THEN
			PRINT "XuiWindow() : error : (wingrid <= 0) : "; wingrid
			RETURN
		END IF
	END IF
'
	IF (message > upperMessage) THEN
		NewMessage (message)
		IF (message > upperMessage) THEN PRINT "XuiWindow() : error : (bad message number) : "; message : RETURN
	END IF
	messageType = messageType[message]
	IFZ messageType THEN
		NewMessage (message)
		messageType = messageType[message]
		IFZ messageType THEN PRINT "XuiWindow() : error : (messageType = 0)" : RETURN
	END IF
'
	window = wingrid
	IF (messageType = $$Window) THEN
		IF (message > UBOUND(sub[])) THEN RETURN
		IF sub[message] THEN																					' window message
			GOSUB QualifyWindow
			IFZ qualify THEN RETURN
			GOSUB @sub[message]
		END IF
	ELSE
		grid = wingrid
		IF sub[message] THEN
			GOSUB @sub[message]																					' required for MonitorMouse support
		ELSE
			XuiSendMessage (wingrid, message, v0, v1, v2, v3, r0, r1)		' grid message
		END IF
	END IF
	RETURN
'
'
' *****  WindowClose  *****
'
SUB WindowClose
	windowType = windowInfo[window].windowType
'	PRINT "XuiWindow() : WindowClose : "; window;; windowType
	SELECT CASE TRUE
		CASE (windowType AND $$WindowTypeCloseMinimize)		: GOSUB WindowMinimize
		CASE (windowType AND $$WindowTypeCloseHide)				: GOSUB WindowHide
		CASE (windowType AND $$WindowTypeCloseDestroy)		: GOSUB WindowDestroy
		CASE (windowType AND $$WindowTypeCloseTerminate)	: QUIT (0)
		CASE ELSE																					: XuiSendMessage (grid, #CloseWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  WindowCreate  *****  @window, #CreateWindow, xDisp, yDisp, width, height, windowType OR parent, display$
'
SUB WindowCreate
	display$ = ""
	windowType = r0
	windowFunc = &XuiWindow()
	IF r1 THEN
		IF (r1 != &XuiWindow()) THEN display$ = r1$		' r1 used to be &WindowFunction()
	END IF
	XuiPlaceWindow (0, 0, @v0, @v1, @v2, @v3)			' put window on display
	XgrCreateWindow (@window, @windowType, @v0, @v1, @v2, @v3, windowFunc, @display$)
	IF (window <= 0) THEN PRINT "XuiWindow() : WindowCreate : error : (window <= 0) : "; window : RETURN
	wingrid = window
	upper = UBOUND(window[])
	IF (window > upper) THEN
		upper = (window + 64) OR 63
		REDIM windowDisplay$[upper]
		REDIM windowInfo[upper]
		REDIM window[upper, ]
		REDIM winkid[upper, ]
		REDIM window$[upper]
	END IF
	IF (window > upperWindow) THEN upperWindow = window
	IFZ window[window, ] THEN
		DIM temp[15]
		ATTACH temp[] TO window[window, ]
	END IF
	IF windowInfo[window].window THEN
		XgrGetWindowTitle (window, @title$)
		PRINT "XuiWindow() : WindowCreate  : error ::: (windowInfo[window].window) : "; window;; window$[window];; title$
	END IF
	lastGrid = UBOUND(window[window, ])
	FOR i = 0 TO lastGrid
		IF window[window,i] THEN
			gg = window[window,i]
			PRINT "XuiWindow() : WindowCreate : error ::: (window[window,i] != 0 = "; gg; " : window ="; window; " : i ="; i; " : lastGrid ="; lastGrid; ")";
		END IF
	NEXT i
	windowDisplay$[window] = display$
	parent = windowType AND 0x0000FFFF
	windowType = windowType AND 0xFFFF0000
	window$[window]														= "Window" + STRING$(window)
	windowInfo[window].window									= window			' window number
	windowInfo[window].windowType							= windowType	' window type
	windowInfo[window].parent									= parent			' parent window
	windowInfo[window].graph									= 0						' graph grid number
	windowInfo[window].grid										= 0						' window grid number
	windowInfo[window].func										= windowFunc	' window function address
	windowInfo[window].xDisplay								= v0					' left edge of window
	windowInfo[window].yDisplay								= v1					' top edge of window
	windowInfo[window].width									= v2					' width of window
	windowInfo[window].height									= v3					' height of window
	windowInfo[window].selectState						= $$FALSE			' not selected
	windowInfo[window].displayState						= 0						' hidden
	windowInfo[window].keyboardFocusGrid			= 0						' not specified yet
	windowInfo[window].previousSelectedWindow	= 0						' not specified yet
	windowInfo[window].whomask								= ##WHOMASK		'
	slot = -1
	IF parent THEN
		IF (parent <= upperWindow) THEN
			IFZ winkid[parent,] THEN
				slot = 0
				DIM temp[3]
				ATTACH temp[] TO winkid[parent, ]
			ELSE
				u = UBOUND (winkid[parent,])
				FOR i = 0 TO u
					IFZ winkid[parent,i] THEN slot = i : EXIT FOR
				NEXT i
				IF (slot < 0) THEN
					slot = u + 1
					u = u + 4
					ATTACH winkid[parent,] TO temp[]
					REDIM temp[u]
					ATTACH temp[] TO winkid[parent,]
				END IF
			END IF
			winkid[parent,slot] = window
		END IF
	END IF
	IF report THEN PRINT "XuiWindow() : WindowCreate : "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrSetWindowIcon (window, #iconWindow)
END SUB
'
'
' *****  WindowDeselected  *****
'
' Windows can already be deselected when the #WindowDeselected message
' is received because on the two separate parallel user/system queues.
' For example, if a user window is currently selected and the user
' clicks on a system window, GraphicsDesigner puts a #WindowDeselected
' message in the user queue, then a #WindowSelected in the system queue.
' But the system queue is processed quicker, so the #WindowSelected
' message is processed first, which deselects the user window before
' it selects the system window.  The #WindowDeselected message for the
' user window comes in later and finds the user window is not selected.
'
SUB WindowDeselected
	IF report THEN PRINT "XuiWindow() : WindowDeselected : "; window, grid, message, v0, v1, v2, v3, r0, r1
	IF (window != selectedWindow) THEN EXIT SUB		' already deselected
	windowInfo[window].selectState = $$FALSE
	kfg = keyboardFocusGrid
	IF kfg THEN
		keyboardFocusGrid = $$FALSE
		XuiSendMessage (kfg, #LostKeyboardFocus, 0, 0, 0, 0, 0, 0)
	END IF
	selectedWindow = 0
	gridMessage = #WindowDeselected
	GOSUB ContextChange
END SUB
'
'
' *****  WindowDestroy  *****
'
SUB WindowDestroy
	IF report THEN PRINT "XuiWindow() : WindowDestroy : "; window, grid, message, v0, v1, v2, v3, r0, r1
	IF (windowInfo[window].window <= 0) THEN PRINT "XuiWindow() : WindowDestroy : error : (windowInfo[window].window <= 0)" : EXIT SUB
	IF winkid[window,] THEN
		upper = UBOUND (winkid[window,])
		FOR i = 0 TO upper
			w = winkid[window,i]
			IF w THEN XuiWindow (w, #WindowDestroy, 0, 0, 0, 0, 0, 0)
		NEXT i
		ATTACH winkid[window,] TO temp[]
		DIM temp[]
	END IF
	windowGrid = windowInfo[window].grid
	IF windowGrid THEN
		windowInfo[window].grid = 0
		gridWindow = grid[windowGrid].gridWindow
		IFZ gridWindow THEN PRINT "XuiWindow() : WindowDestroyed : error : (grid[windowGrid].gridWindow = 0)" : RETURN
		IF (window != gridWindow) THEN PRINT "XuiWindow() : WindowDestroyed : error : (window != grid[windowGrid].gridWindow)" : RETURN
		grid[windowGrid].gridWindow = 0
	END IF
	FOR i = 0 TO lastGrid
		g = window[window,i]
		IF g THEN
			gw = grid[g].window
			IF (gw != window) THEN PRINT "XuiWindow() : WindowDestroy : error : (gw != grid[g].window)" : RETURN
			XuiSendMessage (g, #Destroy, 0, 0, 0, 0, 0, 0)
			window[window,i] = 0
		END IF
	NEXT i
	XgrDestroyWindow (window)
END SUB
'
'
' *****  WindowDestroyed  *****
'
SUB WindowDestroyed
	IF report THEN PRINT "XuiWindow() : WindowDestroyed : "; window, grid, message, v0, v1, v2, v3, r0, r1
	IF (windowInfo[window].window <= 0) THEN PRINT "XuiWindow() : WindowDestroyed : error : (windowInfo[window].window <= 0)" : EXIT SUB
	IF winkid[window,] THEN
		upper = UBOUND (winkid[window,])
		FOR i = 0 TO upper
			w = winkid[window,i]
			IF w THEN XuiWindow (w, #WindowDestroy, 0, 0, 0, 0, 0, 0)
		NEXT i
		ATTACH winkid[window,] TO temp[]
		DIM temp[]
	END IF
	windowGrid = windowInfo[window].grid
	IF windowGrid THEN
		windowInfo[window].grid = 0
		gridWindow = grid[windowGrid].gridWindow
		IFZ gridWindow THEN PRINT "XuiWindow() : WindowDestroyed : error : (grid[windowGrid].gridWindow = 0)" : RETURN
		IF (window != gridWindow) THEN PRINT "XuiWindow() : WindowDestroyed : error : (window != grid[windowGrid].gridWindow)" : RETURN
		grid[windowGrid].gridWindow = 0
	END IF
	FOR i = 0 TO UBOUND (monitor[])
		IF (monitor[i].func = -1) THEN PRINT "DW-1"
		g = monitor[i].grid
		f = monitor[i].func
		IF g THEN
			IF (window = grid[g].window) THEN
				monitor[i].grid = 0
				monitor[i].func = 0
				monitor[i].v0 = 0
				monitor[i].v1 = 0
				monitor[i].r0 = 0
				monitor[i].r1 = 0
			END IF
		END IF
	NEXT i
	FOR i = 0 TO lastGrid
		g = window[window,i]
		IF g THEN
			gw = grid[g].window
			IF (gw != window) THEN PRINT "XuiWindow() : WindowDestroyed : error : (gw != grid[g].window)" : RETURN
			XuiSendMessage (g, #Destroy, 0, 0, 0, 0, 0, 0)
			window[window,i] = 0
		END IF
	NEXT i
	window$[window] = ""
	parent = windowInfo[window].parent
	whomask = windowInfo[window].whomask
	previous = windowInfo[window].previousSelectedWindow
	window$[window]															= ""
	windowInfo[window].window										= 0
	windowInfo[window].windowType								= 0
	windowInfo[window].parent										= 0
	windowInfo[window].graph										= 0
	windowInfo[window].grid											= 0
	windowInfo[window].func											= 0
	windowInfo[window].xDisplay									= 0
	windowInfo[window].yDisplay									= 0
	windowInfo[window].width										= 0
	windowInfo[window].height										= 0
	windowInfo[window].selectState							= 0
	windowInfo[window].displayState							= 0
	windowInfo[window].keyboardFocusGrid				= 0
	windowInfo[window].previousSelectedWindow		= 0
	windowInfo[window].whomask									= 0
	IF parent THEN
		IFZ winkid[parent,] THEN PRINT "XuiWindow() : WindowDestroyed : error ::: (winkid[parent,] is empty)"
		upper = UBOUND (winkid[parent,])
		found = $$FALSE
		FOR i = 0 TO upper
			IF (window = winkid[parent,i]) THEN
				winkid[parent,i] = 0
				found = $$TRUE
				EXIT FOR
			END IF
		NEXT i
		IFZ found THEN PRINT "XuiWindow() : WindowDestroyed : error ::: (winkid[parent,*] does not contain kid window)"
	END IF
	DIM temp[] : ATTACH window[window,] TO temp[] : DIM temp[]
	IF (window = selectedWindow) THEN
		keyboardFocusGrid = 0
		selectedWindow = 0
	END IF
	gridMessage = #WindowDestroyed
	GOSUB ContextChange
END SUB
'
'
' *****  WindowDisplay  *****
'
SUB WindowDisplay
	IF report THEN PRINT "XuiWindow() : WindowDisplay: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrGetModalWindow (@mw)
'	IF (mw AND (mw != window)) THEN XgrSetModalWindow (0)		' cancel modal window
	IF (mw AND (mw != window)) THEN
		cancel = $$TRUE
		p = window
		DO
			p = windowInfo[p].parent
			IF (p = mw) THEN
				cancel = $$FALSE
				EXIT DO
			END IF
		LOOP WHILE p
		IF cancel THEN XgrSetModalWindow (0)		' cancel modal
	END IF
	windowInfo[window].displayState = $$WindowDisplayed
	XgrDisplayWindow (window)
END SUB
'
'
' *****  WindowDisplayed  *****
'
SUB WindowDisplayed
	IF report THEN PRINT "XuiWindow() : WindowDisplayed: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrGetModalWindow (@mw)
	state = windowInfo[window].displayState
	windowInfo[window].displayState = $$WindowDisplayed
'	IF (mw AND (mw != window)) THEN XgrSetModalWindow (0)		' cancel modal window
	IF (mw AND (mw != window)) THEN
		cancel = $$TRUE
		p = window
		DO
			p = windowInfo[p].parent
			IF (p = mw) THEN
				cancel = $$FALSE
				EXIT DO
			END IF
		LOOP WHILE p
		IF cancel THEN XgrSetModalWindow (0)		' cancel modal
	END IF
	IF grid THEN
		IF (state != $$WindowDisplayed) THEN
			XuiSendMessage (grid, #Displayed, state, 0, 0, 0, 0, 0)
'			gridMessage = #WindowDisplayed
'			GOSUB ContextChange
		END IF
	END IF
END SUB
'
'
' *****  WindowGetDisplay  *****
'
SUB WindowGetDisplay
	r1$ = windowDisplay$[window]
END SUB
'
'
' *****  WindowGetFunction  *****
'
SUB WindowGetFunction
	v0 = windowInfo[window].func
END SUB
'
'
' *****  WindowGetIcon  *****
'
SUB WindowGetIcon
	XgrGetWindowIcon (window, @v0)
END SUB
'
'
' *****  WindowGetKeyboardFocusGrid  *****
'
SUB WindowGetKeyboardFocusGrid
	v0 = windowInfo[window].keyboardFocusGrid
END SUB
'
'
' *****  WindowGetSelectedWindow  *****
'
SUB WindowGetSelectedWindow
	v0 = selectedWindow
END SUB
'
'
' *****  WindowGetSize  *****
'
SUB WindowGetSize
	XgrGetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
END SUB
'
'
' *****  WindowGetTitle  *****
'
SUB WindowGetTitle
	XgrGetWindowTitle (window, @r1$)
END SUB
'
'
' *****  WindowHelp  *****
'
SUB WindowHelp
	enableHelp = $$TRUE
	IFZ v0 THEN enableHelp = $$FALSE
END SUB
'
'
' *****  WindowHide  *****
'
SUB WindowHide
	IF report THEN PRINT "XuiWindow() : WindowHide : "; window
	XgrGetModalWindow (@mw)
	IF (mw = window) THEN XgrSetModalWindow (0)		' cancel modal
	windowInfo[window].displayState = $$WindowHidden
	GOSUB HideKidWindows
	XgrHideWindow (window)
END SUB
'
'
' *****  HideKidWindows  *****
'
SUB HideKidWindows
	IF winkid[window,] THEN
		upper = UBOUND (winkid[window,])
		FOR i = 0 TO upper
			w = winkid[window,i]
			IF w THEN XuiWindow (w, #WindowHide, 0, 0, 0, 0, 0, 0)
		NEXT i
	END IF
END SUB
'
'
' *****  WindowHidden  *****
'
SUB WindowHidden
	IF report THEN PRINT "XuiWindow() : WindowHidden: ", window
	XgrGetModalWindow (@mw)
	state = windowInfo[window].displayState
	windowInfo[window].displayState = $$WindowHidden
	IF (mw AND (mw = window)) THEN XgrSetModalWindow (0)
	IF grid THEN
		IF (state != $$WindowHidden) THEN
			XuiSendMessage (grid, #Hidden, state, 0, 0, 0, 0, 0)
'			gridMessage = #WindowHidden
'			GOSUB ContextChange
		END IF
	END IF
END SUB
'
'
' *****  WindowKeyDown  *****
'
SUB WindowKeyDown
	IF report THEN PRINT "XuiWindow() : WindowKeyDown : "; window
	gridMessage = #KeyDown
	GOSUB WindowKey
END SUB
'
'
' *****  WindowKeyUp  *****
'
SUB WindowKeyUp
	IF report THEN PRINT "XuiWindow() : WindowKeyUp : "; window
	gridMessage = #KeyUp
	GOSUB WindowKey
END SUB
'
'
' *****  WindowKey  *****
'
SUB WindowKey
	cancel = $$FALSE
	IFZ grid[grid].state THEN EXIT SUB
	IFZ grid[grid].keyboard THEN EXIT SUB
	focusGrid = windowInfo[window].keyboardFocusGrid
	IF keyboardFocusGrid THEN
		IF (focusGrid != keyboardFocusGrid) THEN
			IF report THEN PRINT "XuiWindow() : WindowKey : SlipFocus ::: "; focusGrid, keyboardFocusGrid
			focusGrid = keyboardFocusGrid
		END IF
	END IF
'
' Alt+Left moves keyboard focus backward
' Alt+Right moves keyboard focus forward
'
	IF focusGrid THEN
		IF (v2 AND $$AltBit) THEN
			IF (gridMessage = #KeyDown) THEN
				vk = v2 AND 0x00FF
				holdFocus = focusGrid
				IF ((vk = $$KeyLeftArrow) OR (vk = $$KeyRightArrow)) THEN
					IF (v2 AND $$CtrlBit) THEN
						GOSUB MoveFocusParent
						focusGrid = keyboardFocusGrid
						IF (focusGrid = holdFocus) THEN GOSUB MoveFocus
					ELSE
						GOSUB MoveFocus
					END IF
				END IF
			END IF
		END IF
	END IF
'
	IF monitor[] THEN
		upper = UBOUND (monitor[])
		FOR i = 0 TO upper
			IF monitor[i].func THEN
				IF (monitor[i].func = -1) THEN PRINT "KM-1"
				IF (monitor[i].func != -1) THEN
					IF (monitor[i].r0 = $$Keyboard) THEN
						abort = $$FALSE
						g = monitor[i].grid
						f = monitor[i].func
						' Only deliver the keyboard event if the monitor-grid has the
						' same ##WHOMASK as the window-grid of the window in which the
						' event occurred.
						IF grid[grid].whomask == grid[g].whomask THEN
							@f (g, gridMessage, v0, v1, v2, v3, @abort, r1)
						END IF
						IF (abort = -1) THEN cancel = $$TRUE
					END IF
				END IF
			END IF
		NEXT i
	END IF
'
	IFZ cancel THEN
		IF focusGrid THEN XuiSendMessage (focusGrid, gridMessage, v0, v1, v2, v3, 0, focusGrid)
	END IF
END SUB
'
'
' *****  MoveFocus  *****
'
SUB MoveFocus
	SELECT CASE	vk
		CASE $$KeyLeftArrow
					XuiSendMessage (focusGrid, #KeyboardFocusBackward, 0, 0, 0, 0, 0, 0)
					IF report THEN PRINT "XuiWindow() : WindowKey: KeyboardFocusBackward"; focusGrid
					cancel = $$TRUE
		CASE $$KeyRightArrow
					XuiSendMessage (focusGrid, #KeyboardFocusForward, 0, 0, 0, 0, 0, 0)
					IF report THEN PRINT "XuiWindow() : WindowKey: KeyboardFocusForward"; focusGrid
					cancel = $$TRUE
	END SELECT
END SUB
'
'
' *****  MoveFocusParent  *****
'
SUB MoveFocusParent
	pg = grid[focusGrid].parent
	IF pg THEN
		XuiGetKidNumber (pg, #GetKidNumber, @pk, 0, 0, 0, 0, 0)
		IF (pk > 0) THEN
			top = grid[pg].parent
			IF top THEN
				XuiGetKidArray (top, #GetKidArray, 0, 0, 0, 0, 0, @tk[])
				IF tk[] THEN
					upk = UBOUND (tk[])
					SELECT CASE	vk
						CASE $$KeyLeftArrow
									ok = pk
									DO
										DEC pk
										IF (pk <= 0) THEN pk = upk
										IF (pk = ok) THEN EXIT DO
										tg = tk[pk]
									LOOP UNTIL tg
									IF (ok != pk) THEN
										XuiSendMessage (tg, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
										IF report THEN PRINT "XuiWindow() : WindowKey: KeyboardFocusParentBackward"; focusGrid
										cancel = $$TRUE
									END IF
						CASE $$KeyRightArrow
									ok = pk
									DO
										INC pk
										IF (pk > upk) THEN pk = 1
										IF (pk = ok) THEN EXIT DO
										tg = tk[pk]
									LOOP UNTIL tg
									IF (ok != pk) THEN
										XuiSendMessage (tg, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
										IF report THEN PRINT "XuiWindow() : WindowKey: KeyboardFocusParentForward"; focusGrid
										cancel = $$TRUE
									END IF
					END SELECT
				END IF
			END IF
		END IF
	END IF
END SUB
'
'
' *****  WindowMaximize  *****
'
SUB WindowMaximize
	IF report THEN PRINT "XuiWindow() : WindowMaximize: ", window
	windowInfo[window].displayState = $$WindowMaximized
	XgrMaximizeWindow (window)
	GOSUB HideKidWindows
END SUB
'
'
' *****  WindowMaximized *****
'
SUB WindowMaximized
	IF report THEN PRINT "XuiWindow() : WindowMaximized : "; window
	XgrGetModalWindow (@mw)
	state = windowInfo[window].displayState
	windowInfo[window].displayState = $$WindowMaximized
	IF (mw AND (mw != window)) THEN XgrSetModalWindow (0)
	IF grid THEN
		IF (state != $$WindowMaximized) THEN
			XuiSendMessage (grid, #Maximized, state, 0, 0, 0, 0, 0)
			gridMessage = #WindowMaximized
			GOSUB ContextChange
		END IF
	END IF
END SUB
'
'
' *****  WindowMinimize  *****
'
SUB WindowMinimize
	IF report THEN PRINT "XuiWindow() : WindowMinimize: ", window
	windowInfo[window].displayState = $$WindowMinimized
	XgrGetModalWindow (@mw)
	IF (mw = window) THEN XgrSetModalWindow (0)		' cancel modal
	XgrMinimizeWindow (window)
	GOSUB HideKidWindows
END SUB
'
'
' *****  WindowMinimized *****
'
SUB WindowMinimized
	IF report THEN PRINT "XuiWindow() : WindowMinimized : "; window
	XgrGetModalWindow (@mw)
	state = windowInfo[window].displayState
	windowInfo[window].displayState = $$WindowMinimized
	IF (mw AND (mw = window)) THEN XgrSetModalWindow (0)
	IF grid THEN
		IF (state != $$WindowMinimized) THEN
			XuiSendMessage (grid, #Minimized, state, 0, 0, 0, 0, 0)
			gridMessage = #WindowMinimized
			GOSUB ContextChange
		END IF
	END IF
END SUB
'
'
' *****  WindowMonitor  *****  r1 = TRUE/FALSE means install/delete
'
SUB WindowMonitor
	IFZ r1 THEN																' delete monitor
'		PRINT "XuiWindow() : WindowMonitor : DeleteMonitor : "; v0;; HEX$(v1,8); device
		IF monitor[] THEN
			upper = UBOUND (monitor[])
			FOR i = 0 TO upper
				IF (v0 = monitor[i].grid) THEN
					IF (device = monitor[i].r0) THEN
						IF ((v1 = 0) OR (v1 = -1) OR (v1 = monitor[i].func)) THEN
							monitor[i].grid = 0
							monitor[i].func = 0
							monitor[i].v0 = 0
							monitor[i].v1 = 0
							monitor[i].r0 = 0
						END IF
					END IF
				END IF
			NEXT i
		END IF
	ELSE
'		PRINT "XuiWindow() : WindowMonitor : InstallMonitor : "; v0;; HEX$(v1,8); device
		slot = -1
		IFZ monitor[] THEN DIM monitor[15]
		upper = UBOUND (monitor[])
		FOR i = 0 TO upper
			IF (slot < 0) THEN
				IFZ monitor[i].func THEN slot = i
			END IF
			IF (v0 = monitor[i].grid) THEN
				IF (v1 = monitor[i].func) THEN
					IF (device = monitor[i].r0) THEN EXIT SUB			' already monitoring
				END IF
			END IF
		NEXT i
		IF v0 THEN
			IF v1 THEN
				IF (v0 > 0) THEN
					IF (v1 != -1) THEN
						IF (v0 < UBOUND(grid[]))
							IF (v0 = grid[v0].grid) THEN
								IF (slot < 0) THEN
									slot = i
									upper = upper + 16
									REDIM monitor[upper]
								END IF
								monitor[slot].grid = v0
								monitor[slot].func = v1
								monitor[slot].v0 = 0
								monitor[slot].v1 = 0
								monitor[slot].r0 = device
							END IF
						END IF
					END IF
				END IF
			END IF
		END IF
	END IF
END SUB
'
'
' *****  WindowMonitorContext  *****  WindowDeselectedSelectedResized
'
SUB WindowMonitorContext
	device = $$Context
	GOSUB WindowMonitor
END SUB
'
'
' *****  WindowMonitorHelp  *****
'
SUB WindowMonitorHelp
	device = $$Help
	GOSUB WindowMonitor
END SUB
'
'
' *****  WindowMonitorKeyboard  *****
'
SUB WindowMonitorKeyboard
	device = $$Keyboard
	GOSUB WindowMonitor
END SUB
'
'
' *****  WindowMonitorMouse  *****
'
SUB WindowMonitorMouse
	device = $$Mouse
	GOSUB WindowMonitor
END SUB
'
'
' *****  WindowMouse  *****
'
SUB WindowMouse
	IF report THEN PRINT "XuiWindow() : WindowMouse "; window, grid, message$, v0, v1, HEX$(v2,8), v3, r0, r1
	SELECT CASE message
		CASE #WindowMouseDown		: message = #MouseDown
		CASE #WindowMouseDrag		: message = #MouseDrag
		CASE #WindowMouseEnter	: message = #MouseEnter
		CASE #WindowMouseExit		: message = #MouseExit
		CASE #WindowMouseMove		: message = #MouseMove
		CASE #WindowMouseUp			: message = #MouseUp
		CASE #WindowMouseWheel	: message = #MouseWheel
	END SELECT
'
	IF hintGrid THEN XuiHint (hintGrid, message, v0, v1, v2, v3, r0, r1)
	IF (r1 <= 0) THEN EXIT SUB
	grid = r1
	GOSUB MouseMessage
END SUB
'
'
' *****  ContextChange  *****
'
SUB ContextChange
	IF monitor[] THEN
		upper = UBOUND (monitor[])
		FOR i = 0 TO upper
			IF (monitor[i].func = -1) THEN PRINT "CC-1"
			IF monitor[i].func THEN
				IF (monitor[i].func != -1) THEN
					IF (monitor[i].r0 = $$Context) THEN
						abort = $$FALSE
						g = monitor[i].grid
						f = monitor[i].func
						IF (gridMessage = #WindowResized) THEN
							IF (grid[g].window != window) THEN DO NEXT	' only resize of same window
						END IF
						@f (g, #ContextChange, v0, v1, v2, v3, @abort, gridMessage)
						IF (abort = -1) THEN cancel = $$TRUE
					END IF
				END IF
			END IF
		NEXT i
	END IF
END SUB
'
'
' *****  MouseMessage  *****
'
SUB MouseMessage
	cancel = $$FALSE
	gridMessage = message
	gridMouseMessage = grid
'
	IFZ grid[grid].state THEN EXIT SUB
	IFZ grid[grid].mouse THEN EXIT SUB

	IF (message == #MouseDown) THEN
		IF monitor[] THEN
			IF enableHelp THEN
				upper = UBOUND (monitor[])
				IF (v2 AND $$HelpButtonBit) THEN
					FOR i = 0 TO upper
						IF (monitor[i].func = -1) THEN PRINT "MM-1a"
						IF monitor[i].func THEN
							IF (monitor[i].func != -1) THEN
								IF (monitor[i].r0 = $$Help) THEN
									abort = $$FALSE
									g = monitor[i].grid
									f = monitor[i].func
									@f (g, gridMessage, v0, v1, v2, v3, @abort, r1)
									IF (abort = -1) THEN cancel = $$TRUE
								END IF
							END IF
						END IF
					NEXT i
				END IF
			END IF
		END IF
	END IF
'
'	XgrMessageNumberToName (message, @mess$)
'
	IF (message != #MouseMove) THEN
		IF monitor[] THEN
			upper = UBOUND (monitor[])
			FOR i = 0 TO upper
				IF monitor[i].func THEN
					IF (monitor[i].func = -1) THEN PRINT "MM-1b"
					IF (monitor[i].func != -1) THEN
						IF (monitor[i].r0 = $$Mouse) THEN
							abort = $$FALSE
							g = monitor[i].grid
							f = monitor[i].func
							IF ((gridMessage == #MouseWheel) OR (gridMessage == #WindowMouseWheel)) THEN PRINT "nnnnn"
							@f (g, gridMessage, v0, v1, v2, v3, @abort, r1)
							IF (abort = -1) THEN cancel = $$TRUE
							IF (g = r1) THEN cancel = $$TRUE			' don't send twice
						END IF
					END IF
				END IF
			NEXT i
		END IF
	END IF
'
	IFZ cancel THEN XuiSendMessage (grid, message, v0, v1, v2, v3, 0, grid)
'	IF ((message == #MouseDown) OR (message == #MouseWheel) OR (message == #WindowMouseWheel)) THEN PRINT "XuiWindow() : MouseMessage : send the message : "; grid, message, v0, v1, v2, v3, 0, grid
END SUB
'
'
' *****  WindowRedraw  *****
'
SUB WindowRedraw
	IF report THEN PRINT "XuiWindow() : WindowRedraw: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrRedrawWindow (window, $$TRUE, v0, v1, v2, v3)
END SUB
'
'
' *****  WindowRegister  *****
'
SUB WindowRegister
	IF report THEN PRINT "XuiWindow() : WindowRegister: "; window, grid, message, v0, v1, v2, v3, r0, r1
	IF grid THEN PRINT "XuiWindow() : WindowRegister : error : (windowInfo[window].grid already defined), grid, v0" : EXIT SUB
	grid = v0
	r0 = window
	windowInfo[window].grid = grid
	grid[grid].gridWindow = window
	XgrSetWindowTitle (window, @r1$)
	GOSUB WindowResizeToGrid
END SUB
'
'
' *****  WindowResize  *****  Resize window to specified size (or to grid that "owns" it)
'
SUB WindowResize
	IF report THEN PRINT "XuiWindow() : WindowResize: "; window, grid, message, v0, v1, v2, v3, r0, r1
	IFZ grid THEN
		XgrSetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
	ELSE
		XgrSetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
		IF ((v2 > 0) AND (v3 > 0)) THEN
			XuiSendMessage (grid, #Resize, 0, 0, v2, v3, 0, 0)
			XuiSendMessage (grid, #GetSize, 0, 0, @v2, @v3, 0, 0)
			XgrSetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
		ELSE
			XgrGetGridPositionAndSize (grid, 0, 0, @v2, @v3)
			XgrSetWindowPositionAndSize (window, @v0, @v1, v2, v3)
			GOSUB WindowResizeToGrid
		END IF
	END IF
	windowInfo[window].xDisplay = v0
	windowInfo[window].yDisplay = v1
	windowInfo[window].width = v2
	windowInfo[window].height = v3
	GOSUB HideKidWindows
END SUB
'
'
' *****  WindowResizeToGrid  *****  Resize window to fit parentless grid
'
SUB WindowResizeToGrid
	IF report THEN PRINT "XuiWindow() : WindowResizeToGrid: "; window, grid, message, v0, v1, v2, v3, r0, r1
	IF grid THEN
		XgrGetWindowPositionAndSize (window, @xDisp, @yDisp, @width, @height)
		XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
		v2 = x2 - x1 + 1 : v3 = y2 - y1 + 1
		resize = $$FALSE
		IF (v2 != width) THEN resize = $$TRUE
		IF (v3 != height) THEN resize = $$TRUE
		IF resize THEN
			XgrSetWindowPositionAndSize (window, @xDisp, @yDisp, @v2, @v3)
			windowInfo[window].xDisplay = xDisp
			windowInfo[window].yDisplay = yDisp
			windowInfo[window].width = v2
			windowInfo[window].height = v3
		END IF
	END IF
END SUB
'
'
' *****  WindowResized  *****
'
SUB WindowResized
	IF report THEN PRINT "XuiWindow() : WindowResized: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrGetMessages (@count, @mess[])
	IF count THEN
'		FOR i = 0 TO count-1
'			XgrMessageNumberToName (mess[i].message, @mmm$)
'			PRINT i;; mess[i].wingrid;; mmm$;; mess[i].v0;; mess[i].v1;; mess[i].v2;; mess[i].v3;; mess[i].r0;; mess[i].r1
'		NEXT i
		FOR i = 0 TO count-1
			IF (mess[i].message = #WindowResized) THEN
				IF (mess[i].wingrid = window) THEN
					IF (mess[0].message = #WindowRedraw) THEN
						IF (mess[0].wingrid = window) THEN
							XgrDeleteMessages (1)
'							PRINT "XuiWindow() : WindowResized : (delete excess #WindowRedraw) : "; wingrid;; window;; grid;; mess[0].v2;; mess[0].v3
						END IF
					END IF
					EXIT SUB		' ignore this #WindowResize because there are more for this window in the message queue
				END IF
			END IF
		NEXT i
	END IF
	XgrGetWindowPositionAndSize (window, @v0, @v1, @v2, @v3)
'	IF ((xx != v0) OR (yy != v1) OR (ww != v2) OR (hh != v3)) THEN
'		XgrMessagesPending (@count)
'		IF count THEN
'			XgrPeekMessage (@wg, @mess, 0, 0, 0, 0, 0, 0)
'			IF ((mess = #WindowRedraw) AND (wg = window)) THEN
'				XgrDeleteMessages (1)
'			END IF
'		END IF
'		EXIT SUB
'	END IF
'
	IF grid THEN
		grid[grid].gridWindow = 0
		XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
		width = x2 - x1 + 1 : height = y2 - y1 + 1
		IF ((v2 != width) OR (v3 != height)) THEN
			XuiSendMessage (grid, #Resize, 0, 0, v2, v3, 0, 0)
			XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
			width = x2 - x1 + 1 : height = y2 - y1 + 1
			IF ((v2 != width) OR (v3 != height)) THEN
				XgrMessagesPending (@count)
				IF count THEN
					XgrPeekMessage (@wg, @mess, 0, 0, 0, 0, 0, 0)
					IF ((mess = #WindowRedraw) AND (wg = window)) THEN
'						XgrDeleteMessages (1)
					END IF
				END IF
				XgrSetWindowPositionAndSize (window, -1, -1, width, height)
				XgrGetWindowPositionAndSize (window, 0, 0, @v2, @v3)
				IF ((v2 != width) OR (v3 != height)) THEN
					grid[grid].gridWindow = window
					PRINT "XuiWindow() : WindowResized: (Disaster)" : EXIT SUB
				END IF
			END IF
		END IF
		grid[grid].gridWindow = window
	END IF
	windowInfo[window].xDisplay = v0
	windowInfo[window].yDisplay = v1
	windowInfo[window].width = v2
	windowInfo[window].height = v3
	gridMessage = #WindowResized
	GOSUB ContextChange
END SUB
'
'
' *****  WindowSelect  *****
'
SUB WindowSelect
	IF report THEN PRINT "XuiWindow() : WindowSelect: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrGetModalWindow (@mw)
'	IF (mw AND (mw != window)) THEN XgrSetModalWindow (0)		' cancel modal
	IF (mw AND (mw != window)) THEN
		cancel = $$TRUE
		p = window
		DO
			p = windowInfo[p].parent
			IF (p = mw) THEN
				cancel = $$FALSE
				EXIT DO
			END IF
		LOOP WHILE p
		IF cancel THEN XgrSetModalWindow (0)		' cancel modal
	END IF
	XgrSetSelectedWindow (window)
END SUB
'
'
' *****  WindowSelected  *****
'
SUB WindowSelected
	IF report THEN PRINT "XuiWindow() : WindowSelected: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrGetModalWindow (@mw)
'	IF (mw AND (mw != window)) THEN XgrSetModalWindow (0)		' cancel modal
	IF (mw AND (mw != window)) THEN
		cancel = $$TRUE
		p = window
		DO
			p = windowInfo[p].parent
			IF (p = mw) THEN
				cancel = $$FALSE
				EXIT DO
			END IF
		LOOP WHILE p
		IF cancel THEN XgrSetModalWindow (0)		' cancel modal
	END IF
	IF selectedWindow THEN
		newWindow = window
		window = selectedWindow
		GOSUB WindowDeselected
		window = newWindow
	END IF
	selectedWindow = window
	windowInfo[window].selectState = $$TRUE
	keyboardFocusGrid = windowInfo[window].keyboardFocusGrid
	IF keyboardFocusGrid THEN
		XuiSendMessage (keyboardFocusGrid, #GotKeyboardFocus, 0, 0, 0, 0, 0, 0)
	ELSE
		u = UBOUND(window[window,])
		FOR i = 0 TO u
			g = window[window,i]
			IF g THEN
				IFZ grid[g].state THEN DO NEXT
				IFZ grid[g].keyboard THEN DO NEXT
				XuiSendMessage (g, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
				IF keyboardFocusGrid THEN EXIT FOR
			END IF
		NEXT i
	END IF
	gridMessage = #WindowSelected
	GOSUB ContextChange
END SUB
'
'
' *****  WindowSetFunction  *****
'
SUB WindowSetFunction
	IF (v0 != -1) THEN
		windowInfo[window].func = v0
		XgrSetWindowFunction (window, v0)
	END IF
END SUB
'
'
' *****  WindowSetIcon  *****
'
SUB WindowSetIcon
	IF (v0 < 0) THEN v0 = 0
	XgrSetWindowIcon (window, v0)
END SUB
'
'
' *****  WindowSetKeyboardFocusGrid  *****
'
SUB WindowSetKeyboardFocusGrid
	IF (v0 = keyboardFocusGrid) THEN EXIT SUB
	IF (v0 <= 0) THEN EXIT SUB
'
	IF (window != grid[v0].window) THEN
		PRINT "XuiWindow() : WindowSetKeyboardFocusGrid : error : (window != grid[v0].window)"
		EXIT SUB
	END IF
'
	IF (window = selectedWindow) THEN
		IF keyboardFocusGrid THEN
			kfg = keyboardFocusGrid
			keyboardFocusGrid = $$FALSE
			windowInfo[window].keyboardFocusGrid = keyboardFocusGrid
			XuiSendMessage (kfg, #LostKeyboardFocus, 0, 0, 0, 0, 0, 0)
		END IF
	END IF
'
	windowInfo[window].keyboardFocusGrid = v0		' update window keyboard focus grid
'
	IF (window = selectedWindow) THEN
		keyboardFocusGrid = v0
		XuiSendMessage (keyboardFocusGrid, #GotKeyboardFocus, 0, 0, 0, 0, 0, 0)
	END IF
END SUB
'
'
' *****  WindowSetTitle  *****
'
SUB WindowSetTitle
	XgrSetWindowTitle (window, r1$)
END SUB
'
'
' *****  WindowShow  *****
'
SUB WindowShow
	IF report THEN PRINT "XuiWindow() : WindowShow: "; window, grid, message, v0, v1, v2, v3, r0, r1
	XgrShowWindow (window)
	gridMessage = #WindowShow
END SUB
'
'
' *****  WindowSystemMessage  *****
'
SUB WindowSystemMessage
	IF grid THEN XuiSendMessage (grid, #SystemMessage, v0, v1, v2, v3, r0, window)
END SUB
'
'
' *****  QualifyWindow  *****
'
SUB QualifyWindow
	grid = $$FALSE
	qualify = $$FALSE
	upperWindow = UBOUND(window[])
	IF (message != #WindowCreate) THEN
		IF ((window <= 0) OR (window > upperWindow)) THEN
			XgrMessageNumberToName (message, @message$)
			PRINT "XuiWindow() : error : (window <= 0 or window > upperWindow): "; message$
			EXIT SUB
		END IF
		IFZ windowInfo[window].window THEN EXIT SUB
	END IF
	IF report THEN XgrMessageNumberToName (message, @message$)
	lastGrid = UBOUND(window[window,])
	grid = windowInfo[window].grid
	qualify = $$TRUE
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	enableHelp = $$TRUE
	DIM sub[upperMessage]
	sub[#MouseDown]										= SUBADDRESS (MouseMessage)
	sub[#MouseDrag]										= SUBADDRESS (MouseMessage)
	sub[#MouseEnter]									= SUBADDRESS (MouseMessage)
	sub[#MouseExit]										= SUBADDRESS (MouseMessage)
	sub[#MouseMove]										= SUBADDRESS (MouseMessage)
	sub[#MouseUp]											= SUBADDRESS (MouseMessage)
	sub[#WindowClose]									= SUBADDRESS (WindowClose)
	sub[#WindowCreate]								= SUBADDRESS (WindowCreate)
	sub[#WindowDeselected]						= SUBADDRESS (WindowDeselected)
	sub[#WindowDestroy]								= SUBADDRESS (WindowDestroy)
	sub[#WindowDestroyed]							= SUBADDRESS (WindowDestroyed)
	sub[#WindowDisplay]								= SUBADDRESS (WindowDisplay)
	sub[#WindowDisplayed]							= SUBADDRESS (WindowDisplayed)
	sub[#WindowGetDisplay]						= SUBADDRESS (WindowGetDisplay)
	sub[#WindowGetFunction]						= SUBADDRESS (WindowGetFunction)
	sub[#WindowGetIcon]								= SUBADDRESS (WindowGetIcon)
	sub[#WindowGetKeyboardFocusGrid]	= SUBADDRESS (WindowGetKeyboardFocusGrid)
	sub[#WindowGetSelectedWindow]			= SUBADDRESS (WindowGetSelectedWindow)
	sub[#WindowGetSize]								= SUBADDRESS (WindowGetSize)
	sub[#WindowGetTitle]							= SUBADDRESS (WindowGetTitle)
	sub[#WindowHelp]									= SUBADDRESS (WindowHelp)
	sub[#WindowHide]									= SUBADDRESS (WindowHide)
	sub[#WindowHidden]								= SUBADDRESS (WindowHidden)
	sub[#WindowKeyDown]								= SUBADDRESS (WindowKeyDown)
	sub[#WindowKeyUp]									= SUBADDRESS (WindowKeyUp)
	sub[#WindowMaximize]							= SUBADDRESS (WindowMaximize)
	sub[#WindowMaximized]							= SUBADDRESS (WindowMaximized)
	sub[#WindowMinimize]							= SUBADDRESS (WindowMinimize)
	sub[#WindowMinimized]							= SUBADDRESS (WindowMinimized)
	sub[#WindowMonitorContext]				= SUBADDRESS (WindowMonitorContext)
	sub[#WindowMonitorHelp]						= SUBADDRESS (WindowMonitorHelp)
	sub[#WindowMonitorKeyboard]				= SUBADDRESS (WindowMonitorKeyboard)
	sub[#WindowMonitorMouse]					= SUBADDRESS (WindowMonitorMouse)
	sub[#WindowMouseDown]							= SUBADDRESS (WindowMouse)
	sub[#WindowMouseDrag]							= SUBADDRESS (WindowMouse)
	sub[#WindowMouseEnter]						= SUBADDRESS (WindowMouse)
	sub[#WindowMouseExit]							= SUBADDRESS (WindowMouse)
	sub[#WindowMouseMove]							= SUBADDRESS (WindowMouse)
	sub[#WindowMouseUp]								= SUBADDRESS (WindowMouse)
	sub[#WindowMouseWheel]						= SUBADDRESS (WindowMouse)
	sub[#WindowRedraw]								= SUBADDRESS (WindowRedraw)
	sub[#WindowRegister]							= SUBADDRESS (WindowRegister)
	sub[#WindowResize]								= SUBADDRESS (WindowResize)
	sub[#WindowResized]								= SUBADDRESS (WindowResized)
	sub[#WindowResizeToGrid]					= SUBADDRESS (WindowResizeToGrid)
	sub[#WindowSelect]								= SUBADDRESS (WindowSelect)
	sub[#WindowSelected]							= SUBADDRESS (WindowSelected)
	sub[#WindowSetFunction]						= SUBADDRESS (WindowSetFunction)
	sub[#WindowSetIcon]								= SUBADDRESS (WindowSetIcon)
	sub[#WindowSetKeyboardFocusGrid]	= SUBADDRESS (WindowSetKeyboardFocusGrid)
	sub[#WindowSetTitle]							= SUBADDRESS (WindowSetTitle)
	sub[#WindowShow]									= SUBADDRESS (WindowShow)
	sub[#WindowSystemMessage]					= SUBADDRESS (WindowSystemMessage)
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiArea ()  #####
' ########################
'
FUNCTION  XuiArea (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiArea
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiArea) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiArea, @v0, @v1, @v2, @v3, r0, r1, &XuiArea())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiArea")
END SUB
'
'
' *****  Key  *****
'
SUB Key
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Mouse  *****
'
SUB Mouse
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#KeyDown]							= SUBADDRESS (Key)
	sub[#MouseDown]						= SUBADDRESS (Mouse)
	sub[#MouseDrag]						= SUBADDRESS (Mouse)
	sub[#MouseEnter]					= SUBADDRESS (Mouse)
	sub[#MouseExit]						= SUBADDRESS (Mouse)
	sub[#MouseMove]						= SUBADDRESS (Mouse)
	sub[#MouseUp]							= SUBADDRESS (Mouse)
	sub[#MouseWheel]					= SUBADDRESS (Mouse)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
'
	IF func[0] THEN PRINT "XuiArea() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiArea() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiArea, @"XuiArea", &XuiArea(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 32
	designHeight = 32
'
	gridType = XuiArea
	XuiSetGridTypeProperty (gridType, @"x",           designX)
	XuiSetGridTypeProperty (gridType, @"y",           designY)
	XuiSetGridTypeProperty (gridType, @"width",       designWidth)
	XuiSetGridTypeProperty (gridType, @"height",      designHeight)
	XuiSetGridTypeProperty (gridType, @"can",         $$Focus OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags", $$RedrawDefaultNoFocus)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiBase ()  #####
' ########################
'
FUNCTION  XuiBase (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiBase
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiBase) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiBase, @v0, @v1, @v2, @v3, r0, r1, &XuiBase())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiBase")
END SUB
'
'
' *****  Mouse  *****
'
SUB Mouse
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (Mouse)
	sub[#MouseDrag]						= SUBADDRESS (Mouse)
	sub[#MouseEnter]					= SUBADDRESS (Mouse)
	sub[#MouseExit]						= SUBADDRESS (Mouse)
	sub[#MouseUp]							= SUBADDRESS (Mouse)
'
	IF func[0] THEN PRINT "XuiBase() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiBase() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiBase, @"XuiBase", &XuiBase(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 32
	designHeight = 32
'
	gridType = XuiBase
	XuiSetGridTypeProperty (gridType, @"border",      $$BorderNone)
	XuiSetGridTypeProperty (gridType, @"borderUp",    $$BorderNone)
	XuiSetGridTypeProperty (gridType, @"borderDown",  $$BorderNone)
	XuiSetGridTypeProperty (gridType, @"can",         $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags", $$RedrawDefaultNoFocus)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiCheckBox ()  #####
' ############################
'
FUNCTION  XuiCheckBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiCheckBox
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiCheckBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiCheckBox, @v0, @v1, @v2, @v3, r0, r1, &XuiCheckBox())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiCheckBox")
END SUB
'
'
' *****  KeyDown  *****  #Selection callback on $$KeyEnter
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	state = v2																			' v2 = state
	key = state{8,24}																' virtual key
	IF (state AND $$AltBit) THEN EXIT SUB						' disallow Alt+Enter
	IF (key = $$KeyEnter) THEN GOSUB Selected				' got Enter
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	GOSUB Selected
END SUB
'
'
' *****  Selected  *****
'
SUB Selected
	XuiGetValue (grid, #GetValue, @state, 0, 0, 0, 0, 0)
	IF state THEN state = $$FALSE ELSE state = $$TRUE
	XuiSetValue (grid, #SetValue, state, 0, 0, 0, 0, 0)
	GOSUB RedrawGrid
	XuiCallback (grid, #Selection, state, 0, v2, v3, 0, grid)
END SUB
'
'
' *****  SetStyle  *****
'
'	$Style0 = 0		' x style checkbox, yellow background
'	$Style1 = 1		' check style checkbox, yellow background
' $Style2 = 2		' x style checkbox, white background, recessed border
' $Style2 = 3		' check style checkbox, white background, recessed border
'
SUB SetStyle
	style = v0
	styleMax = v1
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
	XuiSetStyle (grid, #SetStyle, style, styleMax, 0, 0, 0, 0)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	width = x2 - x1 + 1 : height = y2 - y1 + 1
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetValue (grid, #GetValue, @state, 0, 0, 0, 0, 0)
	XuiGetColor (grid, #GetColor, @back, @draw, @lo, @hi, 0, 0)
	XuiGetColorExtra (grid, #GetColorExtra, 0, @acc, 0, 0, 0, 0)
	XuiGetIndent (grid, #GetIndent, @inX, @inY, 0, 0, 0, @bw)
	xx = x1 + ((inX - 12) >> 1) + bw - 1 : yy = y1 + (height >> 1) - 6
'
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderLower2, back, lo, hi, xx, yy, xx+11, yy+11)
			IF state THEN base = acc ELSE base = back
			XgrFillBox (grid, base, xx+2, yy+2, xx+9, yy+9)
		CASE 2, 3
			Recessed3DBorder (grid, xx, yy, xx+11, yy+11)
			XgrFillBox (grid, $$White, xx+2, yy+2, xx+9, yy+9)
	END SELECT

	IF state THEN
		SELECT CASE style
			CASE 0, 2
				XgrDrawLine (grid, draw, xx+4, yy+3, xx+8, yy+7)
				XgrDrawLine (grid, draw, xx+3, yy+3, xx+8, yy+8)
				XgrDrawLine (grid, draw, xx+3, yy+4, xx+7, yy+8)
				XgrDrawLine (grid, draw, xx+3, yy+7, xx+7, yy+3)
				XgrDrawLine (grid, draw, xx+3, yy+8, xx+8, yy+3)
				XgrDrawLine (grid, draw, xx+4, yy+8, xx+8, yy+4)
			CASE 1, 3
				XgrDrawLine (grid, draw, xx+3, yy+4, xx+5, yy+6)
				XgrDrawLine (grid, draw, xx+3, yy+5, xx+5, yy+7)
				XgrDrawLine (grid, draw, xx+3, yy+6, xx+5, yy+8)
				XgrDrawLine (grid, draw, xx+5, yy+6, xx+8, yy+3)
				XgrDrawLine (grid, draw, xx+5, yy+7, xx+8, yy+4)
				XgrDrawLine (grid, draw, xx+5, yy+8, xx+8, yy+5)
		END SELECT
	END IF
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#Redraw]							= SUBADDRESS (RedrawGrid)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
'
	IF func[0] THEN PRINT "XuiCheckBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiCheckBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiCheckBox, @"XuiCheckBox", &XuiCheckBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiCheckBox
	XuiSetGridTypeProperty (gridType, @"x",            designX)
	XuiSetGridTypeProperty (gridType, @"y",            designY)
	XuiSetGridTypeProperty (gridType, @"width",        designWidth)
	XuiSetGridTypeProperty (gridType, @"height",       designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",     32)
	XuiSetGridTypeProperty (gridType, @"minHeight",    16)
	XuiSetGridTypeProperty (gridType, @"indentLeft",   24)
	XuiSetGridTypeProperty (gridType, @"align",        $$AlignMiddleLeft)
	XuiSetGridTypeProperty (gridType, @"border",       $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderUp",     $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderDown",   $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"texture",      $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",          $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",  $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #########################
' #####  XuiColor ()  #####
' #########################
'
FUNCTION  XuiColor (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiColor
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiColor) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiColor, @v0, @v1, @v2, @v3, r0, r1, &XuiColor())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiColor")
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	top = y1
	left = x1
	right = x2
	bottom = y2
	IF (v1 < top) THEN EXIT SUB
	IF (v0 < left) THEN EXIT SUB
	IF (v0 > right) THEN EXIT SUB
	IF (v1 > bottom) THEN EXIT SUB
	row = (v1 - top) >> 4
	col = (v0 - left) >> 3
	color = row * 25 + col
	XgrConvertColorToRGB (color, @red, @green, @blue)
	XuiCallback (grid, #Selection, color, red, green, blue, 0, grid)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	colorNumber = 0
	FOR i = 0 TO 4
		FOR j = 0 TO 24
			x1 = j *  8:	x2 = x1 +  7
			y1 = i * 16:	y2 = y1 + 15
			XgrFillBox (grid, colorNumber, x1, y1, x2, y2)
			INC colorNumber
		NEXT j
	NEXT i
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]		= &XuiGetMaxMinSize ()
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
'
	IF func[0] THEN PRINT "XuiColor() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiColor() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiColor, @"XuiColor", &XuiColor(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 200
	designHeight = 80
'
	gridType = XuiColor
	XuiSetGridTypeProperty (gridType, @"x",              designX)
	XuiSetGridTypeProperty (gridType, @"y",              designY)
	XuiSetGridTypeProperty (gridType, @"width",          designWidth)
	XuiSetGridTypeProperty (gridType, @"height",         designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"minHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"maxWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"maxHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"can",            $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",    $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##########################
' #####  XuiColors ()  #####
' ##########################
'
FUNCTION  XuiColors (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiColors
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiColors) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiColors, @v0, @v1, @v2, @v3, r0, r1, &XuiColors())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiColors")
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	top = y1
	left = x1
	right = x2
	bottom = y2
	IF (v1 < top) THEN EXIT SUB
	IF (v0 < left) THEN EXIT SUB
	IF (v0 > right) THEN EXIT SUB
	IF (v1 > bottom) THEN EXIT SUB
	row = (v1 - top) >> 4
	col = (v0 - left) \ 10
	color = row * 25 + col
	XgrConvertColorToRGB (color, @red, @green, @blue)
	XuiCallback (grid, #Selection, color, red, green, blue, color, grid)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
'
	xdiam = 10
	ydiam = 16
	FOR x = 0 TO 24
		FOR y = 0 TO 4
			c = (y * 25) + x
			x1 = x * xdiam
			y1 = y * ydiam
			x2 = x1 + xdiam - 1
			y2 = y1 + ydiam - 1
			XgrFillBox (grid, c, x1, y1, x2, y2)
		NEXT y
	NEXT x
	FOR x = 0 TO 25
		x1 = x * xdiam - 1
		y1 = 0
		x2 = x * xdiam - 1
		y2 = 5 * ydiam - 1
		XgrDrawLine (grid, $$Black, x1, y1, x2, y2)
	NEXT x
	FOR y = 0 TO 5
		x1 = 0
		y1 = y * ydiam - 1
		x2 = 25 * xdiam - 1
		y2 = y * ydiam - 1
		XgrDrawLine (grid, $$Black, x1, y1, x2, y2)
	NEXT y
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]		= &XuiGetMaxMinSize ()
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
'
	IF func[0] THEN PRINT "XuiColors() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiColors() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiColors, @"XuiColors", &XuiColors(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 250
	designHeight = 80
'
	gridType = XuiColors
	XuiSetGridTypeProperty (gridType, @"x",              designX)
	XuiSetGridTypeProperty (gridType, @"y",              designY)
	XuiSetGridTypeProperty (gridType, @"width",          designWidth)
	XuiSetGridTypeProperty (gridType, @"height",         designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"minHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"maxWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"maxHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"can",            $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",    $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###########################
' #####  XuiConsole ()  #####
' ###########################
'
'	TextArea with mods to:	SUB Inline, SUB PrintString
'													SUB GetValues, SUB SetValues
'													SUB KeyDown
'
FUNCTION  XuiConsole (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	UBYTE  charsetTextChar[]
	SHARED	WINDOW	windowInfo[]
	SHARED	helpWindow
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiConsole
	UBYTE  null[]
'
	$Console			=  0			' kid numbers
	$Text					=  1
	$ScrollH			=  2
	$ScrollV			=  3
'
	$textGrid			=  0			' value[] indices
	$cursorShown	= 10
	$console			= 30
	$ctrlS				= 31
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiConsole) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiConsole, @v0, @v1, @v2, @v3, r0, r1, &XuiConsole())
	XuiSendMessage ( grid, #CreateValueArray, 31, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiSendMessage ( grid, #GetColorExtra, @dull, @acc, @lowtext, @hightext, 0, 0)
'
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	XuiArea        (@g, #Create, dx, dy, v2-dx2-13, v3-dy2-13, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiConsole(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Area")
	XuiSendMessage ( g, #SetColorExtra, dull, acc, lowtext, hightext, 0, 0)
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
'
' Wierd stuff is going on with #SetValue and #SetValues in this function.
' The following cannot be XuiSendMessage() because of how #SetValue and
' #SetValues are handled.  Fix this someday.
'
	XuiSetValue    ( grid, #SetValue, $$TRUE, 0, 0, 0, 0, $console)
	XuiSetValue    ( grid, #SetValue, $$FALSE, 0, 0, 0, 0, $ctrlS)
	XuiSetValue    ( grid, #SetValue, g, 0, 0, 0, 0, $textGrid)
	TextMessage    ( grid, #SetValues, 0, 0, 0, 0, 0, 0)
'
'	Create Scroll Bars
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - 12
	h		= 12
	x		= dx
	y		= v3 - dy - h
	XuiScrollBarH  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiConsole(), -1, -1, $ScrollH, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollH")
'
	w		= 12
	h		= v3 - dy2 - 12
	x		= v2 - dx - w
	y		= dy
	XuiScrollBarV  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiConsole(), -1, -1, $ScrollV, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollV")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiConsole")
END SUB
'
'
' *****  Destroy  ***** Augment XuiDestroy()
'
SUB Destroy
	XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $textGrid)
	IF textGrid THEN
'		XgrDestroyGrid (textGrid)
		XuiSendMessage (textGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $textGrid)
	END IF
	XuiDestroy (grid, message, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  GetValues  *****  v0 = T/F
'
SUB GetValues
	IF (r1 != 0) THEN v0 = 0 : EXIT SUB
	XuiGetValue (grid, #GetValue, v0, 0, 0, 0, 0, $console)
END SUB
'
'
' *****  GetSmallestSize  *****  v0 = # columns, v1 = # rows
'
SUB GetSmallestSize
	XuiGetMaxMinSize (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	XuiGetAlign (grid, #GetAlign, @align, @justify, @indentX, @indentY, 0, @borderWidth)
	border = borderWidth + borderWidth
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	textWidth = maxCharWidth * MAX(v0, 1)
	textHeight = maxCharHeight * MAX(v1, 1)
	scrollWidth = 12
	scrollHeight = 12
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignUpperCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignUpperRight		: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignMiddleLeft		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignMiddleCenter	: indentX = indentX + indentX	: indentY = indentY + indentY
		CASE $$AlignMiddleRight		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignLowerLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignLowerCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignLowerRight		: indentX = indentX + 2				: indentY = indentY + 2
	END SELECT
	width = textWidth + scrollWidth + border + indentX
	height = textHeight + scrollHeight + border + indentY
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
	v2 = width : v3 = height
END SUB
'
'
' *****  GotKeyboardFocus  *****  after func[#GotKeyboardFocus]
'
SUB GotKeyboardFocus
	TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Inline  *****  r1$ enters with prompt$ and leaves with inline$
'
SUB Inline
	IF r1$ THEN GOSUB Print : r1$ = ""
	XgrGetGridWindow (grid, @window)
	##USERWAITING = grid									' waiting for newline character
'
	DO
		XuiGrabTextString (grid, #GrabTextString, 0, 0, 0, 0, 0, @text$)
		IF text$ THEN
			nl = INSTR (text$, "\n")
			IF nl THEN
				r1$ = LEFT$(text$, nl - 1)
				text$ = MID$(text$, nl + 1)
				IF r1$ THEN
					IF (r1${UBOUND(r1$)} = '\r') THEN r1$ = RCLIP$(r1$,1)
				END IF
				XuiPokeTextString (grid, #PokeTextString, 0, 0, 0, 0, 0, @text$)
				##USERWAITING = $$FALSE
				EXIT SUB
			END IF
			IF text$ THEN XuiPokeTextString (grid, #PokeTextString, 0, 0, 0, 0, 0, @text$)
		END IF
'
' throw away messages for user window and grids,
' except for redraws and messages for this grid.
'
		DO
			delete = $$TRUE
			IFZ ##USERWAITING THEN EXIT SUB										' wait cancelled
			XgrPeekMessage (@wingrid, @message, 0, 0, @v2, 0, 0, 0)
			IFZ ##USERWAITING THEN EXIT SUB										' wait cancelled
			XgrGetMessageType (message, @messageType)
			SELECT CASE messageType
				CASE $$Window	:	messageWindow = wingrid
												whomask = windowInfo[messageWindow].whomask
												IFZ whomask THEN delete = $$FALSE
												SELECT CASE message
													CASE #WindowRedraw	: delete = $$FALSE
												END SELECT
				CASE $$Grid		:	XgrGetGridWindow (wingrid, @messageWindow)
												IF (messageWindow = window) THEN
													delete = $$FALSE
												ELSE
													whomask = windowInfo[messageWindow].whomask
													IFZ whomask THEN delete = $$FALSE
													SELECT CASE message
														CASE #Redraw						: delete = $$FALSE
														CASE #RedrawGrid				: delete = $$FALSE
														CASE #LostKeyboardFocus	: delete = $$FALSE
													END SELECT
												END IF
				CASE ELSE			:	XgrDeleteMessages (1) : DO DO		' discard message
			END SELECT
			IF (messageWindow = helpWindow) THEN delete = $$FALSE
			IF delete THEN XgrDeleteMessages (1) : DO DO
			XgrProcessMessages (1)
			IF (message = #WindowKeyDown) THEN
				IF (v2 AND $$CtrlBit) THEN
					SELECT CASE v2{$$VirtualKey}
						CASE $$KeyBreak	: ##USERWAITING = $$FALSE	' Break - Halt execution
															QUIT (0)
															EXIT SUB
						CASE $$KeyC			: ##USERWAITING = $$FALSE	' ^C - Pause execution
															XitSoftBreak()
															EXIT SUB
					END SELECT
				END IF
				EXIT DO
			END IF
		LOOP
	LOOP
	##USERWAITING = $$FALSE
END SUB
'
'
' *****  InputBuffer  *****  From KeyDown: virtualKey/key (ASCII key to buffer)
'
SUB InputBuffer
	XuiGetValue (grid, #GetValue, @ctrlS, 0, 0, 0, 0, $ctrlS)
	IF ctrlS THEN EXIT SUB
	XuiGrabTextString (grid, #GrabTextString, 0, 0, 0, 0, 0, @text$)
	IF key THEN
		SELECT CASE key
			CASE $$KeyEnter	: text$ = text$ + "\n"
			CASE ELSE				: text$ = text$ + CHR$(key)
		END SELECT
	ELSE
		IF (virtualKey = $$KeyBackspace) THEN
			IF text$ THEN text$ = RCLIP$(text$,1)
		END IF
	END IF
	XuiPokeTextString (grid, #PokeTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  KeyDown  *****
'
'		ctrl	= MORE of the same
'		shift	= extend selection
'			CursorH:
'				OneLess:		left one char			$$KeyLeftArrow
'				SomeLess:		left one word			$$KeyLeftArrow  ^
'				OneMore:		right one char		$$KeyRightArrow
'				SomeMore:		right one word		$$KeyRightArrow  ^
'				Minimum:		beg line					$$KeyHome
'				Maximum:		end line					$$KeyEnd
'			CursorV:
'				OneLess:		up one line				$$KeyUpArrow
'				SomeLess:		up half page			$$KeyUpArrow  ^
'				OneMore:		down one line			$$KeyDownArrow
'				SomeMore:		down half page		$$KeyDownArrow
'				Minimum:		beg Text					$$KeyHome  ^
'				Maximum:		end Text					$$KeyEnd  ^
'			ScrollV:
'				SomeMore:		down half page		$$KeyPageDown
'				MuchMore:		down one page			$$KeyPageDown  ^
'				SomeLess:		up half page			$$KeyPageUp
'				MuchLess:		up one page				$$KeyPageUp  ^
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
'
	state = v2
	alt = state AND $$AltBit
	ctrl = state AND $$CtrlBit
	shift = state AND $$ShiftBit
	virtualKey = state{$$VirtualKey}
	contents = state{$$StateContents}
'
	XuiGetValue (grid, #GetValue, @ctrlS, 0, 0, 0, 0, $ctrlS)
	XuiGetValue (grid, #GetValue, @console, 0, 0, 0, 0, $console)
	XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $textGrid)
'
	IF ctrl THEN
		SELECT CASE virtualKey
			CASE $$KeyQ
'						PRINT "^Q"
						IFZ ctrlS THEN EXIT SELECT
'						r1 = $$FALSE								' prevent #GetTextString error
						ctrlS = $$FALSE
						XuiSetValue (grid, #SetValue, ctrlS, 0, 0, 0, 0, $ctrlS)
						XuiGrabTextString (textGrid, #GrabTextString, 0, 0, 0, 0, 0, @print$)
						IF print$ THEN GOSUB PrintString
			CASE $$KeyS
'						PRINT "^S"
						IF ctrlS THEN EXIT SELECT
						ctrlS = $$TRUE
						XuiSetValue (grid, #SetValue, ctrlS, 0, 0, 0, 0, $ctrlS)
			CASE $$KeyBreak										' Break -- Halts execution
'						PRINT "*** Break ***"
						ctrlS = $$FALSE
						XuiSetValue (grid, #SetValue, ctrlS, 0, 0, 0, 0, $ctrlS)
						QUIT(0)
						EXIT SUB
			CASE $$KeyC												' ^C -- Just pauses
'						PRINT "*** ^C ***"
						ctrlS = $$FALSE
						XuiSetValue (grid, #SetValue, ctrlS, 0, 0, 0, 0, $ctrlS)
						XitSoftBreak()
						EXIT SUB
		END SELECT
	END IF
	XuiGetValue (grid, #GetValue, @ctrlS, 0, 0, 0, 0, $ctrlS)
	IF ctrlS THEN EXIT SUB
'
	IF (contents = 1) THEN													' ASCII
		key = state{8,0}
		IF charsetTextChar[key] THEN
			shiftEnter = (virtualKey = $$KeyEnter) && shift
			IFZ shiftEnter THEN
				abort = 0
				XuiCallback (grid, #TextEvent, v0, v1, state, v3, @abort, grid)
				IF (abort = -1) THEN RETURN
				XgrGetTextSelectionGrid (@focusGrid)
				IF (grid = focusGrid) THEN
					TextMessage (grid, #GetTextSelection, 0, 0, 0, 0, 0, @text$)
					IF text$ THEN TextMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
				END IF
				IF console THEN GOSUB InputBuffer
				TextMessage (grid, #GetTextArrayBounds, 0, 0, @lastPos, @lastLine, 0, 0)
				TextMessage (grid, #SetTextCursor, lastPos, lastLine, 0, 0, 0, 0)
				TextMessage (grid, #TextInsert, 0, 0, 0, key, 0, 0)
				EXIT SUB
			END IF
		END IF
	END IF
'
	selectAction = $$SelectCancel
	IF shift THEN selectAction = $$SelectDrag
'
	cursorMessage = 0
	SELECT CASE virtualKey
		CASE $$KeyBackspace, $$KeyDelete
					IF ctrl THEN									' Clear screen
						DIM text$[]									' Does not clear buffers
						TextMessage (grid, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
						cursorMessage = #Redraw
					ELSE
						cursorMessage = #TextDelete
						action = virtualKey
						IF console THEN
							IF (virtualKey = $$KeyBackspace) THEN
								key = 0
								GOSUB InputBuffer
							END IF
						END IF
					END IF
		CASE $$KeyInsert
		CASE $$KeyLeftArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeLess
					ELSE
						action = #OneLess
					END IF
		CASE $$KeyRightArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeMore
					ELSE
						action = #OneMore
					END IF
		CASE $$KeyUpArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeLess											' beginning of page
					ELSE
						action = #OneLess											' up one line
					END IF
		CASE $$KeyDownArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeMore											' end of page
					ELSE
						action = #OneMore											' down one line
					END IF
		CASE $$KeyHome
					action = #Minimum
					IF ctrl THEN
						cursorMessage = #CursorV								' beginning of text
					ELSE
						cursorMessage = #CursorH								' beginning of line
					END IF
		CASE $$KeyEnd
					action = #Maximum
					IF ctrl THEN
						cursorMessage = #CursorV								' end of text
					ELSE
						cursorMessage = #CursorH								' end of line
					END IF
		CASE $$KeyPageDown
					cursorMessage = #ScrollV
					IF ctrl THEN
						action = #MuchMore											' down one page
					ELSE
						action = #SomeMore											' down half page
					END IF
		CASE $$KeyPageUp
					cursorMessage = #ScrollV
					IF ctrl THEN
						action = #MuchLess											' up one page
					ELSE
						action = #SomeLess											' up half page
					END IF
	END SELECT
'
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, state, v3, @abort, grid)
	IF (abort = -1) THEN RETURN
	SELECT CASE virtualKey
		CASE $$KeyEnter:
					IF shift THEN
						XuiCallback (grid, #Selection, state, 0, 0, 0, 0, 0)
						EXIT SUB
					END IF
		CASE $$KeyEscape
					XuiCallback (grid, #Selection, state, 0, 0, 0, 0, 0)
					EXIT SUB
	END SELECT
'
	IF cursorMessage THEN
		TextMessage (grid, cursorMessage, 0, 0, selectAction, action, 0, action)
	ELSE
		SELECT CASE virtualKey
			CASE $$KeyInsert
				IF ctrl THEN															' grab into buffer 0
					XgrGetTextSelectionGrid (@focusGrid)
					IF (grid = focusGrid) THEN
						TextMessage (grid, #GetTextSelection, @begPos, @begLine, 0, 0, 0, @text$)
						IF text$ THEN
							XgrSetClipboard (0, $$ClipboardTypeText, @text$, @null[])
							TextMessage (grid, #SetTextCursor, begPos, begLine, -1, -1, 0, 0)
							TextMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
						END IF
					END IF
				ELSE																			' insert
					XgrGetClipboard (0, $$ClipboardTypeText, @text$, @null[])
					IF text$ THEN
						TextMessage (grid, #GetTextSelection, @begPos, @begLine, @endPos, @endLine, 0, 0)
						TextMessage (grid, #TextReplace, begPos, begLine, endPos, endLine, 0, @text$)
						TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
					END IF
				END IF
		END SELECT
	END IF
END SUB
'
'
' *****  LostKeyboardFocus  *****
'
SUB LostKeyboardFocus
	TextMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  LostTextSelection  *****
'
SUB LostTextSelection
	TextMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
END SUB
'
'
' *****  MouseDown  *****
'
'		v01		= x,y
'		v2		= state
'		shift	= extend selection
'		v01 low bit clipped to avoid jiggle effects
'
SUB MouseDown
	IFZ callback THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
'
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
'
	IF (v2 AND $$ShiftBit) THEN
		TextMessage (grid, #CursorH, v0, v1, $$SelectExtend, #Change, 0, #Change)
		EXIT SUB
	END IF
	TextMessage (grid, #CursorH, v0, v1, $$SelectSet, #Change, 0, #Change)
'
	clicks = v2{3,4}
	SELECT CASE clicks
		CASE 2																					' select word
			TextMessage (grid, #GetTextCursor, @cursorPos, @cursorLine, 0, 0, 0, 0)
			XuiGetTextArrayLine (grid, #GetTextArrayLine, cursorLine, 0, 0, 0, 0, @text$)
			IFZ text$ THEN EXIT SELECT
			foundWord = $$FALSE
			SELECT CASE text${cursorPos}
				CASE 0, ' ', '\t', '\n'
				CASE ELSE:
					foundWord = $$TRUE
					endPos = INCHR (text$, " \t\n", cursorPos + 1)
					IFZ endPos THEN
						endPos = LEN(text$)
					ELSE
						DEC endPos
					END IF
					begPos = 0
					IF cursorPos THEN
						begPos = RINCHR (text$, " \t\n", cursorPos)
					END IF
			END SELECT
			IFF foundWord THEN
				IF cursorPos THEN
					SELECT CASE text${cursorPos - 1}
						CASE 0, ' ', '\t', '\n'
						CASE ELSE:
							foundWord = $$TRUE
							endPos = cursorPos
							begPos = 0
							begPos = RINCHR (text$, " \t\n", cursorPos)
					END SELECT
				END IF
			END IF
			IF foundWord THEN
				XgrSetTextSelectionGrid (grid)
				TextMessage (grid, #SetTextSelection, begPos, cursorLine, endPos, cursorLine, 0, 0)
				TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
			END IF
		CASE 3																					' select entire line w \n
			XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$[] THEN EXIT SELECT
			uText = UBOUND(text$[])
			XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
			TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
			endLine = cursorLine + 1
			IF (endLine > uText) THEN endLine = uText
			XgrSetTextSelectionGrid (grid)
			TextMessage (grid, #SetTextSelection, 0, cursorLine, 0, endLine, 0, 0)
			TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
		CASE 4																				' select entire text
			XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$[] THEN EXIT SELECT
			uText = UBOUND(text$[])
			endPos = LEN(text$[uText])
			XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
			XgrSetTextSelectionGrid (grid)
			TextMessage (grid, #SetTextSelection, 0, 0, endPos, uText, 0, 0)
			TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  MouseDrag  *****  v01 low bit clipped to avoid jiggle effects
'
SUB MouseDrag
	IFZ callback THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetKeyboardFocus (grid, #GetKeyboardFocus, @keyboardFocusGrid, 0, 0, 0, 0, 0)
	IF (grid != keyboardFocusGrid) THEN EXIT SUB
	XgrSetTextSelectionGrid (grid)
	TextMessage (grid, #CursorH, v0, v1, $$SelectDrag, #Change, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
'	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiConsole(), 0, 0, 0, $$FALSE)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XgrGetMouseInfo (@window, @g, @xWin, @yWin, @state, @time)
	XuiGetKids (grid, #GetKids, @g1, @k1, @k2, @k3, 0, @k4 )
	IF ((g == k1) || (g == k3)) THEN
			SELECT CASE SIGN(v3)
				CASE -1	: TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeMore)
				CASE 1	:	TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeLess)
			END SELECT
		END IF
END SUB
'
'
' *****  PassToText  *****
'
SUB PassToText
	TextMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Print  *****
'
SUB Print
	print$ = ""
	SWAP print$, r1$
	GOSUB PrintString
	SWAP print$, r1$
END SUB
'
'
' *****  PrintString  *****  print$
'
SUB PrintString
	XuiGetValue (grid, #GetValue, @ctrlS, 0, 0, 0, 0, $ctrlS)
	IF ctrlS THEN
		XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $textGrid)
		XuiGrabTextString (textGrid, #GrabTextString, 0, 0, 0, 0, 0, @text$)
		text$ = text$ + print$
		XuiPokeTextString (textGrid, #PokeTextString, 0, 0, 0, 0, 0, @text$)
	ELSE
		TextMessage (grid, #GetTextArrayBounds, 0, 0, @lastPos, @lastLine, 0, 0)
		TextMessage (grid, #GetTextCursor, 0, 0, @topIndent, @topLine, 0, 0)
		TextMessage (grid, #TextReplace, lastPos, lastLine, lastPos, lastLine, 0, @print$)
		TextMessage (grid, #GetTextArrayBounds, 0, 0, @lastPos2, @lastLine2, 0, 0)
		TextMessage (grid, #SetTextCursor, lastPos2, lastLine2, 0, 0, 0, 0)
		TextMessage (grid, #GetTextCursor, @lastPos3, @lastLine3, @topIndent2, @topLine2, 0, 0)
		IF ((topLine = topLine2) AND (topIndent = topIndent2)) THEN
			TextMessage (grid, #RedrawLines, lastLine, lastLine3, 0, 0, 0, 0)
		END IF
	END IF
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetValue (grid, #GetValue, @shown, 0, 0, 0, 0, $cursorShown)
	IF shown THEN TextMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, $$SelectNoChange, 0, 0, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollV, 0)
	IF shown THEN TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  SetValues  *****  v0 = enable input buffer = T/F
'
SUB SetValues
	IF (r1 != 0) THEN EXIT SUB
	XuiGetValue (grid, #GetValue, @enable, 0, 0, 0, 0, $console)
	IF (v0 = enable) THEN EXIT SUB
	XuiGrabTextString (grid, #GrabTextString, 0, 0, 0, 0, 0, @text$)
	text$ = ""
	XuiSetValue (grid, #SetValue, v0, 0, 0, 0, 0, $console)
END SUB
'
'
' *****  Scroll  *****
'
SUB Scroll
	SELECT CASE r0
		CASE $ScrollH		: scroll = #ScrollH
		CASE $ScrollV		: scroll = #ScrollV
	END SELECT
	TextMessage (grid, scroll, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetAlign  *****
'
SUB SetAlign
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetBorder  *****
'
SUB SetBorder
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetIndent  *****
'
SUB SetIndent
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetKeyboardFocus  *****  v2 = state : shift = extend selection
'
SUB SetKeyboardFocus
'	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
'	XgrSetTextSelectionGrid (grid)
'	TextMessage (grid, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
'	TextMessage (grid, #SetTextSelection, cp, cl, cp, cl, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiSendToKid (grid, #GetSize, @hx, @hy, @hw, @hh, $ScrollH, 0)
	XuiSendToKid (grid, #GetSize, @vx, @vy, @vw, @vh, $ScrollV, 0)
'
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
'
	SELECT CASE style
		CASE 0	: scrollBarSize = 12
		CASE 1	: scrollBarSize = 12
		CASE 2	: scrollBarSize = 16
		CASE 3	: scrollBarSize = 16
	END SELECT
'
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	x		= dx
	y		= dy
	w		= v2 - dx2 - scrollBarSize - 1
	h		= v3 - dy2 - scrollBarSize - 1
	XuiSendToKid (grid, #Resize, x, y, w, h, $Text, 0)
	TextMessage (grid, #Resize, x, y, w, h, 0, 0)
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - scrollBarSize
	h		= scrollBarSize
	x		= dx
	y		= v3 - dy - h
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollH, 0)
'
	w		= scrollBarSize
	h		= v3 - dy2 - scrollBarSize
	x		= v2 - dx - w
	y		= dy
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollV, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
'  ***** SetStyle *****
'
' $Style0 = 0		' normal scroll bars, flat buttons
' $Style1 = 1		' normal scroll bars, flat arrowbuttons
' $Style1 = 2		' recessed scroll bars, arrow buttons
' $Style2 = 3		' windows-style scroll bars, arrow buttons
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 3
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollV, 0)
  XuiGetSize ( grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0 )
	GOSUB Resize
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= 0
	func[#GetTextArray]				= 0
	func[#GetTextStrings]			= &XuiGetTextArray ()
	func[#GetValue]						= 0
	func[#GetValues]					= 0
	func[#GrabTextArray]			= 0
	func[#PokeTextArray]			= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetBorderOffset]		= 0
	func[#SetTextArray]				= 0
	func[#SetValue]						= 0
	func[#SetValues]					= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Change]							= SUBADDRESS (Scroll)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextCursor]				= SUBADDRESS (PassToText)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#GetTextArray]				= SUBADDRESS (PassToText)
	sub[#GetTextArrayLine]		= SUBADDRESS (PassToText)
	sub[#GetTextArrayBounds]	= SUBADDRESS (PassToText)
	sub[#GetTextPosition]			= SUBADDRESS (PassToText)
	sub[#GetTextSelection]		= SUBADDRESS (PassToText)
	sub[#GetValue]						= SUBADDRESS (GetValues)
	sub[#GetValues]						= SUBADDRESS (GetValues)
	sub[#GotKeyboardFocus]		= SUBADDRESS (GotKeyboardFocus)
	sub[#GrabTextArray]				= SUBADDRESS (PassToText)
	sub[#HideTextCursor]			= SUBADDRESS (PassToText)
	sub[#Inline]							= SUBADDRESS (Inline)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#LostKeyboardFocus]		= SUBADDRESS (LostKeyboardFocus)
	sub[#LostTextSelection]		= SUBADDRESS (LostTextSelection)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#MouseWheel]					= SUBADDRESS (MouseWheel)
	sub[#MuchLess]						= SUBADDRESS (Scroll)
	sub[#MuchMore]						= SUBADDRESS (Scroll)
	sub[#OneLess]							= SUBADDRESS (Scroll)
	sub[#OneMore]							= SUBADDRESS (Scroll)
	sub[#PokeTextArray]				= SUBADDRESS (PassToText)
	sub[#Print]								= SUBADDRESS (Print)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetAlign]						= SUBADDRESS (SetAlign)
	sub[#SetBorder]						= SUBADDRESS (SetBorder)
	sub[#SetIndent]						= SUBADDRESS (SetIndent)
	sub[#SetFont]							= SUBADDRESS (PassToText)
	sub[#SetFontNumber]				= SUBADDRESS (PassToText)
	sub[#SetKeyboardFocus]		= SUBADDRESS (SetKeyboardFocus)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (PassToText)
	sub[#SetTextArrayLine]		= SUBADDRESS (PassToText)
	sub[#SetTextCursor]				= SUBADDRESS (PassToText)
	sub[#SetTextSelection]		= SUBADDRESS (PassToText)
	sub[#SetValue]						= SUBADDRESS (SetValues)
	sub[#SetValues]						= SUBADDRESS (SetValues)
	sub[#ShowTextCursor]			= SUBADDRESS (PassToText)
	sub[#SomeLess]						= SUBADDRESS (Scroll)
	sub[#SomeMore]						= SUBADDRESS (Scroll)
	sub[#TextDelete]					= SUBADDRESS (PassToText)
	sub[#TextInsert]					= SUBADDRESS (PassToText)
	sub[#TextReplace]					= SUBADDRESS (PassToText)
'
	IF func[0] THEN PRINT "XuiConsole() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiConsole() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiConsole, @"XuiConsole", &XuiConsole(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 256
	designHeight = 128
'
	gridType = XuiConsole
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        72)
	XuiSetGridTypeProperty (gridType, @"minHeight",       72)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       0)
	XuiSetGridTypeProperty (gridType, @"indentTop",        0)
	XuiSetGridTypeProperty (gridType, @"indentRight",      0)
	XuiSetGridTypeProperty (gridType, @"indentBottom",     0)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderNone)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextArray)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiCoordinate ()  #####
' ##############################
'
FUNCTION  XuiCoordinate (grid, message, v0, v1, v2, v3, r0, (r1, r1[], r1$, r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiCoordinate
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiCoordinate) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiCoordinate, @v0, @v1, @v2, @v3, r0, r1, &XuiCoordinate())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiCoordinate")
END SUB
'
'
' *****  RedrawGrid  ****
'
SUB RedrawGrid
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
'	func[#Redraw]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
'
	IF func[0] THEN PRINT "XuiCoordinate() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiCoordinate() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiCoordinate, @"Coordinate", &XuiCoordinate(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 32
	designHeight = 32
'
	gridType = XuiCoordinate
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        0)
	XuiSetGridTypeProperty (gridType, @"minHeight",       0)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiDialog2B ()  #####  Label, TextLine, and 2 PushButtons
' ############################
'
FUNCTION  XuiDialog2B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiDialog2B
'
	$XuiDialog2B	= 0
	$Label				= 1
	$TextLine			= 2
	$Button0			= 3
	$Button1			= 4
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDialog2B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiDialog2B, @v0, @v1, @v2, @v3, r0, r1, &XuiDialog2B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiTextLine    (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDialog2B(), -1, -1, $TextLine, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDialog2B(), -1, -1, $Button0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDialog2B(), -1, -1, $Button1, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDialog2B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @textWidth, @textHeight, $TextLine, 8)
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button1
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth + buttonWidth
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = labelHeight + buttonHeight + textHeight + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	h = labelHeight + buttonHeight + textHeight + bw + bw
	IF (v3 >= h + 4) THEN
		buttonHeight = buttonHeight + 4 : h = h + 4
		IF (v3 >= h + 4) THEN textHeight = textHeight + 4
	END IF
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - textHeight - bw - bw
	buttonWidth	= labelWidth >> 1
	w0					= buttonWidth
	w1					= labelWidth - w0
'
	x = bw
	y = bw
	w = labelWidth
	XuiSendToKid (grid, #Resize, x, y, w, labelHeight, $Label, 0)
'
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, w, textHeight, $TextLine, 0)
'
	h = buttonHeight
	y = y + textHeight
	XuiSendToKid (grid, #Resize, x, y, w0, h, $Button0, 0) : x = x + w0
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0) : x = x + w1
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]           = &XuiCallback()
	func[#GetSmallestSize]    = 0
	func[#Resize]             = 0
'
	DIM sub[upperMessage]
  sub[#Callback]            = SUBADDRESS (Callback)
	sub[#Create]              = SUBADDRESS (Create)
	sub[#CreateWindow]        = SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]     = SUBADDRESS (GetSmallestSize)
	sub[#Resize]              = SUBADDRESS (Resize)
  sub[#Selection]						= SUBADDRESS (Selection)
'
	IF func[0] THEN PRINT "XuiDialog2B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDialog2B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiDialog2B, @"XuiDialog2B", &XuiDialog2B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 160
	designHeight = 68
'
	gridType = XuiDialog2B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       24)
'	XuiSetGridTypeProperty (gridType, @"minWidth",        designWidth)
'	XuiSetGridTypeProperty (gridType, @"minHeight",       designHeight)
'	XuiSetGridTypeProperty (gridType, @"maxWidth",        designWidth)
'	XuiSetGridTypeProperty (gridType, @"maxHeight",       designHeight)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",        $TextLine)
	XuiSetGridTypeProperty (gridType, @"inputTextString", $TextLine)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiDialog3B ()  #####  Label, TextLine, 3 PushButtons
' ############################
'
FUNCTION  XuiDialog3B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
  STATIC	SUBADDR  sub[]
	STATIC	upperMessage
  STATIC	XuiDialog3B
'
  $XuiDialog3B   =  0  ' kid  0 grid type = XuiDialog3B
  $Label         =  1  ' kid  1 grid type = XuiLabel
  $TextLine      =  2  ' kid  2 grid type = XuiTextLine
  $Button0       =  3  ' kid  3 grid type = XuiPushButton
  $Button1       =  4  ' kid  4 grid type = XuiPushButton
  $Button2       =  5  ' kid  5 grid type = XuiPushButton
'
  IFZ sub[] THEN GOSUB Initialize
  IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDialog3B) THEN RETURN
  GOSUB @sub[message]
  RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
  IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiCreateGrid  (@grid, XuiDialog3B, @v0, @v1, @v2, @v3, r0, r1, &XuiDialog3B())
  XuiLabel       (@g, #Create, 4, 4, 312, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
  XuiTextLine    (@g, #Create, 4, 24, 312, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog3B(), -1, -1, $TextLine, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
  XuiPushButton  (@g, #Create, 4, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog3B(), -1, -1, $Button0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
  XuiPushButton  (@g, #Create, 108, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog3B(), -1, -1, $Button1, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" retry ")
  XuiPushButton  (@g, #Create, 212, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog3B(), -1, -1, $Button2, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
  GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
  v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
  GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDialog3B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @textWidth, @textHeight, $TextLine, 8)
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button2
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth + buttonWidth + buttonWidth
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = labelHeight + buttonHeight + textHeight + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	h = labelHeight + buttonHeight + textHeight + bw + bw
	IF (v3 >= (h + 4)) THEN h = h + 4 : buttonHeight = buttonHeight + 4
	IF (v3 >= (h + 4)) THEN h = h + 4 : textHeight = textHeight + 4
	IF (v3 >= (h + 4)) THEN h = h + 4 : labelHeight = labelHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - textHeight - bw - bw
	buttonWidth	= labelWidth \ 3
	w0 = buttonWidth
	w1 = labelWidth - w0 - w0
	w2 = buttonWidth
'
	x = bw
	y = bw
	w = labelWidth
	XuiSendToKid (grid, #Resize, x, y, w, labelHeight, $Label, 0)
'
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, w, textHeight, $TextLine, 0)
'
	h = buttonHeight
	y = y + textHeight
	XuiSendToKid (grid, #Resize, x, y, w0, h, $Button0, 0) : x = x + w0
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0) : x = x + w1
	XuiSendToKid (grid, #Resize, x, y, w2, h, $Button2, 0) : x = x + w2
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiDialog3B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDialog3B() : Initialize : error ::: (undefined message)"
  XuiRegisterGridType (@XuiDialog3B, "XuiDialog3B", &XuiDialog3B(), @func[], @sub[])
'
  designX = 0
  designY = 0
  designWidth = 240
  designHeight = 68
'
	gridType = XuiDialog3B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       24)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $TextLine)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $TextLine)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiDialog4B ()  #####  Label, TextLine, 4 PushButtons
' ############################
'
FUNCTION  XuiDialog4B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
  STATIC	SUBADDR  sub[]
	STATIC	upperMessage
  STATIC	XuiDialog4B
'
  $XuiDialog4B   =  0  ' kid  0 grid type = XuiDialog4B
  $Label         =  1  ' kid  1 grid type = XuiLabel
  $TextLine      =  2  ' kid  2 grid type = XuiTextLine
  $Button0       =  3  ' kid  3 grid type = XuiPushButton
  $Button1       =  4  ' kid  4 grid type = XuiPushButton
  $Button2       =  5  ' kid  5 grid type = XuiPushButton
  $Button3       =  6  ' kid  6 grid type = XuiPushButton
'
  IFZ sub[] THEN GOSUB Initialize
  IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDialog4B) THEN RETURN
  GOSUB @sub[message]
  RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
  IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiCreateGrid  (@grid, XuiDialog4B, @v0, @v1, @v2, @v3, r0, r1, &XuiDialog4B())
  XuiLabel       (@g, #Create, 4, 4, 312, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
  XuiTextLine    (@g, #Create, 4, 24, 312, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog4B(), -1, -1, $TextLine, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
  XuiPushButton  (@g, #Create, 4, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog4B(), -1, -1, $Button0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
  XuiPushButton  (@g, #Create, 108, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog4B(), -1, -1, $Button1, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" update ")
  XuiPushButton  (@g, #Create, 212, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog4B(), -1, -1, $Button2, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" retry ")
  XuiPushButton  (@g, #Create, 212, 48, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiDialog4B(), -1, -1, $Button3, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button3")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
  GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
  v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
  GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDialog4B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @textWidth, @textHeight, $TextLine, 8)
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button3
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth << 2
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = labelHeight + buttonHeight + textHeight + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	h = labelHeight + buttonHeight + textHeight + bw + bw
	IF (v3 >= (h + 4)) THEN h = h + 4 : buttonHeight = buttonHeight + 4
	IF (v3 >= (h + 4)) THEN h = h + 4 : textHeight = textHeight + 4
	IF (v3 >= (h + 4)) THEN h = h + 4 : labelHeight = labelHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - textHeight - bw - bw
	buttonWidth	= labelWidth >> 2
	w0 = buttonWidth
	w1 = w0
	w2 = w1
	w3 = labelWidth - w0 - w1 - w2
'
	x = bw
	y = bw
	w = labelWidth
	XuiSendToKid (grid, #Resize, x, y, w, labelHeight, $Label, 0)
'
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, w, textHeight, $TextLine, 0)
'
	h = buttonHeight
	y = y + textHeight
	XuiSendToKid (grid, #Resize, x, y, w0, h, $Button0, 0) : x = x + w0
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0) : x = x + w1
	XuiSendToKid (grid, #Resize, x, y, w2, h, $Button2, 0) : x = x + w2
	XuiSendToKid (grid, #Resize, x, y, w3, h, $Button3, 0) : x = x + w3
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiDialog4B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDialog4B() : Initialize : error ::: (undefined message)"
  XuiRegisterGridType (@XuiDialog4B, "XuiDialog4B", &XuiDialog4B(), @func[], @sub[])
'
  designX = 0
  designY = 0
  designWidth = 320
  designHeight = 68
'
	gridType = XuiDialog4B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       24)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $TextLine)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $TextLine)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ################################
' #####  XuiDirectoryBox ()  #####
' ################################
'
FUNCTION  XuiDirectoryBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiDirectoryBox
'
	$DirectoryBox = 0
	$Text					= 1
	$ScrollH      = 2
	$ScrollV      = 3
'
	$TextGrid     = 0
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDirectoryBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiDirectoryBox, @v0, @v1, @v2, @v3, r0, r1, &XuiDirectoryBox())
	XuiSendMessage ( grid, #CreateValueArray, 31, 0, 0, 0, 0, 0)
	XuiArea        (@g, #Create, v0, v1, v2, v3, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDirectoryBox(), -1, -1, $Text, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Area")
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #SetValue, g, 0, 0, 0, 0, $TextGrid)
	TextMessage    ( grid, #SetValues, 0, 0, 0, 0, 0, 0)
	XuiScrollBarH  (@g, #Create, 4, v3-16, v2-8, 12, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDirectoryBox(), -1, -1, $ScrollH, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollH")
	XuiScrollBarV  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDirectoryBox(), -1, -1, $ScrollV, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollV")
	GOSUB Resize
	GOSUB Update
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDirectoryBox")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $TextGrid)
	IF textGrid THEN
		XuiSendMessage (textGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $TextGrid)
	END IF
	XuiDestroy (grid, #Destroy, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  GetSmallestSize  *****  v0 = # columns, v1 = # rows
'
SUB GetSmallestSize
	XuiGetMaxMinSize (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	XuiGetAlign (grid, #GetAlign, @align, @justify, @indentX, @indentY, 0, @borderWidth)
	border = borderWidth + borderWidth
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	textWidth = maxCharWidth * MAX(v0, 1)
	textHeight = maxCharHeight * MAX(v1, 1)
	scrollWidth = 12
	scrollHeight = 12
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignUpperCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignUpperRight		: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignMiddleLeft		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignMiddleCenter	: indentX = indentX + indentX	: indentY = indentY + indentY
		CASE $$AlignMiddleRight		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignLowerLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignLowerCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignLowerRight		: indentX = indentX + 2				: indentY = indentY + 2
	END SELECT
	width = textWidth + scrollWidth + border + indentX
	height = textHeight + scrollHeight + border + indentY
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
	v2 = width : v3 = height
END SUB
'
'
' *****  KeyDown  *****  CTRL means more of the same
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	ctrl = (v2 AND $$CtrlBit)													' v2 = state
	cursorMessage = $$FALSE
'
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyLeftArrow
					cursorMessage = #ScrollH									' DirectoryBox widget SCROLLs here
					IF ctrl THEN
						action = #MuchLess
					ELSE
						action = #OneLess
					END IF
		CASE $$KeyRightArrow
					cursorMessage = #ScrollH									' DirectoryBox widget SCROLLs here
					IF ctrl THEN
						action = #MuchMore
					ELSE
						action = #OneMore
					END IF
		CASE $$KeyUpArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeLess											' beginning of page
					ELSE
						action = #OneLess											' up one line
					END IF
		CASE $$KeyDownArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeMore											' end of page
					ELSE
						action = #OneMore											' down one line
					END IF
		CASE $$KeyHome
					action = #Minimum
					IF ctrl THEN
						cursorMessage = #CursorV								' beginning of text
					ELSE
						cursorMessage = #CursorH								' beginning of line
					END IF
		CASE $$KeyEnd
					action = #Maximum
					IF ctrl THEN
						cursorMessage = #CursorV								' end of text
					ELSE
						cursorMessage = #CursorH								' end of line
					END IF
		CASE $$KeyPageDown
					cursorMessage = #ScrollV
					action = #MuchMore
		CASE $$KeyPageUp
					cursorMessage = #ScrollV
					action = #MuchLess
	END SELECT
'
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort = -1) THEN EXIT SUB
'
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyEnter
					TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
					GOSUB SendSelectionCallback
'					XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
		CASE $$KeyEscape
					XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
	END SELECT
	IF cursorMessage THEN TextMessage (grid, cursorMessage, 0, 0, 0, 0, 0, action)
END SUB
'
'
' *****  MouseDown *****  DirectoryBox considers single and double clicks only
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiDirectoryBox(), 0, 0, 0, $$TRUE)
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	TextMessage (grid, #CursorH, vv0, vv1, 0, 0, 0, #Change)
	clicks = v2{3, 4}
	IF (clicks = 2) THEN
		TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
		GOSUB SendSelectionCallback
	END IF
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	TextMessage (grid, #CursorH, vv0, vv1, 0, 0, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiDirectoryBox(), 0, 0, 0, $$FALSE)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XgrGetMouseInfo (@window, @g, @xWin, @yWin, @state, @time)
	XuiGetKids (grid, #GetKids, @g1, @k1, @k2, @k3, 0, @k4 )
	IF ((g == k1) || (g == k3)) THEN
			SELECT CASE SIGN(v3)
				CASE -1	: TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeMore)
				CASE 1	:	TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeLess)
			END SELECT
		END IF
END SUB
'
'
' *****  PassToText  *****
'
SUB PassToText
	TextMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage  (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollV, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	x		= dx
	y		= dy
	w		= v2 - dx2 - 12
	h		= v3 - dy2 - 12
	XuiSendToKid (grid, #Resize, x, y, w, h, $Text, 0)
	TextMessage (grid, #Resize, x, y, w, h, 0, 0)
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - 12
	h		= 12
	x		= dx
	y		= v3 - dy - h - 1
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollH, 0)
'
	w		= 12
	h		= v3 - dy2 - 12
	x		= v2 - dx - w - 1
	y		= dy
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollV, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Scroll  *****
'
SUB Scroll
	SELECT CASE r0
		CASE $ScrollH		: scroll = #ScrollH
		CASE $ScrollV		: scroll = #ScrollV
	END SELECT
	TextMessage (grid, scroll, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SendSelectionCallback  *****
'
SUB SendSelectionCallback
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @dir$[])
	IFZ dir$[] THEN EXIT SUB
	path$ = dir$[0]
	IF (RIGHT$(path$,1) != $$PathSlash$) THEN path$ = path$ + $$PathSlash$
	temp$ = ""
	indent = 0
	FOR i = 1 TO cursorLine
		dir$ = dir$[i]
		length = LEN (dir$)
		dir$ = LTRIM$(dir$)
		delta = length - LEN (dir$)
		dir$ = TRIM$(dir$)
		SELECT CASE ALL TRUE
			CASE (delta = indent)
						temp$ = dir$
			CASE (delta > indent)
						IF temp$ THEN path$ = path$ + temp$
						IF (RIGHT$(path$,1) != $$PathSlash$) THEN path$ = path$ + $$PathSlash$
						indent = delta
						temp$ = dir$
			CASE (i = cursorLine)
						IF temp$ THEN path$ = path$ + temp$
						IF (RIGHT$(path$,1) != $$PathSlash$) THEN path$ = path$ + $$PathSlash$
		END SELECT
	NEXT i
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @path$)
	XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	dir$ = r1$
	GOSUB Update
END SUB
'
'
' *****  Update  *****
'
SUB Update
'	XstGetCurrentDirectory (@dir$)			' old way = bad way
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @dir$)
	GOSUB UpdateList
END SUB
'
'
' *****  UpdateList  *****
'
SUB UpdateList
	DO
		check$ = RIGHT$(dir$,1)
		IF ((check$ != $$PathSlash$) AND (check$ != "*")) THEN EXIT DO
		dir$ = RCLIP$(dir$,1)
	LOOP
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, dir$+$$PathSlash$)
'
	path$ = dir$ + $$PathSlash$ + "*"
	XstGetFiles (path$, @file$[])
	upper = UBOUND(file$[])
	XstQuickSort (@file$[], @empty[], 0, upper, $$SortCaseInsensitive OR $$SortAlphaNumeric)
'
	uppers$ = dir$
	DIM dir$[upper+255]
	colon = INSTR (uppers$, ":")
	slash = INSTR (uppers$, $$PathSlash$)
	IF colon THEN
		IF slash THEN
			dir$[0] = LEFT$ (uppers$, slash)
		ELSE
			dir$[0] = LEFT$ (uppers$, colon)
		END IF
		uppers$ = LCLIP$ (uppers$, colon)								' remove "c:"
	ELSE
		IF uppers$ THEN
			zip = uppers${0}
			IF (zip = $$PathSlash) THEN
				uppers$ = LCLIP$ (uppers$, 1)									' remove leading "\"
			END IF
		END IF
		dir$[0] = $$PathSlash$
	END IF
	insert$ = ""
	insert$ = " " + insert$
'
	DO
		bs = INSTR (uppers$, $$PathSlash$)
		IF bs THEN
			INC dir
			dir$[dir] = insert$ + LEFT$(uppers$,bs-1)
			uppers$ = LCLIP$(uppers$,bs)
			insert$ = " " + insert$
		END IF
	LOOP WHILE bs
'
	IF uppers$ THEN
		INC dir
		dir$[dir] = insert$ + uppers$
		insert$ = " " + insert$
	END IF
'
	FOR i = 0 TO upper
		file$ = dir$ + $$PathSlash$ + file$[i]
		XstGetFileAttributes (@file$, @attributes)
		IF (attributes AND $$FileDirectory) THEN
			IFZ (attributes AND ($$FileHidden OR $$FileSystem)) THEN
				INC dir
				dir$[dir] = insert$ + file$[i]
			END IF
		END IF
	NEXT i
	REDIM dir$[dir]
	TextMessage (grid, #SetTextArray, 0, 0, 0, 0, 0, @dir$[])
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= 0
	func[#GetTextArray]				= 0
	func[#GetTextStrings]			= 0
	func[#GrabTextArray]			= 0
	func[#PokeTextArray]			= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetTextArray]				= 0
	func[#SetTextStrings]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Change]							= SUBADDRESS (Scroll)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextCursor]				= SUBADDRESS (PassToText)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#GetTextArray]				= SUBADDRESS (PassToText)
	sub[#GetTextArrayBounds]	= SUBADDRESS (PassToText)
	sub[#GrabTextArray]				= SUBADDRESS (PassToText)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#MouseWheel]					= SUBADDRESS (MouseWheel)
	sub[#MuchLess]						= SUBADDRESS (Scroll)
	sub[#MuchMore]						= SUBADDRESS (Scroll)
	sub[#OneLess]							= SUBADDRESS (Scroll)
	sub[#OneMore]							= SUBADDRESS (Scroll)
	sub[#PokeTextArray]				= SUBADDRESS (PassToText)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetTextArray]				= SUBADDRESS (PassToText)
	sub[#SetTextCursor]				= SUBADDRESS (PassToText)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#SomeLess]						= SUBADDRESS (Scroll)
	sub[#SomeMore]						= SUBADDRESS (Scroll)
	sub[#TextReplace]					= SUBADDRESS (PassToText)
	sub[#Update]							= SUBADDRESS (Update)
'
	IF func[0] THEN PRINT "XuiDirectoryBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDirectoryBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiDirectoryBox, @"XuiDirectoryBox", &XuiDirectoryBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 80
'
	gridType = XuiDirectoryBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       24)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       8)
	XuiSetGridTypeProperty (gridType, @"indentTop",        4)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiDriveBox ()  #####
' ############################
'
FUNCTION  XuiDriveBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiDriveBox
'
	$DriveBox	= 0
	$Text			= 1
	$Button		= 2
	$Pulldown	= 3
'
	$Style0		= 0			' list goes up/down, text line not editable
	$Style1		= 1			' list always down, text line not editable
	$Style2		= 2			' list goes up/down, text line not editable
	$Style3		= 3			' list always down, text line not editable
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDriveBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiDriveBox, @v0, @v1, 128, 20, r0, r1, &XuiDriveBox())
	XuiTextLine    (@g, #Create, 0, 0, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDriveBox(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
	XuiArea        (@g, #Create, 108, 0, 20, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDriveBox(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Area")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, 0, 0, 0)
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"\x1F")
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	XgrGetGridWindow (grid, @window)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoSelect OR $$WindowTypeNoFrame OR window
	XuiPullDown    (@pulldown, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( pulldown, #SetCallback, grid, &XuiDriveBox(), -1, -1, $Pulldown, grid)
	XuiSendMessage ( pulldown, #SetGridName, 0, 0, 0, 0, 0, @"PullDown")
	XuiSendMessage ( pulldown, #SetGridProperties, -1, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #SetValues, pulldown, 0, 0, 0, 0, 0)
	GOSUB Resize
	GOSUB Update
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDriveBox")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValue (grid, #GetValue, @pulldown, 0, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  MouseDown  *****  (From the "pulldown" button)
'
SUB MouseDown
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, $Text, 0)
	IF ((style = 1) OR (style = 3)) THEN GOSUB PullDown ELSE GOSUB PullToggle
END SUB
'
'
' *****  MouseExit  *****
'
SUB MouseExit
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF (v2 < (v3 + 32)) THEN v2 = v3 + 32
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	x1 = 0 : y1 = 0 : w1 = v2 - v3
	x2 = v2 - v3 : y2 = 0 : w2 = v3
	XuiSendToKid (grid, #Resize, x1, y1, w1, v3, $Text, 0)
	XuiSendToKid (grid, #Resize, x2, y2, w2, v3, $Button, 0)
	XuiSendMessage (pulldown, #Resize, 0, 0, 0, 0, 0, 0)
	XgrGetGridWindow (pulldown, @pullWindow)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	SELECT CASE r0
		CASE $Text			: IF ((style != 1) AND (style != 3)) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, r0, 0, 0, 0, 0, 0)
		CASE $Button		:	PRINT "XuiDriveBox() : error : (Selection message from pulldown button)"
		CASE $Pulldown	: XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											IF ((v0 >= 0) AND (v0 <= UBOUND(text$[]))) THEN
												text$ = text$[v0]
												under = INSTR(text$, "_")
												colon = INSTR(text$, ":")
												IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
												IF colon THEN text$ = LEFT$(text$,colon)
												XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, text$)
												XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
											END IF
											IF (style != 1) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, r0, v0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  PullDown  *****
'
SUB PullDown
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 1)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #DisplayWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullUp  *****
'
SUB PullUp
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 1)
	XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullToggle  *****
'
SUB PullToggle
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF pullstate THEN GOSUB PullUp ELSE GOSUB PullDown
END SUB
'
'
' *****  Redraw  *****  After executing func[#Redraw]
'
SUB Redraw
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (text, -1)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	SELECT CASE style
		CASE 1,3:	XuiGetValues (grid, #GetValues, @pulldown, 0, 0, 0, 0, 0)
							XuiSendMessage (pulldown, #DisplayWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN EXIT SUB
	IF (style > 3) THEN EXIT SUB
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @oldStyle, 0, 0, 0, 0, 0)
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	IF (style = oldStyle) THEN EXIT SUB
	SELECT CASE style
		CASE 0:		XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
'							XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
		CASE 1:		XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
'							XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
'							XuiSendMessage (pulldown, #DisplayWindow, 0, 0, 0, 0, 0, 0)
		CASE 2:		XuiSendToKid (grid, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, 0, $Text, 0)
'							XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
		CASE 3:		XuiSendToKid (grid, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, 0, $Text, 0)
'							XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
'							XuiSendMessage (pulldown, #DisplayWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Text, r1)
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Button, r1)
	XuiSendMessage (pulldown, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XuiSendMessage (pulldown, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	XuiSendMessage (pulldown, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @r1$)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @r1$)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pulldown THEN EXIT SUB
	IF (r0 = $Text) THEN
		IF (v2 AND $$AltBit) THEN
			SELECT CASE v2{$$VirtualKey}
				CASE $$KeyUpArrow		: GOSUB PullUp		: r0 = -1			' cancel
				CASE $$KeyDownArrow	: GOSUB PullDown	: r0 = -1			' cancel
			END SELECT
		ELSE
			key = v2{$$VirtualKey}
			IF ((key = $$KeyUpArrow) OR (key = $$KeyDownArrow)) THEN
				XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, r1)
				r0 = -1
			END IF
		END IF
	END IF
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IF ((style = 2) OR (style = 3)) THEN r0 = -1
END SUB
'
'
' *****  Update  *****
'
SUB Update
	GOSUB UpdateDriveTextArray
END SUB
'
'
' *****  UpdateDriveTextArray  *****
'
SUB UpdateDriveTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XstGetCurrentDirectory (@current$)
	current$ = LEFT$ (current$,2)
	XstGetDrives (@count, @drive$[], @driveType[], @driveType$[])
	FOR i = 0 TO count-1
		drive$[i] = drive$[i] + "  " + driveType$[i]
	NEXT i
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @current$)
	XuiSendMessage (pulldown, #SetTextArray, 0, 0, 0, 0, 0, @drive$[])
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#GetTextArray]				= 0
	func[#GetTextString]			= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextArray]				= SUBADDRESS (GetTextArray)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseExit]						= SUBADDRESS (MouseExit)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetColor]						= SUBADDRESS (SetColor)
	sub[#SetColorExtra]				= SUBADDRESS (SetColor)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
	sub[#Update]							= SUBADDRESS (Update)
'
	IF func[0] THEN PRINT "XuiDriveBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDriveBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiDriveBox, @"XuiDriveBox", &XuiDriveBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiDriveBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###########################
' #####  XuiDropBox ()  #####
' ###########################
'
FUNCTION  XuiDropBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiDropBox
	STATIC	monitor
'
	$DropBox	= 0
	$Text			= 1
	$Button		= 2
	$PullDown	= 3
'
' $Style2 is not implemented because it causes annoying problems in some applications
'
	$Style0		= 0			' list goes up/down, text line editable
	$Style1		= 1			' list always down, text line editable
	$Style2		= 2			' first underline character is hotkey
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDropBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiDropBox, @v0, @v1, 128, 20, r0, r1, &XuiDropBox())
	XuiTextLine    (@g, #Create, 0, 0, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDropBox(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
	XuiPressButton (@g, #Create, 108, 0, 20, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDropBox(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"PressButton")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, 0, 0, 0)
	XuiSendMessage ( g, #SetTexture, $$TextureFlat, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #SetStyle, $$TriangleDown, 0, 0, 0, 0, 0)
	GOSUB CreatePullDown
	GOSUB Resize
END SUB
'
'
' *****  CreatePullDown  *****
'
SUB CreatePullDown
	XgrGetGridWindow (grid, @window)
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoSelect OR $$WindowTypeNoFrame OR $$WindowTypeNoIcon OR window
	XuiPullDown    (@g, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDropBox(), -1, -1, $PullDown, grid)
	XuiSendMessage (grid, #SetValues, g, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	IF (upper < $PullDown) THEN REDIM k[$PullDown]
	k[$PullDown] = g
	XuiSendMessage (grid, #SetKidArray, 0, 0, 0, 0, 0, @k[])
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDropBox")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullDownMessage  *****
'
SUB PullDownMessage
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  GetTextArrayLine  *****
'
SUB GetTextArrayLine
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextCursor, 0, @v1, 0, 0, 0, 0)
	XuiSendToKid (grid, #GetTextCursor, @v0, 0, 0, 0, $Text, 0)
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @r1$)
END SUB
'
'
' *****  Monitor  *****
'
SUB Monitor
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiDropBox(), 0, 0, 0, monitor)
	XuiMonitorContext (grid, #MonitorContext, grid, &XuiDropBox(), 0, 0, 0, monitor)
END SUB
'
'
' *****  MouseDown  *****  caused by #MonitorMouse
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
		r0 = -1
	ELSE
		IF (style == 0) THEN GOSUB PullUp
		XuiSendToKid (grid, #GetGridNumber, @gb, 0, 0, 0, $Button, 0)
		IF XuiGridContainsGridCoord (gb, gg, v0, v1, 0, 0) THEN r0 = -1
	END IF
END SUB
'
'
' *****  MouseDrag  *****  caused by #MonitorMouse
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
	END IF
	r0 = -1
END SUB
'
'
' *****  MouseUp  *****  caused by #MonitorMouse
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
	ELSE
		IF (style == 0) THEN
			XuiSendToKid (grid, #GetGridNumber, @gb, 0, 0, 0, $Button, 0)
			IFZ XuiGridContainsGridCoord (gb, gg, v0, v1, 0, 0) THEN GOSUB PullUp
		END IF
	END IF
	r0 = -1
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	IF (v2 < (v3 + 32)) THEN v2 = v3 + 32
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	x1 = bw : y1 = bw : w1 = v2 - v3 - bw - bw : h1 = v3 - bw - bw
	x2 = v2 - v3 + bw : y2 = bw : w2 = v3 - bw - bw : h2 = v3 - bw - bw
	XuiSendToKid (grid, #Resize, x1, y1, w1, h1, $Text, 0)
	XuiSendToKid (grid, #Resize, x2, y2, w2, h2, $Button, 0)
	XuiSendMessage (pulldown, #Resize, 0, 0, 0, 0, 0, 0)
	XgrGetGridWindow (pulldown, @pullWindow)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	SELECT CASE r0
		CASE $Text			: item = -1
											state = v0
											virtualKey = state{$$VirtualKey}
											IF (style == 0) THEN GOSUB PullUp
											IF (virtualKey = $$KeyEnter) THEN
												XuiSendMessage (pulldown, #GetTextCursor, 0, @cl, 0, 0, 0, 0)
												XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
												XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
												IF text$[] THEN
													IF (text$ = text$[cl]) THEN
														item = cl
													ELSE
														IF text$[] THEN
															upper = UBOUND (text$[])
															FOR i = 0 TO upper
																IF (text$ = text$[i]) THEN item = i : EXIT FOR
															NEXT i
														END IF
													END IF
													IF (item >= 0) THEN XuiSendMessage (pulldown, #SetTextCursor, 0, @item, 0, 0, 0, 0)
												END IF
												XuiCallback (grid, #Selection, item, 0, 0, 0, 1, 0)
											END IF
		CASE $Button		:	IF (style == 1) THEN
												GOSUB PullDown
											ELSE
												IF pullstate THEN
													state = ($$KeyEnter << 24) OR $$KeyEnter
													XuiSendMessage (pulldown, #KeyDown, 0, 0, state, 0, 0, 0)
'													GOSUB PullUp
												ELSE
													GOSUB PullDown
												END IF
											END IF
		CASE $PullDown	: XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											XuiSendMessage (pulldown, #GetTextCursor, 0, @cl, 0, 0, 0, 0)
											IF ((v0 >= 0) AND (v0 <= UBOUND(text$[]))) THEN
												text$ = text$[v0]
'												IF (style AND $Style2) THEN
'													under = INSTR (text$, "_")
'													IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'												END IF
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
												XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @text$)
												XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
												XuiSendToKid (grid, #SetKeyboardFocus, 0, 0, 0, 0, $Text, 0)
											END IF
											IF (style == 0) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, v0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  PullDown  *****
'
SUB PullDown
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 1)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
'
' drop upward if necessary
'
	XuiGetSize (grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
	XuiSendMessage (pulldown, #GetSize, 0, 0, @width, @height, 0, 0)
'
	above = y1
	below = #displayHeight - y2
	IF (width < ww) THEN width = ww
	XuiSendMessage (pulldown, #Resize, 0, 0, width, 0, 0, 0)
	IF ((xDrop + width) > #displayWidth) THEN xDrop = xDrop - width + x2 - x1 + 1
	IF (above > below) THEN
		IF ((yDrop + height) > #displayHeight) THEN yDrop = yDrop - height - y2 + y1 - 1
	END IF
'
' position and display the pulldown window
'
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #ShowWindow, 0, 0, 0, 0, 0, 0)
	monitor = $$TRUE
	GOSUB Monitor
END SUB
'
'
' *****  PullUp  *****
'
SUB PullUp
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 1)
	XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
	monitor = $$FALSE
	GOSUB Monitor
END SUB
'
'
' *****  PullToggle  *****
'
SUB PullToggle
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF pullstate THEN GOSUB PullUp ELSE GOSUB PullDown
END SUB
'
'
' *****  SetStyle  *****
'
'	$Style0		= 0			' list goes up/down, text line editable
'	$Style1		= 1			' list always down, text line editable
' $Style2		= 2			' do not process underline characters
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 1) THEN style = 0
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @oldStyle, 0, 0, 0, 0, 0)
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	IF (style = oldStyle) THEN EXIT SUB
	SELECT CASE style
		CASE 0	:	XuiSendMessage (grid, #SetBorder, $$BorderLower1, $$BorderLower1, $$BorderLower1, 0, 0, 0)
							XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
							XuiSendToKid (grid, #ShowTextCursor, 0, 0, 0, 0, $Text, 0)
		CASE 1	:	XuiSendMessage (grid, #SetBorder, $$BorderLower1, $$BorderLower1, $$BorderLower1, 0, 0, 0)
							XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
							XuiSendToKid (grid, #ShowTextCursor, 0, 0, 0, 0, $Text, 0)
							XuiSendMessage (pulldown, #ShowWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
	v0 = style
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	IF r1$[] THEN text$ = r1$[0] ELSE text$ = ""
'	IF (style AND $Style2) THEN
'		under = INSTR (text$, "_")
'		IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'	END IF
	cp = LEN (text$)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @text$)
	XuiSendToKid (grid, #SetTextCursor, cp, 0, 0, 0, $Text, 0)
	XuiSendMessage (pulldown, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	XuiSendMessage (pulldown, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
	XuiSendMessage (pulldown, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextArrayLine  *****
'
SUB SetTextArrayLine
	XuiGetValues (grid, #GetValues, @pulldown, @pullState, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #SetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
	ATTACH r1$ TO temp$
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	DIM r1$[]
	ATTACH temp$ TO r1$
END SUB
'
'
' *****  SetTextCursor  *****
'
SUB SetTextCursor
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF (v0 >= 0) THEN XuiSendToKid (grid, #SetTextCursor, v0, 0, 0, 0, $Text, 0)
	IF (v1 >= 0) THEN XuiSendMessage (pulldown, #SetTextCursor, 0, v1, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	cp = LEN (r1$)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @r1$)
'	XuiSendToKid (grid, #SetTextCursor, cp, 0, 0, 0, $Text, 0)
	XuiSendToKid (grid, #SetTextCursor, 0, 0, 0, 0, $Text, 0)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	kid = r0
	IF (r0 = $PullDown) THEN r0 = $DropBox
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @r0, grid)
	IF (r0 = -1) THEN EXIT SUB
	contents = v2{$$StateContents}
	IF (contents = 1) THEN XgrJamMessage (grid, #TextModified, 0, 0, 0, 0, 0, 0)
'
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ pulldown THEN EXIT SUB
	key = v2{$$VirtualKey}
'
	IF (v2 AND $$AltBit) THEN
		SELECT CASE key
			CASE $$KeyUpArrow		: GOSUB PullUp		: r0 = -1			' cancel
			CASE $$KeyDownArrow	: GOSUB PullDown	: r0 = -1			' cancel
		END SELECT
	ELSE
		IF (kid != $PullDown) THEN		' avoid infinite loop stack overflow
			SELECT CASE key
				CASE $$KeyUpArrow, $$KeyDownArrow
							XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, pulldown)
							XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @item$[])
							XuiSendMessage (pulldown, #GetTextCursor, 0, @cl, 0, 0, 0, 0)
							IF item$[] THEN
								upper = UBOUND (item$[])
								IF (cl > upper) THEN cl = upper
								IF (cl < 0) THEN cl = 0
								item$ = item$[cl]
								cp = LEN(item$)
								XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @item$)
								XuiSendToKid (grid, #SetTextCursor, 0, 0, 0, 0, $Text, 0)
								XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
							END IF
							r0 = -1
'				CASE $$KeyEnter
'							IF pullstate THEN
'								XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, pulldown)
'								IF (style == 0) THEN GOSUB PullUp
'							ELSE
'								GOSUB PullDown
'							END IF
'							r0 = -1
				CASE $$KeyEscape
							IF (style == 0) THEN GOSUB PullUp
							r0 = -1
			END SELECT
		END IF
	END IF
END SUB
'
'
' *****  TextModified  *****
'
SUB TextModified
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
	IFZ pulldown THEN EXIT SUB
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
	IFZ text$ THEN EXIT SUB
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @list$[])
	IFZ list$[] THEN EXIT SUB
	uList = UBOUND (list$[])
	lenText = LEN (text$)
	FOR line = 0 TO uList
		list$ = list$[line]
'		IF (style AND $Style2) THEN
'			under = INSTR (list$, "_")
'			IF under THEN list$ = LEFT$ (list$, under-1) + MID$ (list$, under+1)
'		END IF
		lenLine = LEN (list$)
		IF (lenLine < lenText) THEN DO NEXT
		IF (text$ = LEFT$ (list$, lenText)) THEN EXIT FOR
	NEXT line
	IF (line <= uList) THEN XuiSendMessage (pulldown, #SetTextCursor, 0, line, -1, -1, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#GetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#GetTextString]			= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
	func[#SetTextArrayLine]		= 0
	func[#SetTextString]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#ContextChange]				= SUBADDRESS (PullUp)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextArray]				= SUBADDRESS (GetTextArray)
	sub[#GetTextArrayLine]		= SUBADDRESS (GetTextArrayLine)
	sub[#GetTextCursor]				= SUBADDRESS (GetTextCursor)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
	sub[#SetTextArrayLine]		= SUBADDRESS (SetTextArrayLine)
	sub[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
	sub[#TextModified]				= SUBADDRESS (TextModified)
'
	IF func[0] THEN PRINT "XuiDropBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDropBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiDropBox, @"XuiDropBox", &XuiDropBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiDropBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"styleMax",        1)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiDropButton ()  #####
' ##############################
'
FUNCTION  XuiDropButton (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiDropButton
	STATIC	monitor
'
	$DropButton	= 0
	$Button			= 1
	$PullDown		= 2
'
' $Style2 is not implemented because it causes problems in some applications
'
	$Style0			= 0			' list goes up/down
	$Style1			= 1			' list always down
	$Style2			= 2			' _ before hotkey
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiDropButton) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiDropButton, @v0, @v1, 128, 20, r0, r1, &XuiDropButton())
	XuiPressButton (@g, #Create, 108, 0, 20, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDropButton(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"PressButton")
	GOSUB CreatePullDown
	GOSUB Resize
END SUB
'
'
' *****  CreatePullDown  *****
'
SUB CreatePullDown
	XgrGetGridWindow (grid, @window)
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoSelect OR $$WindowTypeNoFrame OR $$WindowTypeNoIcon OR window
	XuiPullDown    (@g, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( g, #SetCallback, grid, &XuiDropButton(), -1, -1, $PullDown, grid)
	XuiSendMessage (grid, #SetValues, g, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	IF (upper < $PullDown) THEN REDIM k[$PullDown]
	k[$PullDown] = g
	XuiSendMessage (grid, #SetKidArray, 0, 0, 0, 0, 0, @k[])
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiDropButton")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullDownMessage  *****
'
SUB PullDownMessage
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  GetTextArrayLine  *****
'
SUB GetTextArrayLine
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #GetTextCursor, 0, @v1, 0, 0, 0, 0)
	v0 = 0
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Button, @r1$)
END SUB
'
'
' *****  Monitor  *****
'
SUB Monitor
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiDropButton(), 0, 0, 0, monitor)
	XuiMonitorContext (grid, #MonitorContext, grid, &XuiDropButton(), 0, 0, 0, monitor)
END SUB
'
'
' *****  MouseDown  *****  caused by #MonitorMouse
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
		r0 = -1
	ELSE
		IFZ (style AND 1) THEN GOSUB PullUp
		XuiSendToKid (grid, #GetGridNumber, @gb, 0, 0, 0, $Button, 0)
		IF XuiGridContainsGridCoord (gb, gg, v0, v1, 0, 0) THEN r0 = -1
	END IF
END SUB
'
'
' *****  MouseDrag  *****  caused by #MonitorMouse
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
	END IF
	r0 = -1
END SUB
'
'
' *****  MouseUp  *****  caused by #MonitorMouse
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ pullstate THEN EXIT SUB
	IFZ pulldown THEN EXIT SUB
	IFZ monitor THEN EXIT SUB
	IFZ r1 THEN EXIT SUB
	gg = r1
'
	IF XuiGridContainsGridCoord (pulldown, gg, v0, v1, @xx, @yy) THEN
		XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
	ELSE
		IFZ (style AND 1) THEN
			XuiSendToKid (grid, #GetGridNumber, @gb, 0, 0, 0, $Button, 0)
			IFZ XuiGridContainsGridCoord (gb, gg, v0, v1, 0, 0) THEN GOSUB PullUp
		END IF
	END IF
	r0 = -1
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	x1 = bw : y1 = bw : w1 = v2 - bw - bw : h1 = v3 - bw - bw
	XuiSendToKid (grid, #Resize, bw, bw, w1, h1, $Button, 0)
	XuiSendMessage (pulldown, #Resize, 0, 0, 0, 0, 0, 0)
	XgrGetGridWindow (pulldown, @pullWindow)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	SELECT CASE r0
		CASE $Button		:	abort = 0
											XuiCallback (grid, #Notify, 0, 0, 0, @abort, r0, 0)
											IF abort THEN EXIT SUB
											SELECT CASE style
												CASE 0	: GOSUB PullToggle
												CASE 1	: GOSUB PullDown
											END SELECT
		CASE $PullDown	:	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											XuiSendMessage (pulldown, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
											IF ((v0 >= 0) AND (v0 <= UBOUND(text$[]))) THEN
												text$ = text$[v0]
'												IF (style AND $Style2) THEN
'													under = INSTR (text$, "_")
'													IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'												END IF
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
											END IF
											IF (style == 0) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, v0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  PullDown  *****
'
SUB PullDown
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 1)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
'
' drop upward if necessary
'
	XuiGetSize (grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
	XuiSendMessage (pulldown, #GetSize, 0, 0, @width, @height, 0, 0)
'
	above = y1
	below = #displayHeight - y2
	IF (width < ww) THEN width = ww
	XuiSendMessage (pulldown, #Resize, 0, 0, width, 0, 0, 0)
	IF ((xDrop + width) > #displayWidth) THEN xDrop = xDrop - width + x2 - x1 + 1
	IF (above > below) THEN
		IF ((yDrop + height) > #displayHeight) THEN yDrop = yDrop - height - y2 + y1 - 1
	END IF
'
'	IF (width < ww) THEN width = ww
'	XuiSendMessage (pulldown, #Resize, 0, 0, width, 0, 0, 0)
'	IF ((yDrop + height) > #displayHeight) THEN yDrop = yDrop - height - y2 + y1 - 1
'	IF ((xDrop + width) > #displayWidth) THEN xDrop = xDrop - width + x2 - x1 + 1
'
' position and display the pulldown window
'
	XgrSetWindowPositionAndSize (pullWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (pulldown, #ShowWindow, 0, 0, 0, 0, 0, 0)
	monitor = $$TRUE
	GOSUB Monitor
END SUB
'
'
' *****  PullUp  *****
'
SUB PullUp
'	PRINT "PullUp.A"
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pullstate THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (pulldown, @pullWindow)
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 1)
	XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
	monitor = $$FALSE
	GOSUB Monitor
'	PRINT "PullUp.Z"
END SUB
'
'
' *****  PullToggle  *****
'
SUB PullToggle
'	PRINT "PullToggle.A"
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pullstate THEN GOSUB PullDown ' ELSE GOSUB PullUp
'	PRINT "PullToggle.Z"
END SUB
'
'
' *****  SetStyle  *****
'
'	$Style0		= 0			' list goes up/down
'	$Style1		= 1			' list always down
' $Style2		= 2			' not implemented
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN EXIT SUB
	IF (style > 1) THEN EXIT SUB
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	IF (style AND 1) THEN GOSUB PullDown
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Button, r1)
'	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
'	XuiSendMessage (pulldown, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	XuiGetSize (grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
'
	XuiSendMessage (pulldown, #GetSize, 0, 0, @width, @height, 0, 0)
	IF (width < ww) THEN width = ww
	XuiSendMessage (pulldown, #Resize, 0, 0, width, 0, 0, 0)
	XuiSendMessage (pulldown, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextArrayLine  *****
'
SUB SetTextArrayLine
	XuiGetValues (grid, #GetValues, @pulldown, @pullState, 0, 0, 0, 0)
	XuiSendMessage (pulldown, #SetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
	ATTACH r1$ TO temp$
	XuiSendMessage (pulldown, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	DIM r1$[]
	ATTACH temp$ TO r1$
END SUB
'
'
' *****  SetTextCursor  *****
'
SUB SetTextCursor
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IF (v1 >= 0) THEN XuiSendMessage (pulldown, #SetTextCursor, 0, v1, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Button, @r1$)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	XuiGetValues (grid, #GetValues, @pulldown, @pullstate, 0, 0, 0, 0)
	IFZ pulldown THEN EXIT SUB
	key = v2{$$VirtualKey}
'
	IF (v2 AND $$AltBit) THEN
		SELECT CASE key
			CASE $$KeyUpArrow		: GOSUB PullUp		: r0 = -1			' cancel
			CASE $$KeyDownArrow	: GOSUB PullDown	: r0 = -1			' cancel
		END SELECT
	ELSE
		IF (r0 != $PullDown) THEN		' avoid infinite loop stack overflow
			IF pullstate THEN
				SELECT CASE key
					CASE $$KeyUpArrow, $$KeyDownArrow
								XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, pulldown)
								r0 = -1
					CASE $$KeyEnter
								XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, pulldown)
								r0 = -1
					CASE $$KeyEscape
								GOSUB PullUp
								r0 = -1
				END SELECT
			END IF
		END IF
	END IF
END SUB
'
'
' *****  GetFromButton  *****
'
SUB GetFromButton
	XuiSendToKid (grid, message, @v0, @v1, @v2, @v3, $Button, @r1)
END SUB
'
'
' *****  SendToButton  *****
'
SUB SendToButton
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Button, r1)
END SUB
'
'
' *****  SendToKids  *****
'
SUB SendToKids
	XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#GetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
	func[#SetTextArrayLine]		= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#ContextChange]				= SUBADDRESS (PullUp)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
'	sub[#GetBorder]						= SUBADDRESS (GetFromButton)
'	sub[#GetColor]						= SUBADDRESS (GetFromButton)
'	sub[#GetColorExtra]				= SUBADDRESS (GetFromButton)
'	sub[#GetFont]							= SUBADDRESS (GetFromButton)
'	sub[#GetFontNumber]				= SUBADDRESS (GetFromButton)
	sub[#GetTextArray]				= SUBADDRESS (GetTextArray)
	sub[#GetTextArrayLine]		= SUBADDRESS (GetTextArrayLine)
	sub[#GetTextCursor]				= SUBADDRESS (GetTextCursor)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)
'	sub[#GetTexture]					= SUBADDRESS (GetFromButton)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
'	sub[#SetBorder]						= SUBADDRESS (SendToButton)
'	sub[#SetColor]						= SUBADDRESS (SendToButton)
'	sub[#SetColorExtra]				= SUBADDRESS (SendToButton)
'	sub[#SetFont]							= SUBADDRESS (SendToButton)
'	sub[#SetFontNumber]				= SUBADDRESS (SendToButton)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
	sub[#SetTextArrayLine]		= SUBADDRESS (SetTextArrayLine)
	sub[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
'	sub[#SetTexture]					= SUBADDRESS (SendToButton)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
'
	IF func[0] THEN PRINT "XuiDropButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiDropButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiDropButton, @"XuiDropButton", &XuiDropButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiDropButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"styleMax",        1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #########################
' #####  XuiImage ()  #####
' #########################
'
FUNCTION  XuiImage (grid, message, v0, v1, v2, v3, r0, r1)
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiImage
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiImage) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	XuiCreateGrid (@grid, XuiImage, @v0, @v1, @v2, @v3, r0, r1, &XuiImage())
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
	DIM func[upperMessage]
'
	func[#Destroy]						= &XuiDestroy ()
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
'
	IF func[0] THEN PRINT "XuiImage() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiImage() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiImage, @"Image", &XuiImage(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 32
	designHeight = 32
'
	gridType = XuiImage
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        0)
	XuiSetGridTypeProperty (gridType, @"minHeight",       0)
	XuiSetGridTypeProperty (gridType, @"mouse",           $$FALSE)
	XuiSetGridTypeProperty (gridType, @"keyboard",        $$FALSE)
	XuiSetGridTypeProperty (gridType, @"redraw",          $$FALSE)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawImage)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiFile ()  #####
' ########################
'
FUNCTION  XuiFile (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
  STATIC	SUBADDR  sub[]
	STATIC	upperMessage
  STATIC	XuiFile
	FILEINFO	fileData[]
'
  $XuiFile         =  0  ' kid  0 grid type = XuiFile
  $FileNameLabel   =  1  ' kid  1 grid type = XuiLabel
  $FileNameText    =  2  ' kid  2 grid type = XuiTextLine
  $DirectoryLabel  =  3  ' kid  3 grid type = XuiLabel
  $FilesLabel      =  4  ' kid  4 grid type = XuiLabel
  $DirectoryBox    =  5  ' kid  5 grid type = XuiList
  $FileBox         =  6  ' kid  6 grid type = XuiList
  $EnterButton     =  7  ' kid  7 grid type = XuiPushButton
  $CancelButton    =  8  ' kid  8 grid type = XuiPushButton
'
  IFZ sub[] THEN GOSUB Initialize
  IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiFile) THEN RETURN
  GOSUB @sub[message]
  RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiCreateGrid  (@grid, XuiFile, @v0, @v1, @v2, @v3, r0, r1, &XuiFile())
  XuiLabel       (@g, #Create, 4, 4, 108, 24, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FileNameLabel")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" filename: ")
  XuiTextLine    (@g, #Create, 112, 4, 324, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $FileNameText, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FileNameText")
  XuiCheckBox    (@g, #Create, 4, 28, 216, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $DirectoryLabel, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"DirectoryLabel")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"dir")
  XuiCheckBox    (@g, #Create, 220, 28, 216, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $FilesLabel, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FilesLabel")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"file")
  XuiList        (@g, #Create, 4, 52, 216, 312, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $DirectoryBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"DirectoryBox")
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 1, @"DirectoryBoxScrollH")
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 2, @"DirectoryBoxScrollV")
  XuiList        (@g, #Create, 220, 52, 216, 312, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $FileBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FileBox")
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 1, @"FileBoxScrollH")
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 2, @"FileBoxScrollV")
  XuiPushButton  (@g, #Create, 4, 364, 216, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $EnterButton, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"EnterButton")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
  XuiPushButton  (@g, #Create, 220, 364, 216, 24, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFile(), -1, -1, $CancelButton, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"CancelButton")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	nodraw = $$TRUE
	GOSUB Update
	GOSUB Resize
	XuiGetStyle    ( grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'	IF (style AND 0x0C00) THEN XuiSetValue (grid, #SetValue, -1, 0, 0, 0, $DirectoryLabel, 0)
'	IF (style AND 0x0300) THEN XuiSetValue (grid, #SetValue, -1, 0, 0, 0, $FilesLabel, 0)
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
  v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
  GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiFile")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw1, @ah1, $FileNameLabel,  0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw2, @ah2, $FileNameText,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw3, @ah3, $DirectoryLabel, 0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw4, @ah4, $FilesLabel,     0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw5, @ah5, $DirectoryBox,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw6, @ah6, $FileBox,        0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw7, @ah7, $EnterButton,    0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw8, @ah8, $CancelButton,   0)
'
' find minimum width of grids on left
'
	awl = aw3
	IF (aw5 > awl) THEN awl = aw5
	IF (aw7 > awl) THEN awl = aw7
'
' find minimum width of grids on right
'
	awr = aw4
	IF (aw6 > awr) THEN awr = aw6
	IF (aw8 > awr) THEN awr = aw8
'
' find minimum total width
'
	minx = awl + awr
	IF (minx < (aw1 + aw2)) THEN
		delta = ((aw1 + aw2) - minx) >> 1
		awl = awl + delta
		awr = awr + delta
		minx = aw1 + aw2
	END IF
'
	ahl = ah1 + ah3 + ah5 + ah7
	ahr = ah2 + ah4 + ah6 + ah8
	miny = ahl
	IF (miny < ahr) THEN miny = ahr
'
	v2 = minx + bw + bw
	v3 = miny + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and minimum widths/heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	expand = $$FALSE
	IF (v3 >= (miny + 12)) THEN expand = 4
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	x1 = bw
	y1 = bw
	w1 = aw1
	h1 = MAX (ah1, ah2)
	IF expand THEN h1 = h1 + 4
'
	x2 = x1 + w1
	y2 = y1
	w2 = v2 - w1 - bw - bw
	h2 = h1
'
	x3 = x1
	y3 = y1 + h1
	w3 = (v2 - bw - bw)	>> 1
	IF (w3 < awl) THEN w3 = awl
	h3 = MAX (ah3, ah4)
	IF expand THEN h3 = h3 + 4
'
	x4 = x3 + w3
	y4 = y3
	w4 = v2 - w3 - bw - bw
	h4 = h3
'
	w7 = w3
	h7 = MAX (ah7, ah8)
	IF expand THEN h7 = h7 + 4
	w8 = w4
	h8 = h7
'
	x5 = x3
	y5 = y3 + h3
	w5 = w3
	h5 = v3 - h1 - h3 - h7 - bw - bw
'
	x6 = x5 + w5
	y6 = y5
	w6 = w4
	h6 = h5
'
	x7 = x5
	y7 = y5 + h5
	x8 = x5 + w5
	y8 = y6 + h6
'
	XuiSendToKid (grid, #Resize, x1, y1, w1, h1, $FileNameLabel,  0)
	XuiSendToKid (grid, #Resize, x2, y2, w2, h2, $FileNameText,   0)
	XuiSendToKid (grid, #Resize, x3, y3, w3, h3, $DirectoryLabel, 0)
	XuiSendToKid (grid, #Resize, x4, y4, w4, h4, $FilesLabel,     0)
	XuiSendToKid (grid, #Resize, x5, y5, w5, h5, $DirectoryBox,   0)
	XuiSendToKid (grid, #Resize, x6, y6, w6, h6, $FileBox,        0)
	XuiSendToKid (grid, #Resize, x7, y7, w7, h7, $EnterButton,    0)
	XuiSendToKid (grid, #Resize, x8, y8, w8, h8, $CancelButton,   0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	SELECT CASE r0
		CASE $FileNameText		: GOSUB SelectionFileNameText
		CASE $DirectoryLabel	: GOSUB SelectionDirectoryLabel
		CASE $DirectoryBox		:	GOSUB SelectionDirectoryBox
		CASE $FilesLabel			: GOSUB SelectionFilesLabel
		CASE $FileBox					: GOSUB SelectionFileBox
		CASE $EnterButton			:	GOSUB SelectionFileName
		CASE $CancelButton		:	GOSUB SelectionCancel
	END SELECT
END SUB
'
'
' *****  SelectionDirectoryLabel  *****
'
SUB SelectionDirectoryLabel
	GOSUB Update
END SUB
'
'
' *****  SelectionFilesLabel  *****
'
SUB SelectionFilesLabel
	GOSUB Update
END SUB
'
'
' *****  Update  *****
'
SUB Update
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @tt$)
	XstGuessFilename ("", @tt$, @text$, @attributes)
	XstGetPathComponents (@text$, @path$, @drive$, @dir$, @file$, @attributes)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	GOSUB UpdateDirectoryBox
	GOSUB UpdateFilename
END SUB
'
'
' *****  UpdateFilename  *****
'
SUB UpdateFilename
	text$ = path$ + file$
	x = LEN (text$) + 1
	XuiSendToKid (grid, #SetTextCursor, 0, -1, -1, -1, $FileNameText, 0)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XuiSendToKid (grid, #SetTextCursor, x, -1, -1, -1, $FileNameText, 0)
	IFZ nodraw THEN XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FileNameText, 0)
END SUB
'
'
' *****  UpdateDirectoryBox  *****  enter with dir$ = "\DIR\FILE"
'
SUB UpdateDirectoryBox
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetValue (grid, #GetValue, @fmask, 0, 0, 0, $FilesLabel, 0)
	XuiGetValue (grid, #GetValue, @dmask, 0, 0, 0, $DirectoryLabel, 0)
	XstGetDrives (@drives, @drive$[], @driveType[], @driveType$[])
	udrive = drives - 1
	test$ = path$ + "*"
	dr$ = UCASE$(drive$) + $$PathSlash$
	XstGetFilesAndAttributes (@test$, -1, @file$[], @fileData[])
	upper = UBOUND(file$[])
	DIM map[upper]
'
	IF fmask THEN
		IF (style AND 0x0200) THEN
			FOR i = 0 TO upper
				file$[i] = UCASE$(file$[i])			' display filenames in upper case
			NEXT i
		END IF
		IF (style AND 0x0100) THEN					' display filenames in lower case
			FOR i = 0 TO upper
				file$[i] = LCASE$(file$[i])
			NEXT i
		END IF
	END IF
'
	XstQuickSort (@file$[], @map[], 0, upper, $$SortCaseInsensitive OR $$SortAlphaNumeric)
'
	IF (LEFT$(dir$,1) = $$PathSlash$) THEN dir$ = LCLIP$ (dir$, 1)
	IF dir$ THEN
		IF (RIGHT$(dir$,1) != $$PathSlash$) THEN dir$ = dir$ + $$PathSlash$
	END IF
'
	dir = -1
	directoryBoxLine = 0
	last$ = RCLIP$ (dir$)									' remove trailing \
	slash = RINSTR (last$, $$PathSlash$)	' find \ before last directory
	last$ = MID$ (last$, slash+1)					' last$ = deepest directory (selected)
	DIM dir$[upper+255]
	IFZ drive$ THEN
		INC dir
		dir$[dir] = $$PathSlash$
	ELSE
		FOR drive = 0 TO udrive
			d$ = UCASE$(drive$[drive])
			IF d$ THEN
				IF (d${UBOUND(d$)} != $$PathSlash) THEN d$ = d$ + $$PathSlash$
				INC dir
				dir$[dir] = d$
				IF (dr$ = d$) THEN INC drive : EXIT FOR
			END IF
		NEXT drive
	END IF
	uppers$ = dir$
	insert$ = " "
'
	DO
		bs = INSTR (uppers$, $$PathSlash$)
		IF bs THEN
			INC dir
			f$ = LEFT$ (uppers$, bs-1)
			dir$[dir] = insert$ + f$
			uppers$ = LCLIP$ (uppers$,bs)
			insert$ = " " + insert$
			IF (f$ = last$) THEN directoryBoxLine = dir
		END IF
	LOOP WHILE bs
'
	FOR i = 0 TO upper
		attributes = fileData[map[i]].attributes
		IF (attributes AND $$FileDirectory) THEN
			' IFZ (attributes AND ($$FileHidden OR $$FileSystem OR $$FileArchive)) THEN
			' Don't display hidden and system directories.
			IFZ (attributes AND ($$FileHidden OR $$FileSystem)) THEN
				INC dir
				f$ = file$[i]
				uuu = UBOUND (f$)
				IF (f${uuu} = $$PathSlash) THEN f$ = RCLIP$ (f$, 1)
				IFZ f$ THEN f$ = $$PathSlash$
				dir$[dir] = insert$ + f$
				IF (f$ = last$) THEN directoryBoxLine = dir
			END IF
		END IF
	NEXT i
'
	IF (drive < drives) THEN
		FOR drive = drive TO udrive
			d$ = UCASE$(drive$[drive])
			IF d$ THEN
				IF (d${UBOUND(d$)} != $$PathSlash) THEN d$ = d$ + $$PathSlash$
				INC dir
				dir$[dir] = d$
			END IF
		NEXT drive
	END IF
'
	FileBoxLine = 0
	REDIM dir$[dir]
'
	IF dmask THEN
		IF (style AND 0x0800) THEN
			FOR i = 0 TO dir
				dir$[i] = UCASE$(dir$[i])			' display directories in upper case
			NEXT i
		END IF
		IF (style AND 0x0400) THEN				' display directories in lower case
			FOR i = 0 TO dir
				dir$[i] = LCASE$(dir$[i])
			NEXT i
		END IF
	END IF
'
	XuiSendToKid (grid, #SetTextArray, 0, 0, 0, 0, $DirectoryBox, @dir$[])
	dir$ = $$PathSlash$ + dir$
	x = LEN (dir$)
'
	IFZ nodraw THEN
		XuiSendToKid (grid, #SetTextCursor, 0, directoryBoxLine, 0, 0, $DirectoryBox, 0)
		XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $DirectoryBox, 0)
	END IF
	GOSUB UpdateFileBox
END SUB
'
'
' *****  UpdateFileBox  *****  enter with file$[] and fileData[]  (from UpdateDirectoryBox)
'
SUB UpdateFileBox
	DIM f$[upper]
	file = 0
	FOR i = 0 TO upper
		attributes = fileData[map[i]].attributes
		IFZ (attributes AND ($$FileHidden OR $$FileSystem OR $$FileDirectory OR $$FileTemporary)) THEN
			f$[file] = file$[i]
			INC file
		END IF
	NEXT i
	DEC file
	IF (file < 0) THEN DIM f$[] ELSE REDIM f$[file]
'
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	order = style AND 0x0F
	split = 9
	SELECT CASE (style >> 4) AND 0x03
		CASE 0			: split = SortNot (@f$[], order)
		CASE 1			: split = SortByName (@f$[], order)
		CASE 2			:	split = SortByExtent (@f$[], order)
		CASE ELSE		: PRINT "XuiFileBox() : UpdateList : error ::: (unknown style)"
	END SELECT
	IF (style AND 0x40) THEN SplitFilenames (@f$[], split)
	XuiSendToKid (grid, #SetTextArray, 0, 0, 0, 0, $FileBox, @f$[])
	IFZ nodraw THEN
		XuiSendToKid (grid, #SetTextCursor, 0, fileBoxLine, 0, 0, $FileBox, 0)
		XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FileBox, 0)
	END IF
END SUB
'
'
' *****  SelectionDirectoryBox  *****
'
SUB SelectionDirectoryBox
	IF (v0 < 0) THEN
		XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
		EXIT SUB
	END IF
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XstGetPathComponents (@text$, @path$, @drive$, @dir$, @file$, @attributes)
	XuiSendToKid (grid, #GetTextArray, 0, 0, 0, 0, $DirectoryBox, @file$[])
	attributes = $$FileDirectory
	IFZ file$[] THEN EXIT SUB
	path$ = ""
	temp$ = ""
	indent = 1
	FOR i = 0 TO v0
		p$ = file$[i]
		IF p$ THEN
			IF (p${0} != ' ') THEN
				path$ = p$
				ii = i
			END IF
		END IF
	NEXT i
	IF (ii < v0) THEN
		FOR i = ii TO v0
			dir$ = file$[i]
			length = LEN (dir$)
			dir$ = LTRIM$(dir$)
			delta = length - LEN(dir$)
			dir$ = TRIM$(dir$)
			SELECT CASE ALL TRUE
				CASE (delta = indent)
							temp$ = dir$
				CASE (delta > indent)
							IF temp$ THEN path$ = path$ + temp$
							IF (RIGHT$(path$,1) != $$PathSlash$) THEN path$ = path$ + $$PathSlash$
							indent = delta
							temp$ = dir$
				CASE (i = v0)
							IF temp$ THEN path$ = path$ + temp$
							IF (RIGHT$(path$,1) != $$PathSlash$) THEN path$ = path$ + $$PathSlash$
			END SELECT
		NEXT i
	END IF
'
	DO WHILE RIGHT$ (path$, 1) = $$PathSlash$				' strip trailing \
		path$ = RCLIP$ (path$, 1)
	LOOP
'
	dir$ = path$ + $$PathSlash$
	path$ = dir$
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @path$)
	GOSUB Update
END SUB
'
'
' *****  SelectionFileBox  *****
'
SUB SelectionFileBox
	IF (v0 < 0) THEN
		XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
		EXIT SUB
	END IF
	fileBoxLine = v0
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XstGetPathComponents (@text$, @path$, @drive$, @dir$, @file$, @attributes)
	XuiSendToKid (grid, #GetTextArray, 0, 0, 0, 0, $FileBox, @ff$[])
	upperFileBox = UBOUND (ff$[])
	IF (v0 > upperFileBox) THEN
'		XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
		EXIT SUB
	END IF
	file$ = ff$[v0]
	UnsplitFilename (@file$)
	text$ = path$ + file$
	x = LEN (text$)
	XuiSendToKid (grid, #SetTextCursor, 0, -1, -1, -1, $FileNameText, 0)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XuiSendToKid (grid, #SetTextCursor, x, -1, -1, -1, $FileNameText, 0)
	GOSUB Update
	XuiCallback (grid, #Selection, r0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SelectionFileNameText  *****  v0 = state (KeyEnter / KeyEscape)
'
SUB SelectionFileNameText
	IF (v0{$$VirtualKey} = $$KeyEscape) THEN
		XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
	ELSE
		GOSUB SelectionFileName
	END IF
END SUB
'
'
' *****  SelectionFileName  *****
'
SUB SelectionFileName
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XstGuessFilename ("", @text$, @file$, @attr)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @file$)
	GOSUB Update
	IF file$ THEN XuiCallback (grid, #Selection, r0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SelectionCancel  *****
'
SUB SelectionCancel
	XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @r1$)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FileNameText, @text$)
	XstGuessFilename (@text$, @r1$, @file$, @attr)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FileNameText, @file$)
	IF (text$ != file$) THEN GOSUB Update
END SUB
'
'
' *****  Initialize  *****  ' comment lines in/out as appropriate
'
SUB Initialize
  XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0															' if internal routine
	func[#GetTextString]			= 0															' internal routine
  func[#Resize]							= 0                             ' if internal routine
	func[#SetTextString]			= 0															' internal routine
'
  DIM sub[upperMessage]
  sub[#Callback]						= SUBADDRESS (Callback)         ' internal routine
  sub[#Create]							= SUBADDRESS (Create)           ' internal routine (always)
  sub[#CreateWindow]				= SUBADDRESS (CreateWindow)     ' internal routine (always)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)		' internal routine
  sub[#Resize]							= SUBADDRESS (Resize)           ' internal routine
	sub[#Selection]						= SUBADDRESS (Selection)				' internal routine
	sub[#SetTextString]				= SUBADDRESS (SetTextString)		' executes after func[#SetTextString]
	sub[#Update]							= SUBADDRESS (Update)						' update drive/directory/file boxes
'
	IF func[0] THEN PRINT "XuiFile() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiFile() : Initialize : error ::: (undefined message)"
  XuiRegisterGridType (@XuiFile, "XuiFile", &XuiFile(), @func[], @sub[])
'
	style = 0x0066
	XstGetOSName (@os$)
	win = INSTRI (os$, "Win")
	IF win THEN style = style OR 0x0A00		' display lists in lower case
'
  designX = 256
  designY = 23
  designWidth = 264
  designHeight = 200
'
	gridType = XuiFile
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        72)
	XuiSetGridTypeProperty (gridType, @"minHeight",       72)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       8)
	XuiSetGridTypeProperty (gridType, @"indentTop",        4)
	XuiSetGridTypeProperty (gridType, @"style",           style)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $FileNameText)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $FileNameText)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###########################
' #####  XuiFileBox ()  #####
' ###########################
'
FUNCTION  XuiFileBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiFileBox
'
	$FileBox		= 0
	$Text				= 1
	$ScrollH		= 2
	$ScrollV		= 3
'
	$TextGrid		= 0
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiFileBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiFileBox, @v0, @v1, @v2, @v3, r0, r1, &XuiFileBox())
	XuiSendMessage ( grid, #CreateValueArray, 31, 0, 0, 0, 0, 0)
	XuiArea        (@g, #Create, v0, v1, v2, v3, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiFileBox(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Area")
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #SetValue, g, 0, 0, 0, 0, $TextGrid)
	TextMessage    ( grid, #SetValues, 0, 0, 0, 0, 0, 0)
	XuiScrollBarH  (@g, #Create, 4, v3-16, v2-8, 12, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiFileBox(), -1, -1, $ScrollH, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollH")
	XuiScrollBarV  (@g, #Create, v2-16, 4, 12, v3-8, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiFileBox(), -1, -1, $ScrollV, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollV")
	GOSUB Resize
	GOSUB Update
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiFileBox")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $TextGrid)
	IF textGrid THEN
		XuiSendMessage (textGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $TextGrid)
	END IF
	XuiDestroy (grid, #Destroy, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  GetSmallestSize  *****  v0 = # columns, v1 = # rows
'
SUB GetSmallestSize
	XuiGetMaxMinSize (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	XuiGetAlign (grid, #GetAlign, @align, @justify, @indentX, @indentY, 0, @borderWidth)
	border = borderWidth + borderWidth
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	textWidth = maxCharWidth * MAX(v0, 1)
	textHeight = maxCharHeight * MAX(v1, 1)
	scrollWidth = 12
	scrollHeight = 12
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignUpperCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignUpperRight		: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignMiddleLeft		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignMiddleCenter	: indentX = indentX + indentX	: indentY = indentY + indentY
		CASE $$AlignMiddleRight		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignLowerLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignLowerCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignLowerRight		: indentX = indentX + 2				: indentY = indentY + 2
	END SELECT
	width = textWidth + scrollWidth + border + indentX
	height = textHeight + scrollHeight + border + indentY
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
	v2 = width : v3 = height
END SUB
'
'
' *****  KeyDown  *****  CTRL means more of the same
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	ctrl = (v2 AND $$CtrlBit)													' v2 = state
	cursorMessage = $$FALSE
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyLeftArrow
					cursorMessage = #ScrollH									' FileBox widget SCROLLs here
					IF ctrl THEN
						action = #MuchLess
					ELSE
						action = #OneLess
					END IF
		CASE $$KeyRightArrow
					cursorMessage = #ScrollH									' FileBox widget SCROLLs here
					IF ctrl THEN
						action = #MuchMore
					ELSE
						action = #OneMore
					END IF
		CASE $$KeyUpArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeLess											' beginning of page
					ELSE
						action = #OneLess											' up one line
					END IF
		CASE $$KeyDownArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeMore											' end of page
					ELSE
						action = #OneMore											' down one line
					END IF
		CASE $$KeyHome
					action = #Minimum
					IF ctrl THEN
						cursorMessage = #CursorV								' beginning of text
					ELSE
						cursorMessage = #CursorH								' beginning of line
					END IF
		CASE $$KeyEnd
					action = #Maximum
					IF ctrl THEN
						cursorMessage = #CursorV								' end of text
					ELSE
						cursorMessage = #CursorH								' end of line
					END IF
		CASE $$KeyPageDown
					cursorMessage = #ScrollV
					action = #MuchMore
		CASE $$KeyPageUp
					cursorMessage = #ScrollV
					action = #MuchLess
	END SELECT
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort = -1) THEN EXIT SUB
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyEnter
			TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
			GOSUB SendSelectionCallback
'			XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
		CASE $$KeyEscape
			XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
	END SELECT

	IF cursorMessage THEN
		TextMessage (grid, cursorMessage, 0, 0, 0, 0, 0, action)
	END IF
END SUB
'
'
' *****  MouseDown *****  FileBox considers single and double clicks only
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiFileBox(), 0, 0, 0, $$TRUE)
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	TextMessage (grid, #CursorH, vv0, vv1, 0, 0, 0, #Change)
	clicks = v2{3, 4}
	IF (clicks = 2) THEN
		TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
		GOSUB SendSelectionCallback
	END IF
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	TextMessage (grid, #CursorH, vv0, vv1, 0, 0, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiFileBox(), 0, 0, 0, $$FALSE)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XgrGetMouseInfo (@window, @g, @xWin, @yWin, @state, @time)
	XuiGetKids (grid, #GetKids, @g1, @k1, @k2, @k3, 0, @k4 )
	IF ((g == k1) || (g == k3)) THEN
			SELECT CASE SIGN(v3)
				CASE -1	: TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeMore)
				CASE 1	:	TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeLess)
			END SELECT
		END IF
END SUB
'
'
' *****  UpdateTextString  *****
'
SUB UpdateTextString
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	upper = UBOUND (text$[])
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
'
	text$ = ""
	IF ((cursorLine >= 0) AND (cursorLine <= upper)) THEN
		XuiGetTextArrayLine (grid, #GetTextArrayLine, cursorLine, 0, 0, 0, 0, @text$)
	END IF
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  PassToText  *****
'
SUB PassToText
	TextMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollV, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	x		= v0 + dx
	y		= v1 + dy
	w		= v2 - dx2 - 12
	h		= v3 - dy2 - 12
	XuiSendToKid (grid, #Resize, x, y, w, h, $Text, 0)
	TextMessage (grid, #Resize, x, y, w, h, 0, 0)
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - 12
	h		= 12
	x		= dx
	y		= v3 - dy - h - 1
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollH, 0)
'
	w		= 12
	h		= v3 - dy2 - 12
	x		= v2 - dx - w - 1
	y		= dy
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollV, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Scroll  *****
'
SUB Scroll
	SELECT CASE r0
		CASE $ScrollH		: scroll = #ScrollH
		CASE $ScrollV		: scroll = #ScrollV
	END SELECT
	TextMessage (grid, scroll, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SendSelectionCallback  *****
'
SUB SendSelectionCallback
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @dir$)
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @dir$[])
	XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
'	file$ = dir$[cursorLine]
'	PRINT dir$ + file$
'	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @file$)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	dir$ = r1$
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @dir$)
	GOSUB UpdateList
END SUB
'
'
' *****  Update  *****
'
SUB Update
'	XstGetCurrentDirectory (@dir$)			' old way = bad way
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @dir$)
	GOSUB UpdateList
END SUB
'
'
' *****  UpdateList  *****
'
SUB UpdateList
	DO
		check$ = RIGHT$(dir$,1)
		IF ((check$ != $$PathSlash$) AND (check$ != "*")) THEN EXIT DO
		dir$ = RCLIP$(dir$,1)
	LOOP
	path$ = dir$ + $$PathSlash$ + "*"
	XstGetFiles (path$, @files$[])
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, dir$ + $$PathSlash$)
'
	DIM file$[]
	IF files$[] THEN
		upper = UBOUND(files$[])
		DIM file$[upper]
		file = 0
		FOR i = 0 TO upper
			file$ = dir$ + $$PathSlash$ + files$[i]
			XstGetFileAttributes (@file$, @attributes)
			IFZ (attributes AND ($$FileHidden OR $$FileSystem OR $$FileDirectory OR $$FileTemporary)) THEN
				file$[file] = files$[i]
				INC file
			END IF
		NEXT i
		DEC file
		IF (file < 0) THEN DIM file$[] ELSE REDIM file$[file]
'
		XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
		order = style AND 0x0F
		split = 9
		SELECT CASE (style >> 4) AND 0x03
			CASE 0			: split = SortNot (@file$[], order)
			CASE 1			: split = SortByName (@file$[], order)
			CASE 2			:	split = SortByExtent (@file$[], order)
			CASE ELSE		: PRINT "XuiFileBox() : UpdateList : error ::: (unknown style)"
		END SELECT
		IF style AND 0x40 THEN SplitFilenames (@file$[], split)
	END IF
	TextMessage (grid, #SetTextArray, 0, 0, 0, 0, 0, @file$[])
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= 0
	func[#GetTextArray]				= 0
	func[#GetTextStrings]			= 0
	func[#GrabTextArray]			= 0
	func[#PokeTextArray]			= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetTextArray]				= 0
	func[#SetTextStrings]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Change]							= SUBADDRESS (Scroll)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextCursor]				= SUBADDRESS (PassToText)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#GetTextArray]				= SUBADDRESS (PassToText)
	sub[#GetTextArrayBounds]	= SUBADDRESS (PassToText)
	sub[#GrabTextArray]				= SUBADDRESS (PassToText)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#MouseWheel]					= SUBADDRESS (MouseWheel)
	sub[#MuchLess]						= SUBADDRESS (Scroll)
	sub[#MuchMore]						= SUBADDRESS (Scroll)
	sub[#OneLess]							= SUBADDRESS (Scroll)
	sub[#OneMore]							= SUBADDRESS (Scroll)
	sub[#PokeTextArray]				= SUBADDRESS (PassToText)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetTextArray]				= SUBADDRESS (PassToText)
	sub[#SetTextCursor]				= SUBADDRESS (PassToText)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#SomeLess]						= SUBADDRESS (Scroll)
	sub[#SomeMore]						= SUBADDRESS (Scroll)
	sub[#TextReplace]					= SUBADDRESS (PassToText)
	sub[#Update]							= SUBADDRESS (Update)
'
	IF func[0] THEN PRINT "XuiFileBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiFileBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiFileBox, @"XuiFileBox", &XuiFileBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 72
'
	gridType = XuiFileBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        72)
	XuiSetGridTypeProperty (gridType, @"minHeight",       72)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       8)
	XuiSetGridTypeProperty (gridType, @"indentTop",        4)
	XuiSetGridTypeProperty (gridType, @"style",           0x66)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiFont ()  #####
' ########################
'
FUNCTION  XuiFont (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC  defName$,  defSize$,  defWeight$,  defItalic$,  defAngle$
  STATIC	designX,  designY,  designWidth,  designHeight
  STATIC	SUBADDR  sub[]
  STATIC	upperMessage
  STATIC	XuiFont
'
  $Font             =  0  ' kid  0 grid type = Font
  $FontNameLabel    =  1  ' kid  1 grid type = XuiLabel
  $FontNameBox      =  2  ' kid  2 grid type = XuiListBox
  $FontSizeLabel    =  3  ' kid  3 grid type = XuiLabel
  $FontSizeBox      =  4  ' kid  4 grid type = XuiListBox
  $FontWeightLabel  =  5  ' kid  5 grid type = XuiLabel
  $FontWeightBox    =  6  ' kid  6 grid type = XuiListBox
  $FontItalicLabel  =  7  ' kid  7 grid type = XuiLabel
  $FontItalicBox    =  8  ' kid  8 grid type = XuiListBox
  $FontViewArea     =  9  ' kid 11 grid type = XuiLabel
  $EnterButton      = 10  ' kid 12 grid type = XuiPushButton
  $FontViewButton   = 11  ' kid 13 grid type = XuiPushButton
  $CancelButton     = 12  ' kid 14 grid type = XuiPushButton
'
  IFZ sub[] THEN GOSUB Initialize
  IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiFont) THEN RETURN
  GOSUB @sub[message]
  RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiCreateGrid  (@grid, XuiFont, @v0, @v1, @v2, @v3, r0, r1, &XuiFont())
  XuiLabel       (@g, #Create, 4, 4, 108, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontNameLabel")
  XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 4, 0, 0, 0)
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"font name:")
  XuiListBox     (@g, #Create, 112, 4, 204, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $FontNameBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontNameBox")
  DIM text$[0]
  text$[0] = defName$
  XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 1, @defName$)
  XuiLabel       (@g, #Create, 4, 24, 108, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontSizeLabel")
  XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 4, 0, 0, 0)
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"font size:")
  XuiDropBox     (@g, #Create, 112, 24, 204, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $FontSizeBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontSizeBox")
  DIM text$[15]
  text$[ 0] = "  8  point"
  text$[ 1] = " 10  point"
  text$[ 2] = " 12  point"
  text$[ 3] = " 14  point"
  text$[ 4] = " 16  point"
  text$[ 5] = " 18  point"
  text$[ 6] = " 20  point"
  text$[ 7] = " 22  point"
  text$[ 8] = " 24  point"
  text$[ 9] = " 26  point"
  text$[10] = " 28  point"
  text$[11] = " 30  point"
  text$[12] = " 32  point"
  text$[13] = " 34  point"
  text$[14] = " 36  point"
  text$[15] = " 38  point"
  XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @defSize$)
  XuiLabel       (@g, #Create, 4, 44, 108, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontWeightLabel")
  XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 4, 0, 0, 0)
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"font weight:")
  XuiDropBox     (@g, #Create, 112, 44, 204, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $FontWeightBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontWeightBox")
  DIM text$[8]
  text$[0] = "100  thin"
  text$[1] = "200  extra light"
  text$[2] = "300  light"
  text$[3] = "400  normal"
  text$[4] = "500  medium"
  text$[5] = "600  semi-bold"
  text$[6] = "700  bold"
  text$[7] = "800  extra bold"
  text$[8] = "900  heavy"
  XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @defWeight$)
  XuiLabel       (@g, #Create, 4, 64, 108, 20, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontItalicLabel")
  XuiSendMessage ( g, #SetAlign, $$AlignMiddleLeft, -1, 4, 0, 0, 0)
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @"font italic:")
  XuiDropBox     (@g, #Create, 112, 64, 204, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $FontItalicBox, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontItalicBox")
  DIM text$[1]
  text$[0] = "no"
  text$[1] = "yes"
  XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @defItalic$)
  XuiLabel       (@g, #Create, 4, 84, 312, 132, r0, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontViewArea")
  XuiSendMessage ( g, #SetTexture, 0, 0, 0, 0, 0, 0)
  XuiPushButton  (@g, #Create, 4, 216, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $EnterButton, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"EnterButton")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
  XuiPushButton  (@g, #Create, 108, 216, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $FontViewButton, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"FontViewButton")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" view font ")
  XuiPushButton  (@g, #Create, 212, 216, 104, 20, r0, grid)
  XuiSendMessage ( g, #SetCallback, grid, &XuiFont(), -1, -1, $CancelButton, grid)
  XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"CancelButton")
  XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB InitializeTextArray
	GOSUB Update
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  v0123 = xywh : r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
  XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
  v0 = 0 : v1 = 0 : r0 = window : display$ = r1$ : r1 = 0
  GOSUB Create
	r1 = 0 : r1$ = display$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiFont")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw1, @ah1, $FontNameLabel,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw2, @ah2, $FontNameBox,     0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw3, @ah3, $FontSizeLabel,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw4, @ah4, $FontSizeBox,     0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw5, @ah5, $FontWeightLabel, 0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw6, @ah6, $FontWeightBox,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw7, @ah7, $FontItalicLabel, 0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw8, @ah8, $FontItalicBox,   0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @aw9, @ah9, $FontViewArea,    0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @awa, @aha, $EnterButton,     0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @awb, @ahb, $FontViewButton,  0)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @awc, @ahc, $CancelButton,    0)
	aw1 = MAX (aw1, aw3)								' aw1 = max Labels
	aw1 = MAX (aw1, aw5)
	aw1 = MAX (aw1, aw7)
	aw2 = MAX (aw2, aw4)								' aw2 = max Boxes
	aw2 = MAX (aw2, aw6)
	aw2 = MAX (aw2, aw8)
	awa = MAX (awa, awb)								' awc = max Buttons
	awa = MAX (awa, awc)

	ah1 = MAX (ah1, ah2)								' ah1 = max Labels/Boxes
	ah1 = MAX (ah1, ah3)
	ah1 = MAX (ah1, ah4)
	ah1 = MAX (ah1, ah5)
	ah1 = MAX (ah1, ah6)
	ah1 = MAX (ah1, ah7)
	ah1 = MAX (ah1, ah8)
	ah1 = MAX (ah1, aha)
	ah1 = MAX (ah1, ahb)
	ah1 = MAX (ah1, ahc)
	ah1 = ah1 + 4
	ah2 = ah1 : ah3 = ah1 : ah4 = ah1 : ah5 = ah1 : ah6 = ah1
	ah7 = ah1 : ah8 = ah1 : ah9 = ah1 : aha = ah1 : ahb = ah1 : ahc = ah1
'
	minX = -1
	minX = MAX (minX, aw9)							' view area
	minX = MAX (minX, aw1 + aw2)				' labels + boxes
	minX = MAX (minX, awa + awb + awc)	' buttons
	minX = minX + bw + bw
'
	minY = ah1 + ah3 + ah5 + ah7 + ah9 + ah9 + ah9 + aha + bw + bw
	v2 = minX
	v3 = minY
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and minimum widths/heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	x = bw
	y = bw
	w = aw1
	h = ah1
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontNameLabel,   0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontSizeLabel,   0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontWeightLabel, 0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontItalicLabel, 0):  y = y + h
'
	x = x + w
	y = bw
	w = v2 - w - bw - bw
	h = ah1
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontNameBox,     0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontSizeBox,     0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontWeightBox,   0):  y = y + h
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontItalicBox,   0):  y = y + h
'
	x = bw
	w = v2 - bw - bw
	h = v3 - ah1 - ah3 - ah5 - ah7 - aha - bw - bw
	XuiSendToKid (grid, #Resize, x, y, @w, @h, $FontViewArea, 0)
'
	x = bw
	y = y + h
	w1 = (v2 - bw - bw) \ 3
	w2 = v2 - w1 - w1 - bw - bw
	h = aha
	XuiSendToKid (grid, #Resize, x, y, @w1, @h, $EnterButton,     0):  x = x + w1
	XuiSendToKid (grid, #Resize, x, y, @w2, @h, $FontViewButton,  0):  x = x + w2
	XuiSendToKid (grid, #Resize, x, y, @w1, @h, $CancelButton,    0)
	XuiSendMessage (grid, #ResizeWindowToGrid, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	SELECT CASE r0
		CASE $FontNameBox			:	GOSUB ClearViewArea
		CASE $FontSizeBox			:	GOSUB ClearViewArea
		CASE $FontWeightBox		:	GOSUB ClearViewArea
		CASE $FontItalicBox		:	GOSUB ClearViewArea
		CASE $EnterButton			:	GOSUB CreateFont
														XuiCallback (grid, #Selection, font, 0, 0, 0, 0, 0)
		CASE $FontViewButton	:	GOSUB ViewFont
		CASE $CancelButton		:	XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  Update  *****
'
SUB Update
	XgrGetFontNames (@count, @fontName$[])			' TrueType only
	IFZ count THEN EXIT SUB
	IF fontName$[0] THEN
		REDIM fontName$[count]											' Add defName$
		FOR i = count TO 1 STEP -1
			SWAP fontName$[i], fontName$[i-1]
		NEXT i
	END IF
	fontName$[0] = defName$
	XuiSendMessage (grid, #SetTextArray, 0, 0, 0, 0, $FontNameBox, @fontName$[])
END SUB
'
'
' *****  ClearViewArea  *****
'
SUB ClearViewArea
	DIM text$[]
	XuiSendToKid (grid, #SetTextArray, 0, 0, 0, 0, $FontViewArea, @text$[])
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FontViewArea, 0)
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FontNameBox, @fontName$)
	IF (fontName$ = defName$) THEN
		XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FontSizeBox,   @defSize$)
		XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FontWeightBox, @defWeight$)
		XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $FontItalicBox, @defItalic$)
		XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FontSizeBox,   0)
		XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FontWeightBox, 0)
		XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FontItalicBox, 0)
	END IF
END SUB
'
'
' *****  CreateFont  *****  Internal: returns font number
'
SUB CreateFont
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FontNameBox,   @fontName$)
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FontSizeBox,   @fontSize$)
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FontWeightBox, @fontWeight$)
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $FontItalicBox, @fontItalic$)
	IF (fontName$ = defName$) THEN fontName$ = ""
	fontSize = XLONG(fontSize$) * 20								' 20th of point
	fontWeight = XLONG(fontWeight$)
	fontItalic = $$FALSE
	IF fontItalic$ THEN
		IF ((fontItalic${0} = 'Y') OR (fontItalic${0} = 'y')) THEN fontItalic = 700
	END IF
	fontAngle = 0
	XgrCreateFont (@font, @fontName$, fontSize, fontWeight, fontItalic, fontAngle)
END SUB
'
'
' *****  ViewFont  *****
'
SUB ViewFont
	GOSUB CreateFont
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
	XuiSendToKid (grid, #SetFontNumber, font, 0, 0, 0, $FontViewArea, 0)
	XuiSendToKid (grid, #SetTextArray, 0, 0, 0, 0, $FontViewArea, @text$[])
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $FontViewArea, 0)
END SUB
'
'
' *****  InitializeTextArray  *****
'
SUB InitializeTextArray
	DIM text$[7]
	t0$ = SPACE$(32)
	t1$ = SPACE$(32)
	t2$ = SPACE$(32)
	t3$ = SPACE$(32)
	t4$ = SPACE$(32)
	t5$ = SPACE$(32)
	t6$ = SPACE$(32)
	t7$ = SPACE$(32)
	FOR i = 0 TO 31
		t0${i} = i +  00
		t1${i} = i +  32
		t2${i} = i +  64
		t3${i} = i +  96
		t4${i} = i + 128
		t5${i} = i + 160
		t6${i} = i + 192
		t7${i} = i + 224
	NEXT i
	t0${'\n'} = ' '
	text$[0] = t0$
	text$[1] = t1$
	text$[2] = t2$
	text$[3] = t3$
	text$[4] = t4$
	text$[5] = t5$
	text$[6] = t6$
	text$[7] = t7$
	XuiSetTextArray (grid, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
	DIM text$[]
END SUB
'
'
' *****  Initialize  *****  ' comment lines in/out as appropriate
'
SUB Initialize
	defName$		= "SystemDefault"
	defSize$		= " 12 point"
	defWeight$	= "400 normal"
	defItalic$	= "No"
	defAngle$		= "  0 degrees"
'
  XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
  func[#Callback]            = 0
  func[#GetSmallestSize]     = 0
  func[#Resize]              = 0
'
  DIM sub[upperMessage]
  sub[#Callback]            = SUBADDRESS (Callback)         ' internal routine
  sub[#Create]              = SUBADDRESS (Create)           ' internal routine (always)
  sub[#CreateWindow]        = SUBADDRESS (CreateWindow)     ' internal routine (always)
  sub[#GetSmallestSize]     = SUBADDRESS (GetSmallestSize)  ' internal routine
  sub[#Resize]              = SUBADDRESS (Resize)           ' internal routine
  sub[#Selection]           = SUBADDRESS (Selection)        ' internal routine
  sub[#Update]              = SUBADDRESS (Update)           ' internal routine
'
	IF func[0] THEN PRINT "XuiFont() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiFont() : Initialize : error ::: (undefined message)"
  XuiRegisterGridType (@XuiFont, "XuiFont", &XuiFont(), @func[], @sub[])
'
  designX = 0
  designY = 0
  designWidth = 320
  designHeight = 240
'
	gridType = XuiFont
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        64)
	XuiSetGridTypeProperty (gridType, @"minHeight",       64)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       8)
	XuiSetGridTypeProperty (gridType, @"indentTop",        4)
	XuiSetGridTypeProperty (gridType, @"style",           0x2A)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $FontNameBox)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $FontNameBox)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
  IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiGrip ()  #####
' ########################
'
'	XuiGrip is for GuiDesigner only (not a public grid)
'
FUNCTION  XuiGrip (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	selectGrid
	STATIC	points[]
	STATIC	loX,  loY,  hiX,  hiY
	STATIC	lastGrid,  lastMessage,  lastX,  lastY,  lastArg1,  lastArg2
	STATIC	SUBADDR		sub[]
	STATIC	SUBADDR  op
	STATIC	upperMessage
	STATIC	XuiGrip
	STATIC	window
	STATIC	cursor
	STATIC	cursor$
	STATIC  visible
	STATIC  block
	STATIC  color
	STATIC  base
	STATIC  gx1, gy1, gx2, gy2
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiGrip) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <  0) THEN v0 = designX
	IF (v1 <  0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
'	v0 = ((v0 + 2) AND -4)
'	v1 = ((v1 + 2) AND -4)
'	v2 = ((v2 + 2) AND -4)
'	v3 = ((v3 + 2) AND -4)
	XuiCreateGrid (@grid, -XuiGrip, @v0, @v1, @v2, @v3, r0, r1, &XuiGrip())
	IF r1 THEN XuiGetColor (r1, #GetColor, @color, 0, 0, 0, 0, 0)
	XuiDisable (grid, #Disable, 0, 0, 0, 0, 0, 0)
	visible = $$FALSE
	base = r1
	gx1 = v0
	gy1 = v1
	gww = v2
	ghh = v3
	gx2 = v0 + v2 - 1
	gy2 = v1 + v3 - 1
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	GOSUB Hide
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Hide  *****
'
SUB Hide
	IFZ visible THEN
'		PRINT "Hide : "; visible
	ELSE
'		PRINT "Hide : "; visible; " ... "
		visible = $$FALSE
		GOSUB Draw
	END IF
END SUB
'
'
' *****  Show  *****
'
SUB Show
	IF visible THEN
'		PRINT "Show : "; visible
	ELSE
'		PRINT "Show : "; visible; " ... "
		visible = $$TRUE
		GOSUB Draw
	END IF
END SUB
'
'
' *****  MouseLocate  *****
'
SUB MouseLocate
	XgrGetGridWindow (grid, @window)
	XgrGetWindowPositionAndSize (window, 0, 0, @winWidth, @winHeight)
	loX = 0 : loY = 0 : hiX = winWidth - 1 : hiY = winHeight - 1
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
'	x1 = gx1 : y1 = gy1 : x2 = gx2 : y2 = gy2
	IF (vv0 < (x1 + 5)) THEN gotLeft = $$TRUE
	IF (vv1 < (y1 + 5)) THEN gotTop = $$TRUE
	IF (vv0 > (x2 - 5)) THEN gotRight = $$TRUE
	IF (vv1 > (y2 - 5)) THEN gotBottom = $$TRUE
	SELECT CASE TRUE
		CASE gotTop AND gotLeft			:	op = SUBADDRESS (MoveTopLeft)			: cur = #cursorArrowsNWSE
		CASE gotTop AND gotRight		:	op = SUBADDRESS (MoveTopRight)		: cur = #cursorArrowsNESW
		CASE gotBottom AND gotLeft	:	op = SUBADDRESS (MoveBottomLeft)	:	cur = #cursorArrowsNESW
		CASE gotBottom AND gotRight	:	op = SUBADDRESS (MoveBottomRight)	: cur = #cursorArrowsNWSE
		CASE gotTop									:	op = SUBADDRESS (MoveTop)					: cur = #cursorArrowsNS
		CASE gotLeft								:	op = SUBADDRESS (MoveLeft)				:	cur = #cursorArrowsWE
		CASE gotRight								:	op = SUBADDRESS (MoveRight)				: cur = #cursorArrowsWE
		CASE gotBottom							:	op = SUBADDRESS (MoveBottom)			: cur = #cursorArrowsNS
		CASE ELSE										:	op = SUBADDRESS (MoveGrid)				: cur = #cursorArrowsAll
	END SELECT
	IFZ cur THEN cur = #cursorArrow
END SUB
'
'
' *****  MouseMove  *****
'
SUB MouseMove
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	GOSUB MouseLocate
	IF cur THEN XgrSetCursor (cur, @cursor)
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	GOSUB MouseLocate
	GOSUB DoneMouseMessage
END SUB
'
'
' *****  MouseExit  *****
'
SUB MouseExit
	XgrSetCursor (cursor, @cur)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	op = $$FALSE																				' no operation to perform
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)			' get grip location
	left = (x1 + 1) AND -4															' snap to MOD 4
	top = (y1 + 1) AND -4																' snap to MOD 4
	right = ((x2 + 2) AND -4) - 1												' snap to MOD 4
	bottom = ((y2 + 2) AND -4) - 1											' snap to MOD 4
	IF ((left != x1) OR (top != y1) OR (right != x2) OR (bottom != y2)) THEN
		GOSUB Hide																				' hide grip
		XgrSetGridPositionAndSize (grid, left, top, right-left+1, bottom-top+1)
		GOSUB Show																				' show grip
	END IF
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XgrConvertLocalToWindow (grid, v0, v1, @vv0, @vv1)
	IF (vv0 < loX) THEN vv0 = loX
	IF (vv0 > hiX) THEN vv0 = hiX
	IF (vv1 < loY) THEN vv1 = loY
	IF (vv1 > hiY) THEN vv1 = hiY
	IF ((vv0 = lastX) AND (vv1 = lastY)) THEN RETURN	' same xy (outta window)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)		' get grid location
	XgrGetGridWindow (grid, @window)
	XgrGetWindowPositionAndSize (window, 0, 0, @winWidth, @winHeight)
	GOSUB Hide																			' hide grip
	GOSUB @op																				' draw grip moved or stretched
	GOSUB Show																			' show grip
	GOSUB DoneMouseMessage
END SUB
'
'
' *****  DoneMouseMessage  *****  Hold state of last mouse message  *****
'
SUB DoneMouseMessage
	lastGrid = grid
	lastMessage = message
	lastX = vv0
	lastY = vv1
	lastArg1 = v2
	lastArg2 = v3
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
'	PRINT "Redraw.A : "; visible;;;; v0; v1; v2; v3
	IF block THEN EXIT SUB
	IF visible THEN
'		PRINT "Redraw.B : "; visible;;;; v0; v1; v2; v3
		XgrGetGridBoxWindow (grid, @wx1, @wy1, @wx2, @wy2)
		block = $$TRUE
		XgrGetGridWindow (grid, @window)
		XgrRedrawWindow (window, $$TRUE, wx1, wy1, wx2-wx1+1, wy2-wy1+1)
		visible = $$FALSE
		block = $$FALSE
	END IF
'	PRINT "Redraw.Z : "; visible;; " ... "
	visible = $$TRUE
	GOSUB Draw
END SUB
'
'
' *****  Draw  *****
'
SUB Draw
	XgrGetGridColors (base, @b, @d, 0, 0, 0, 0, 0, 0)
	XgrSetGridColors (base, -1, b, -1, -1, -1, -1, -1, -1)
	XgrSetGridDrawingMode (base, $$DrawModeXOR, -1, -1)
	XgrGetGridPositionAndSize (grid, @gx, @gy, @gw, @gh)
	XgrGetGridBoxWindow (grid, @lx1, @ly1, @lx2, @ly2)
'	XgrGetGridBoxLocal (grid, @lx1, @ly1, @lx2, @ly2)
	xx1 = lx1 + 4
	yy1 = ly1 + 4
	xx2 = lx2 - 4
	yy2 = ly2 - 4
	XgrDrawBox (base, -1, lx1, ly1, lx2, ly2)
	XgrDrawBox (base, -1, xx1, yy1, xx2, yy2)
'
'	PRINT "Draw : "; lx1; ly1; lx2; ly2;;; xx1; yy1; xx2; yy2;;; gx; gy; gw; gh
'
	points[ 0] = lx1 + 1	: points[ 1] = yy1				' bar 0
	points[ 2] = xx1 - 1	: points[ 3] = yy1
	points[ 4] = xx1			: points[ 5] = yy1 - 1		' bar 1
	points[ 6] = xx1			: points[ 7] = ly1 + 1
	points[ 8] = xx2			: points[ 9] = yy1 - 1		' bar 2
	points[10] = xx2			: points[11] = ly1 + 1
	points[12] = lx2 - 1	: points[13] = yy1				' bar 3
	points[14] = xx2 + 1	: points[15] = yy1
	points[16] = lx2 - 1	: points[17] = yy2				' bar 4
	points[18] = xx2 + 1	: points[19] = yy2
	points[20] = xx2			: points[21] = yy2 + 1		' bar 5
	points[22] = xx2			: points[23] = ly2 - 1
	points[24] = xx1			: points[25] = yy2 + 1		' bar 6
	points[26] = xx1			: points[27] = ly2 - 1
	points[28] = lx1 + 1	: points[29] = yy2				' bar 7
	points[30] = xx1 - 1	: points[31] = yy2
	XgrDrawLines (base, -1, 0, 8, @points[])
	XgrSetGridDrawingMode (base, $$DrawModeSET, -1, -1)
	XgrSetGridColors (base, b, d, -1, -1, -1, -1, -1, -1)
END SUB
'
'
' ******************************************************************
' *****  Subroutines to move whole grid or any side or corner  *****
' ******************************************************************
'
'
' *****  MoveGrid  *****  Move whole grid-box
'
SUB MoveGrid
	dx			= vv0 - lastX													' how far to move in x
	dy			= vv1 - lastY													' how far to move in y
	xx1			= x1 + dx															' left of moved grid-box
	yy1			= y1 + dy															' top of moved grid-box
	xMin		= 0																		' x of window left edge
	yMin		= 0																		' y of window top edge
	width		= winWidth														' width of window
	height	= winHeight														' height of window
	xMax		= width - (x2 - x1)										' max x of upper-left corner
	yMax		= height - (y2 - y1)									' max y of upper-left corner
	IF (xx1 < xMin) THEN xx1 = xMin								' keep grid in window
	IF (yy1 < yMin) THEN yy1 = yMin								' keep grid in window
	IF (xx1 > xMax) THEN xx1 = xMax								' keep grid in window
	IF (yy1 > yMax) THEN yy1 = yMax								' keep grid in window
	xx2			= xx1 + (x2 - x1)											' right of moved grid-box
	yy2			= yy1 + (y2 - y1)											' bottom of moved grid-box
	XgrSetGridPositionAndSize (grid, xx1, yy1, -1, -1)	' set grid-box corners
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, xx1, yy1, -1, -1)	' set grid-box corners
	x1 = xx1 : y1 = yy1 : x2 = xx2 : y2 = yy2						' set new grid location
END SUB
'
'
' *****  MoveTop  *****  Move top side of grid-box
'
SUB MoveTop
	dy			= vv1 - lastY													' how far to move in y (request)
	yy1			= y1 + dy															' fake new top-side
	IF (yy1 < 0) THEN yy1 = 0											' keep grid in window
	IF (yy1 > (y2 - 12)) THEN yy1 = y2 - 12				' keep grid positive size
	ddy			= yy1 - y1														' how far to move in y (final)
	y2			= y2 - ddy														' move top of grid-box
	h				= y2 - yy1 + 1
	XgrSetGridPositionAndSize (grid, x1, yy1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, x1, yy1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveLeft  *****  Move left side of grid-box
'
SUB MoveLeft
	dx			= vv0 - lastX													' how far to move in x (request)
	xx1			= x1 + dx															' fake new left-side
	IF (xx1 < 0) THEN xx1 = 0											' keep grid in window
	IF (xx1 > (x2 - 12)) THEN xx1 = x2 - 12				' keep grid positive size
	ddx			= xx1 - x1														' how far to move in x (final)
	x2			= x2 - ddx														' move right of grid-box
	XgrSetGridPositionAndSize (grid, xx1, y1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, xx1, y1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveRight  *****  Move right side of grid-box
'
SUB MoveRight
	dx			= vv0 - lastX													' how far to move in x (request)
	xx2			= x2 + dx															' fake new right-side
	width		= winWidth														' width of window
	xMax		= width																' max x of upper-right corner
	IF (xx2 > xMax) THEN xx2 = xMax								' keep grid in window
	IF (xx2 < (x1 + 12)) THEN xx2 = x1 + 12				' keep grid positive size
	ddx			= xx2 - x2														' how far to move in x (final)
	x2			= x2 + ddx														' move right of grid-box
	XgrSetGridPositionAndSize (grid, x1, y1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, x1, y1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveBottom  *****  Move bottom side of grid-box
'
SUB MoveBottom
	dy			= vv1 - lastY													' how far to move in y (request)
	yy2			= y2 + dy															' fake new bottom
	height	= winHeight														' height of window
	yMax		= height															' max y of bottom
	IF (yy2 > yMax) THEN yy2 = yMax								' keep grid in window
	IF (yy2 < (y1 + 12)) THEN yy2 = y1 + 12				' keep grid positive size
	ddy			= yy2 - y2														' how far to move in y (final)
	y2			= y2 + ddy														' move right of grid-box
	XgrSetGridPositionAndSize (grid, x1, y1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, x1, y1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveTopLeft  *****  Move top left corner of grid-box
'
SUB MoveTopLeft
	dx			= vv0 - lastX													' how far to move in x (request)
	xx1			= x1 + dx															' fake new left-side
	IF (xx1 < 0) THEN xx1 = 0											' keep grid in window
	IF (xx1 > (x2 - 12)) THEN xx1 = x2 - 12				' keep grid positive size
	ddx			= xx1 - x1														' how far to move in x (final)
	x2			= x2 - ddx														' move right of grid-box
'
	dy			= vv1 - lastY													' how far to move in y (request)
	yy1			= y1 + dy															' fake new top-side
	IF (yy1 < 0) THEN yy1 = 0											' keep grid in window
	IF (yy1 > (y2 - 12)) THEN yy1 = y2 - 12				' keep grid positive size
	ddy			= yy1 - y1														' how far to move in y (final)
	y2			= y2 - ddy														' move top of grid-box
'
	XgrSetGridPositionAndSize (grid, xx1, yy1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, xx1, yy1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveTopRight  *****  Move top right corner of grid-box
'
SUB MoveTopRight
	dx			= vv0 - lastX													' how far to move in x (request)
	xx2			= x2 + dx															' fake new right-side
	width		= winWidth														' width of window
	xMax		= width																' max x of upper-right corner
	IF (xx2 > xMax) THEN xx2 = xMax								' keep grid in window
	IF (xx2 < (x1 + 12)) THEN xx2 = x1 + 12				' keep grid positive size
	ddx			= xx2 - x2														' how far to move in x (final)
	x2			= x2 + ddx														' move right of grid-box
'
	dy			= vv1 - lastY													' how far to move in y (request)
	yy1			= y1 + dy															' fake new top-side
	IF (yy1 < 0) THEN yy1 = 0											' keep grid in window
	IF (yy1 > (y2 - 12)) THEN yy1 = y2 - 12				' keep grid positive size
	ddy			= yy1 - y1														' how far to move in y (final)
	y2			= y2 - ddy														' move top of grid-box
'
	XgrSetGridPositionAndSize (grid, x1, yy1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, x1, yy1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveBottomRight  *****  Move bottom right corner of grid-box
'
SUB MoveBottomRight
	dx			= vv0 - lastX													' how far to move in x (request)
	xx2			= x2 + dx															' fake new right-side
	width		= winWidth														' width of window
	xMax		= width																' max x of upper-right corner
	IF (xx2 > xMax) THEN xx2 = xMax								' keep grid in window
	IF (xx2 < (x1 + 12)) THEN xx2 = x1 + 12				' keep grid positive size
	ddx			= xx2 - x2														' how far to move in x (final)
	x2			= x2 + ddx														' move right of grid-box
'
	dy			= vv1 - lastY													' how far to move in y (request)
	yy2			= y2 + dy															' fake new bottom
	height	= winHeight														' height of window
	yMax		= height															' max y of bottom
	IF (yy2 > yMax) THEN yy2 = yMax								' keep grid in window
	IF (yy2 < (y1 + 12)) THEN yy2 = y1 + 12				' keep grid positive size
	ddy			= yy2 - y2														' how far to move in y (final)
	y2			= y2 + ddy														' move right of grid-box
'
	XgrSetGridPositionAndSize (grid, x1, y1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, x1, y1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  MoveBottomLeft  *****  Move bottom left corner of grid-box
'
SUB MoveBottomLeft
	dx			= vv0 - lastX													' how far to move in x (request)
	xx1			= x1 + dx															' fake new left-side
	IF (xx1 < 0) THEN xx1 = 0											' keep grid in window
	IF (xx1 > (x2 - 12)) THEN xx1 = x2 - 12				' keep grid positive size
	ddx			= xx1 - x1														' how far to move in x (final)
	x2			= x2 - ddx														' move right of grid-box
'
	dy			= vv1 - lastY													' how far to move in y (request)
	yy2			= y2 + dy															' fake new bottom
	height	= winHeight														' height of window
	yMax		= height															' max y of bottom
	IF (yy2 > yMax) THEN yy2 = yMax								' keep grid in window
	IF (yy2 < (y1 + 12)) THEN yy2 = y1 + 12				' keep grid positive size
	ddy			= yy2 - y2														' how far to move in y (final)
	y2			= y2 + ddy														' move right of grid-box
'
	XgrSetGridPositionAndSize (grid, xx1, y1, x2-x1+1, y2-y1+1)
	IF selectGrid THEN XgrSetGridPositionAndSize (selectGrid, xx1, y1, x2-x1+1, y2-y1+1)	' set grid-box corners
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	DIM points[31]
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseMove]						= SUBADDRESS (MouseMove)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
'
	IF func[0] THEN PRINT "XuiGrip() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiGrip() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiGrip, @"XuiGrip", &XuiGrip(), @func[], @sub[])
'
	designX = 4
	designY = 4
	designWidth = 80
	designHeight = 20
'
	gridType = XuiGrip
	XuiSetGridTypeProperty (gridType, @"redrawFlags",      $$RedrawNone)
	XuiSetGridTypeProperty (gridType, @"drawingColor",     $$BrightGrey)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #########################
' #####  XuiLabel ()  #####
' #########################
'
FUNCTION  XuiLabel (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiLabel
	STATIC  oldie
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, @XuiLabel) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiLabel, @v0, @v1, @v2, @v3, r0, r1, &XuiLabel())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiLabel")
END SUB
'
'
' *****  MouseEnter  *****  enable only to test changing cursor
'
SUB MouseEnter
	XgrSetCursor (#cursorHand, @oldie)
END SUB
'
'
' *****  MouseExit  *****  enable only to test changing cursor
'
SUB MouseExit
	XgrSetCursor (oldie, @test)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
'	sub[#MouseEnter]					= SUBADDRESS (MouseEnter)			' enable to test cursor
'	sub[#MouseExit]						= SUBADDRESS (MouseExit)			' enable to test cursor
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)			'
'
	IF func[0] THEN PRINT "XuiLabel() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiLabel() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiLabel, @"XuiLabel", &XuiLabel(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 16
'
	gridType = XuiLabel
	XuiSetGridTypeProperty (gridType, @"x",           designX)
	XuiSetGridTypeProperty (gridType, @"y",           designY)
	XuiSetGridTypeProperty (gridType, @"width",       designWidth)
	XuiSetGridTypeProperty (gridType, @"height",      designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",    4)
	XuiSetGridTypeProperty (gridType, @"minHeight",   4)
	XuiSetGridTypeProperty (gridType, @"align",       $$AlignMiddleCenter)
	XuiSetGridTypeProperty (gridType, @"justify",     $$JustifyCenter)
	XuiSetGridTypeProperty (gridType, @"border",      $$BorderRaise)
	XuiSetGridTypeProperty (gridType, @"texture",     $$TextureRaise1)
	XuiSetGridTypeProperty (gridType, @"can",         $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags", $$RedrawDefaultNoFocus)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiList ()  #####
' ########################
'
FUNCTION  XuiList (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiList
'
	$List					=  0
	$Text					=  1
	$ScrollH			=  2
	$ScrollV			=  3
'
	$TextGrid			=  0								' values[grid,] index
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiList) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiList, @v0, @v1, @v2, @v3, r0, r1, &XuiList())
	XuiSendMessage ( grid, #CreateValueArray, 31, 0, 0, 0, 0, 0)
	XgrGetGridPositionAndSize (grid, @v0, @v1, @v2, @v3)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
'
'	Create, but don't enable textGrid
'
	dx = borderWidth + indentLeft
	dy = borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	XuiArea        (@g, #Create, dx, dy, v2-dx2-13, v3-dy2-13, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiList(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"List")
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
'
	XuiSendMessage ( grid, #SetValue, g, 0, 0, 0, 0, $TextGrid)
	TextMessage    ( grid, #SetValues, 0, 0, 0, 0, 0, 0)
'
'	Create Scroll Bars
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - 12
	h		= 12
	x		= dx
	y		= v3 - dy - h
	XuiScrollBarH  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiList(), -1, -1, $ScrollH, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollH")
'
	w		= 12
	h		= v3 - dy2 - 12
	x		= v2 - dx - w
	y		= dy
	XuiScrollBarV  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiList(), -1, -1, $ScrollV, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollV")
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiList")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValue (grid, #GetValue, @textGrid, 0, 0, 0, 0, $TextGrid)
	IF textGrid THEN
		XuiSendMessage (textGrid, #Destroy, 0, 0, 0, 0, 0, 0)
		XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $TextGrid)
	END IF
	XuiDestroy (grid, #Destroy, v0, v1, v2, v3, r0, r1)
END SUB
'
'
' *****  GetSmallestSize  *****  v0 = # columns, v1 = # rows
'
SUB GetSmallestSize
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	XuiGetAlign (grid, #GetAlign, @align, @justify, @indentX, @indentY, 0, @borderWidth)
	XuiGetMaxMinSize (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	border = borderWidth + borderWidth
	textWidth = maxCharWidth * MAX(v0, 1)
	textHeight = maxCharHeight * MAX(v1, 1)
'
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
'
	SELECT CASE style
		CASE 0	: scrollWidth = 12 : scrollHeight = 12
		CASE 1	: scrollWidth = 12 : scrollHeight = 12
		CASE 2	: scrollWidth = 20 : scrollHeight = 20
		CASE 3	: scrollWidth = 18 : scrollHeight = 18
	END SELECT
'
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignUpperCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignUpperRight		: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignMiddleLeft		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignMiddleCenter	: indentX = indentX + indentX	: indentY = indentY + indentY
		CASE $$AlignMiddleRight		: indentX = indentX + 2				: indentY = indentY + indentY
		CASE $$AlignLowerLeft			: indentX = indentX + 2				: indentY = indentY + 2
		CASE $$AlignLowerCenter		: indentX = indentX + indentX	: indentY = indentY + 2
		CASE $$AlignLowerRight		: indentX = indentX + 2				: indentY = indentY + 2
	END SELECT
	width = textWidth + scrollWidth + border + indentX
	height = textHeight + scrollHeight + border + indentY
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
	v2 = width : v3 = height
END SUB
'
'
' *****  KeyDown  *****  CTRL means more of the same
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
'
	shift = v2 AND $$ShiftBit
	ctrl = v2 AND $$CtrlBit
	alt = v2 AND $$AltBit
	cursorMessage = 0
'
	IFZ alt THEN
		SELECT CASE v2{$$VirtualKey}
			CASE $$KeyLeftArrow
						cursorMessage = #ScrollH									' List widget SCROLLs here
							IF ctrl THEN
								action = #MuchLess
							ELSE
								action = #OneLess
							END IF
			CASE $$KeyRightArrow
						cursorMessage = #ScrollH									' List widget SCROLLs here
						IF ctrl THEN
							action = #MuchMore
						ELSE
							action = #OneMore
						END IF
			CASE $$KeyUpArrow
						cursorMessage = #CursorV
						IF ctrl THEN
							action = #SomeLess											' beginning of page
						ELSE
							action = #OneLess											' up one line
						END IF
			CASE $$KeyDownArrow
						cursorMessage = #CursorV
						IF ctrl THEN
							action = #SomeMore											' end of page
						ELSE
							action = #OneMore											' down one line
						END IF
			CASE $$KeyHome
						action = #Minimum
						IF ctrl THEN
							cursorMessage = #CursorV								' beginning of text
						ELSE
							cursorMessage = #CursorH								' beginning of line
						END IF
			CASE $$KeyEnd
						action = #Maximum
						IF ctrl THEN
							cursorMessage = #CursorV								' end of text
						ELSE
							cursorMessage = #CursorH								' end of line
						END IF
			CASE $$KeyPageDown
						cursorMessage = #ScrollV
						action = #MuchMore
			CASE $$KeyPageUp
						cursorMessage = #ScrollV
						action = #MuchLess
		END SELECT
	END IF
'
	abort = $$FALSE
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort = -1) THEN EXIT SUB
'
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyEnter
			TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
			XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
		CASE $$KeyEscape
			XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
	END SELECT
'
	IF cursorMessage THEN TextMessage (grid, cursorMessage, 0, 0, 0, 0, 0, action)
END SUB
'
'
' *****  MouseDown *****  List considers single and double clicks only
'
SUB MouseDown
	IFZ callback THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	TextMessage (grid, #CursorH, v0, v1, 0, 0, 0, #Change)
	TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	clicks = v2{3, 4}
	IF (clicks = 2) THEN
		TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
		XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, grid)
	END IF
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	IFZ callback THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	TextMessage (grid, #CursorH, v0, v1, 0, 0, 0, #Change)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XgrGetMouseInfo (@window, @g, @xWin, @yWin, @state, @time)
	XuiGetKids (grid, #GetKids, @g1, @k1, @k2, @k3, 0, @k4 )
	IF ((g == k1) || (g == k3)) THEN
			SELECT CASE SIGN(v3)
				CASE -1	: TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeMore)
				CASE 1	:	TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeLess)
			END SELECT
		END IF
END SUB
'
'
' *****  UpdateTextString  *****
'
SUB UpdateTextString
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	upper = UBOUND (text$[])
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
'
	text$ = ""
	IF ((cursorLine >= 0) AND (cursorLine <= upper)) THEN
		XuiGetTextArrayLine (grid, #GetTextArrayLine, cursorLine, 0, 0, 0, 0, @text$)
	END IF
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  PassToText  *****
'
SUB PassToText
	TextMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage  (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollV, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawText  *****
'
SUB RedrawText
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
'
	SELECT CASE style
		CASE 0	: scrollBarSize = 12
		CASE 1	: scrollBarSize = 12
		CASE 2	: scrollBarSize = 16
		CASE 3	: scrollBarSize = 16
	END SELECT
'
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	x		= dx
	y		= dy
	w		= v2 - dx2 - scrollBarSize - 1
	h		= v3 - dy2 - scrollBarSize - 1
	XuiSendToKid (grid, #Resize, x, y, w, h, $Text, 0)
	TextMessage (grid, #Resize, x, y, w, h, 0, 0)				' keep cursor visible
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - scrollBarSize
	h		= scrollBarSize
	x		= dx
	y		= v3 - dy - h
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollH, 0)
'
	w		= scrollBarSize
	h		= v3 - dy2 - scrollBarSize
	x		= v2 - dx - w
	y		= dy
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollV, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Scroll  *****
'
SUB Scroll
	SELECT CASE r0
		CASE $ScrollH		: scroll = #ScrollH
		CASE $ScrollV		: scroll = #ScrollV
	END SELECT
	TextMessage (grid, scroll, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  GetTextStrings  *****  Do same thing as GetTextArray
'
SUB GetTextStrings
	TextMessage (grid, #GetTextArray, v0, v1, v2, v3, 0, @r1$[])
END SUB
'
'
' *****  SetTextStrings  *****  Do same thing as SetTextArray
'
SUB SetTextStrings
	TextMessage (grid, #SetTextArray, v0, v1, v2, v3, 0, @r1$[])
END SUB
'
'
'  ***** SetStyle *****
'
' $Style0 = 0		' normal scroll bars, flat buttons
' $Style1 = 1		' normal scroll bars, flat arrowbuttons
' $Style1 = 2		' recessed scroll bars, arrow buttons
' $Style2 = 3		' windows-style scroll bars, arrow buttons
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 3
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollV, 0)
  XuiGetSize ( grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0 )
	GOSUB Resize
END SUB
'
'
' *****  SendToKids  ****
'
SUB SendToKids
	XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= 0
	func[#GetTextArray]				= 0
	func[#GetTextStrings]			= 0
	func[#GrabTextArray]			= 0
	func[#PokeTextArray]			= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#RedrawText]					= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
	func[#SetTextStrings]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Change]							= SUBADDRESS (Scroll)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextCursor]				= SUBADDRESS (PassToText)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#GetTextArray]				= SUBADDRESS (PassToText)
	sub[#GetTextArrayBounds]	= SUBADDRESS (PassToText)
	sub[#GetTextStrings]			= SUBADDRESS (GetTextStrings)
	sub[#GrabTextArray]				= SUBADDRESS (PassToText)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseWheel]					=	SUBADDRESS (MouseWheel)
	sub[#MuchLess]						= SUBADDRESS (Scroll)
	sub[#MuchMore]						= SUBADDRESS (Scroll)
	sub[#OneLess]							= SUBADDRESS (Scroll)
	sub[#OneMore]							= SUBADDRESS (Scroll)
	sub[#PokeTextArray]				= SUBADDRESS (PassToText)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#RedrawText]					= SUBADDRESS (RedrawText)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetColor]						= SUBADDRESS (SendToKids)
	sub[#SetColorExtra]				= SUBADDRESS (SendToKids)
	sub[#SetFont]							= SUBADDRESS (PassToText)
	sub[#SetFontNumber]				= SUBADDRESS (PassToText)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (PassToText)
	sub[#SetTextCursor]				= SUBADDRESS (PassToText)
	sub[#SetTextStrings]			= SUBADDRESS (SetTextStrings)
	sub[#SomeLess]						= SUBADDRESS (Scroll)
	sub[#SomeMore]						= SUBADDRESS (Scroll)
	sub[#TextReplace]					= SUBADDRESS (PassToText)
'
	IF func[0] THEN PRINT "XuiList() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiList() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiList, @"XuiList", &XuiList(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 80
'
	gridType = XuiList
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        72)
	XuiSetGridTypeProperty (gridType, @"minHeight",       72)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       0)
	XuiSetGridTypeProperty (gridType, @"indentTop",        0)
	XuiSetGridTypeProperty (gridType, @"indentRight",      0)
	XuiSetGridTypeProperty (gridType, @"indentBottom",     0)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $List)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder OR $$RedrawFocus)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###########################
' #####  XuiListBox ()  #####
' ###########################
'
FUNCTION  XuiListBox (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiListBox
'
	$ListBox	= 0
	$Text			= 1
	$Button		= 2
	$List			= 3
'
' $Style2 is not implemented because it causes problems in some applications
'
	$Style0		= 0			' list goes up/down, text line editable
	$Style1		= 1			' list always down, text line editable
	$Style2		= 2			' first underline character is hotkey
'
'	XgrMessageNumberToName (message, @message$)
'	IF grid THEN
'		XuiGetColor (grid, #GetColor, @back, @draw, @low, @high, 0, 0)
'		XuiGetColorExtra (grid, #GetColorExtra, @dull, @accent, @lot, @hit, 0, 0)
'		PRINT STRING$(grid);; LJUST$(message$, 16);; back, draw, low, high, dull, accent, lot, hit,, v0, v1, v2, v3, r0, r1,,
'	END IF
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiListBox) THEN RETURN
	GOSUB @sub[message]
'	PRINT v0, v1, v2, v3
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiListBox, @v0, @v1, 128, 20, r0, r1, &XuiListBox())
	XuiTextLine    (@g, #Create, 0, 0, 108, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListBox(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
	XuiSendMessage ( g, #GetColor, @back, @draw, @low, @high, $Text, 0)
	XuiSendMessage ( g, #GetColorExtra, @accent, @dull, @lowtext, @hightext, $Text, 0)
	XuiPressButton (@g, #Create, 108, 0, 20, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListBox(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"PressButton")
	XuiSendMessage ( g, #SetBorder, $$BorderRaise1, $$BorderRaise1, $$BorderRaise1, 0, 0, 0)
	XuiSendMessage ( g, #SetTexture, $$TextureFlat, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #SetStyle, $$TriangleDown, 0, 0, 0, 0, 0)
	GOSUB CreateList
	GOSUB Resize
END SUB
'
'
' *****  CreateList  *****
'
SUB CreateList
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	XgrGetGridWindow (grid, @window)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoFrame OR $$WindowTypeNoIcon OR window
	XuiList        (@g, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListBox(), -1, -1, $List, grid)
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, 0, 0)
	XuiSendMessage ( g, #SetColorExtra, $$Yellow, $$Yellow, -1, -1, $List, 0)
	XuiSendMessage (grid, #SetValues, g, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	IF (upper < $List) THEN REDIM k[$List]
	k[$List] = g
	XuiSendMessage (grid, #SetKidArray, 0, 0, 0, 0, 0, @k[])
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	r0 = r0 OR $$WindowTypeNoIcon
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiListBox")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  GetTextArrayLine  *****
'
SUB GetTextArrayLine
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #GetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendToKid (grid, #GetTextCursor, @v0, 0, 0, 0, $Text, 0)
	XuiSendMessage (list, #GetTextCursor, 0, @v1, 0, 0, 0, 0)
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @r1$)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @list, @liststate, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	IF (v2 < (v3 + 32)) THEN v2 = v3 + 32
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	x1 = bw : y1 = bw : w1 = v2 - v3 - bw : h1 = v3 - bw - bw
	x2 = v2 - v3 + bw : y2 = bw : w2 = v3 - bw - bw : h2 = v3 - bw - bw
	XuiSendToKid (grid, #Resize, x1, y1, w1, h1, $Text, 0)
	XuiSendToKid (grid, #Resize, x2, y2, w2, h2, $Button, 0)
	XuiSendMessage (list, #Resize, 0, 0, 0, 0, 0, 0)
	XgrGetGridWindow (list, @listWindow)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	GOSUB SizeList
	XuiSendMessage (list, #Resize, 0, 0, x2-x1+1, 0, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	SELECT CASE r0
		CASE $Text			: item = -1
											IF (style == 0) THEN GOSUB PullUp
											XuiSendMessage (list, #GetTextCursor, 0, @cl, 0, 0, 0, 0)
											XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
											XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
											XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											IF text$[] THEN
												IF (text$ = text$[cl]) THEN
													item = cl
												ELSE
													IF text$[] THEN
														upper = UBOUND (text$[])
														FOR i = 0 TO upper
															IF (text$ = text$[i]) THEN item = i : EXIT FOR
														NEXT i
													END IF
												END IF
												IF (item >= 0) THEN XuiSendMessage (list, #SetTextCursor, 0, @item, 0, 0, 0, 0)
											END IF
											XuiCallback (grid, #Selection, item, 0, 0, 0, 1, 0)
		CASE $Button		:	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
											IFZ listState THEN
												GOSUB PullDown
											ELSE
												state = ($$KeyEnter << 24) OR $$KeyEnter
												XuiSendMessage (list, #KeyDown, 0, 0, state, 0, 0, 0)
											END IF
		CASE $List			: XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											XuiSendMessage (list, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
											IF ((v0 >= 0) AND (v0 <= UBOUND(text$[]))) THEN
												text$ = text$[v0]
'												IF (style AND $Style2) THEN
'													under = INSTR (text$, "_")
'													IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'												END IF
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, "")
												XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, "")
												XuiSendToKid (grid, #SetTextCursor, 0, 0, 0, 0, $Text, 0)
												XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
												XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @text$)
												XuiSendToKid (grid, #SetTextCursor, 0, 0, 0, 0, $Text, 0)
												XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
												XuiSendToKid (grid, #SetKeyboardFocus, 0, 0, 0, 0, $Text, 0)
											END IF
											IF (style == 0) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, v0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  PullDown  *****
'
SUB PullDown
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IF listState THEN EXIT SUB
	XgrGetGridWindow (grid, @window)
	XgrGetGridWindow (list, @listWindow)
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 1)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
'
' drop upward if necessary
'
	GOSUB SizeList
	width = x2 - x1 + 1
	XuiGetSize (grid, #GetSize, 0, 0, @ww, @hh, 0, 0)
'
	IF (width < ww) THEN width = ww
	XuiSendMessage (list, #Resize, 0, 0, width, height, 0, 0)
	XuiSendMessage (list, #GetSize, 0, 0, @width, @height, 0, 0)
	IF ((yDrop + height) > #displayHeight) THEN yDrop = yDrop - height - y2 + y1 - 1
	IF ((xDrop + width) > #displayWidth) THEN xDrop = xDrop - width + x2 - x1 + 1
'
' position and display the list window
'
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (list, #ShowWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullUp  *****
'
SUB PullUp
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IFZ listState THEN EXIT SUB
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 1)
	XuiSendMessage (list, #HideWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullToggle  *****
'
SUB PullToggle
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IF listState THEN GOSUB PullUp ELSE GOSUB PullDown
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiSendToKid (grid, #SetColor, v0, v1, v2, v3, $Text, r1)
	XuiSendToKid (grid, #SetColor, v0, v1, v2, v3, $Button, r1)
'
'	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
'	XuiSendMessage (list, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetColorExtra  *****
'
SUB SetColorExtra
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Text, r1)
	XuiSendToKid (grid, message, v0, v1, v2, v3, $Button, r1)

'	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
'	XuiSendMessage (list, message, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
	IF r1$[] THEN text$ = r1$[0]
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
'
'	IF (style AND $Style2) THEN
'		under = INSTR (text$, "_")
'		IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'	END IF
'
	cp = LEN (text$)
	IF r1$[] THEN
		XuiSendMessage (list, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XuiSendMessage (list, #GetTextSpacing, @xgap, @ygap, 0, 0, 0, 0)
		xgap = 0
		XgrGetTextArrayImageSize (font, @r1$[], @w, @h, @width, @height, extra+xgap, extra+ygap)
	END IF
	height = height + 24
	IF (height > 256) THEN height = 256
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @text$)
	XuiSendToKid (grid, #SetTextCursor, cp, 0, 0, 0, $Text, 0)
	XuiSendMessage (list, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SizeList
	XuiSendMessage (list, #Resize, 0, 0, x2-x1+1, height, 0, 0)
	XuiSendMessage (list, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextArrayLine  *****
'
SUB SetTextArrayLine
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #SetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
	ATTACH r1$ TO temp$
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	DIM r1$[]
	ATTACH temp$ TO r1$
END SUB
'
'
' *****  SizeList  *****
'
SUB SizeList
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @list$[])
	height = 0
	IF list$[] THEN
		XuiSendMessage (list, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XuiSendMessage (list, #GetTextSpacing, @xgap, @ygap, 0, 0, 0, 0)
		xgap = 0
		XgrGetTextArrayImageSize (font, @list$[], 0, 0, 0, @height, xgap, ygap)
	END IF
	DIM list$[]
	height = height + 32
	IF (height > 256) THEN height = 256
END SUB
'
'
' *****  SetTextCursor  *****
'
SUB SetTextCursor
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IF (v0 >= 0) THEN XuiSendToKid (grid, #SetTextCursor, v0, 0, 0, 0, $Text, 0)
	IF (v1 >= 0) THEN XuiSendMessage (list, #SetTextCursor, 0, v1, -1, -1, 0, 0)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	cp = LEN (r1$)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @r1$)
	XuiSendToKid (grid, #SetTextCursor, cp, 0, 0, 0, $Text, 0)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	kid = r0
	IF (r0 = $List) THEN r0 = $ListBox
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @r0, grid)
	IF (r0 = -1) THEN EXIT SUB
	contents = v2{$$StateContents}
	IF (contents = 1) THEN XgrJamMessage (grid, #TextModified, 0, 0, 0, 0, 0, 0)
'
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IFZ list THEN EXIT SUB
	key = v2{$$VirtualKey}
'
	IF (v2 AND $$AltBit) THEN
		SELECT CASE key
			CASE $$KeyUpArrow		: GOSUB PullUp		: r0 = -1			' cancel
			CASE $$KeyDownArrow	: GOSUB PullDown	: r0 = -1			' cancel
		END SELECT
	ELSE
		IF (kid != $List) THEN
			SELECT CASE key
				CASE $$KeyUpArrow, $$KeyDownArrow
							XuiSendMessage (list, #KeyDown, v0, v1, v2, v3, 0, list)
							XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @item$[])
							XuiSendMessage (list, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
							IF item$[] THEN
								upper = UBOUND (item$[])
								IF (cl > upper) THEN cl = upper
								IF (cl < 0) THEN cl = 0
								item$ = item$[cl]
								cp = LEN(item$)
								XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Text, @item$)
								XuiSendToKid (grid, #SetTextCursor, cp, 0, 0, 0, $Text, 0)
								XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Text, 0)
							END IF
							r0 = -1
				CASE $$KeyEscape
							IF listState THEN
								IF (style == 0) THEN GOSUB PullUp
							END IF
			END SELECT
		END IF
	END IF
END SUB
'
'
' *****  TextModified  *****
'
SUB TextModified
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
	IFZ list THEN EXIT SUB
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
	IFZ text$ THEN EXIT SUB
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @list$[])
	IFZ list$[] THEN EXIT SUB
	uList = UBOUND (list$[])
	lenText = LEN (text$)
	FOR line = 0 TO uList
		list$ = list$[line]
'		IF (style AND $Style2) THEN
'			under = INSTR (list$, "_")
'			IF under THEN list$ = LEFT$ (list$, under-1) + MID$ (list$, under+1)
'		END IF
		lenLine = LEN (list$)
		IF (lenLine < lenText) THEN DO NEXT
		IF (text$ = LEFT$ (list$, lenText)) THEN EXIT FOR
	NEXT line
	IF (line <= uList) THEN XuiSendMessage (list, #SetTextCursor, 0, line, -1, -1, 0, 0)
END SUB
'
'
' *****  SetStyle  *****
'
' $Style2 is not implemented because it causes problems in some applications
'
'	$Style0		= 0			' list goes up/down, text line editable
'	$Style1		= 1			' list always down, text line editable
' $Style2		= 2			' first underline character is hotkey
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN EXIT SUB
	IF (style > 1) THEN EXIT SUB
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @oldStyle, 0, 0, 0, 0, 0)
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	IF (style = oldStyle) THEN EXIT SUB
'
	SELECT CASE style
		CASE 0:		XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
							XuiSendToKid (grid, #ShowTextCursor, 0, 0, 0, 0, $Text, 0)
							XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
							GOSUB Resize
		CASE 1:		XuiSendToKid (grid, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, $Text, 0)
							XuiSendToKid (grid, #ShowTextCursor, 0, 0, 0, 0, $Text, 0)
							XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
							GOSUB Resize
							XuiSendMessage (list, #ShowWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
'
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
	v0 = style
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#GetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#GetTextString]			= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#SetTextString]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextArray]				= SUBADDRESS (GetTextArray)
	sub[#GetTextArrayLine]		= SUBADDRESS (GetTextArrayLine)
	sub[#GetTextCursor]				= SUBADDRESS (GetTextCursor)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)
'	sub[#Redraw]							= SUBADDRESS (RedrawGrid)
'	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
	sub[#SetTextArrayLine]		= SUBADDRESS (SetTextArrayLine)
	sub[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
	sub[#TextModified]				= SUBADDRESS (TextModified)
'
	IF func[0] THEN PRINT "XuiListBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiListBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiListBox, @"XuiListBox", &XuiListBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiListBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"styleMax",        1)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiListButton ()  #####
' ##############################
'
FUNCTION  XuiListButton (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiListButton
'
	$ListButton	= 0
	$Button			= 1
	$List				= 2
'
' $Style2 is not implemented because is causes problems in some applications
'
	$Style0		= 0			' list goes up/down, text line editable
	$Style1		= 1			' list always down, text line editable
	$Style2		= 2			' first underline character is hotkey
'
'	XgrMessageNumberToName (message, @message$)
'	IF grid THEN
'		XuiGetColor (grid, #GetColor, @back, @draw, @low, @high, 0, 0)
'		XuiGetColorExtra (grid, #GetColorExtra, @dull, @accent, @lot, @hit, 0, 0)
'		PRINT STRING$(grid);; LJUST$(message$, 16);; back, draw, low, high, dull, accent, lot, hit,, v0, v1, v2, v3, r0, r1,,
'	END IF
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiListButton) THEN RETURN
	GOSUB @sub[message]
'	PRINT v0, v1, v2, v3
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiListButton, @v0, @v1, 128, 20, r0, r1, &XuiListButton())
	XuiPressButton (@g, #Create, 108, 0, 20, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListButton(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"PressButton")
	GOSUB CreateList
	GOSUB Resize
END SUB
'
'
' *****  CreateList  *****
'
SUB CreateList
	XgrGetGridWindow (grid, @window)
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoFrame OR $$WindowTypeNoIcon OR window
	XuiList        (@g, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListButton(), -1, -1, $List, grid)
	XuiSendMessage ( g, #SetBorder, $$BorderRidge, $$BorderRidge, $$BorderRidge, 0, 0, 0)
	XuiSendMessage ( g, #SetColorExtra, $$Yellow, $$Yellow, -1, -1, $List, 0)
	XuiSendMessage (grid, #SetValues, g, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	IF (upper < $List) THEN REDIM k[$List]
	k[$List] = g
	XuiSendMessage (grid, #SetKidArray, 0, 0, 0, 0, 0, @k[])
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiListButton")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  ListMessage  *****
'
SUB ListMessage
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  GetTextArrayLine  *****
'
SUB GetTextArrayLine
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #GetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #GetTextCursor, 0, @v1, 0, 0, 0, 0)
	v0 = 0
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Button, @r1$)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	IF (v2 < (v3 + 32)) THEN v2 = v3 + 32
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	x1 = bw : y1 = bw : w1 = v2 - bw - bw : h1 = v3 - bw - bw
	XuiSendToKid (grid, #Resize, x1, y1, w1, h1, $Button, 0)
	XuiSendMessage (list, #Resize, 0, 0, 0, 0, 0, 0)
	XgrGetGridWindow (list, @listWindow)
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	XgrConvertWindowToDisplay (grid, x1, y2+1, @xDrop, @yDrop)
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	GOSUB SizeList
	XuiSendMessage (list, #Redraw, 0, 0, 0, 0, 0, 0)
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	SELECT CASE r0
		CASE $Button		:	abort = 0
											XuiCallback (grid, #Notify, 0, 0, 0, @abort, r0, 0)
											IF abort THEN EXIT SUB
											SELECT CASE style
												CASE 0	: GOSUB PullToggle
												CASE 1	: GOSUB PullDown
											END SELECT
		CASE $List			: XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
											XuiSendMessage (list, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
											IF ((v0 >= 0) AND (v0 <= UBOUND(text$[]))) THEN
												text$ = text$[v0]
'												IF (style AND $Style2) THEN
'													under = INSTR (text$, "_")
'													IF under THEN text$ = LEFT$(text$,under-1) + MID$(text$, under+1)
'												END IF
												XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
											END IF
											IF (style == 0) THEN GOSUB PullUp
											XuiCallback (grid, #Selection, v0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  PullDown  *****
'
SUB PullDown
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 1)
'	IF listState THEN EXIT SUB
'
' position and display list window
'
	GOSUB SizeList
	XgrGetGridWindow (list, @listWindow)
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (list, #ShowWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullUp  *****
'
SUB PullUp
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 1)
'	IFZ listState THEN EXIT SUB
	XuiSendMessage (list, #HideWindow, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  PullToggle  *****
'
SUB PullToggle
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IF listState THEN GOSUB PullUp ELSE GOSUB PullDown
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
'	IF r1$[] THEN text$ = r1$[0]
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SizeList
	XgrGetGridWindow (list, @listWindow)
	XgrSetWindowPositionAndSize (listWindow, xDrop, yDrop, -1, -1)
	XuiSendMessage (list, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextArrayLine  *****
'
SUB SetTextArrayLine
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #SetTextArrayLine, v0, 0, 0, 0, 0, @r1$)
	ATTACH r1$ TO temp$
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	DIM r1$[]
	ATTACH temp$ TO r1$
END SUB
'
'
' *****  SizeList  *****  default is drop-down, but may drop-up if appropriate
'
SUB SizeList
	XgrGetGridBoxDisplay (grid, @x1Disp, @y1Disp, @x2Disp, @y2Disp)
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiSendMessage (list, #GetTextArray, 0, 0, 0, 0, 0, @list$[])
'
	gridheight = y2Disp - y1Disp + 1
	gridwidth = x2Disp - x1Disp + 1
	yDown = y2Disp + 1
	yUp = y1Disp - 1
'
	height = 0
'
	IF list$[] THEN
		xgap = 0
		XuiSendMessage (list, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XuiSendMessage (list, #GetTextSpacing, xgap, @ygap, 0, 0, 0, 0)
		XgrGetTextArrayImageSize (font, @list$[], 0, 0, 0, @height, xgap, ygap)
	END IF
'
	DIM list$[]
	height = height + 32
'
	spaceAbove = yUp + 1
	spaceBelow = #displayHeight - yDown - 1
	spaceMaybe = (spaceAbove + spaceAbove) \ 3
'	spaceMaybe = spaceAbove - (spaceAbove >> 1)
'	spaceMaybe = spaceAbove - (spaceAbove >> 2)
'
	SELECT CASE TRUE
		CASE (height <= spaceBelow)								' place list below button - all items visible
					yDrop = yDown
					xDrop = x1Disp
					width = gridwidth
		CASE (height <= spaceAbove)								' place list above button - all items visible
					yDrop = yUp - height
					xDrop = x1Disp
					width = gridwidth
		CASE (spaceBelow > spaceMaybe)						' place list below button - some items visible
					yDrop = yDown												' list reaches to bottom of display screen
					xDrop = x1Disp
					width = gridwidth
					height = spaceBelow
		CASE ELSE																	' place list above button - some items visible
					yDrop = 0														' list reaches to top of display screen
					xDrop = x1Disp
					width = gridwidth
					height = spaceAbove
	END SELECT
'
' resize list to make sure it doesn't increase width
'
	XuiSendMessage (list, #Resize, 0, 0, width, height, 0, 0)
	XuiSendMessage (list, #GetSize, 0, 0, @width, @height, 0, 0)
	IF ((xDrop + width) > #displayWidth) THEN xDrop = #displayWidth - xDrop
END SUB
'
'
' *****  SetStyle  *****
'
'	$Style0		= 0			' list goes up/down, text line editable
'	$Style1		= 1			' list always down, text line editable
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN EXIT SUB
	IF (style > 1) THEN EXIT SUB
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @oldStyle, 0, 0, 0, 0, 0)
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	IF (style = oldStyle) THEN EXIT SUB
'
	SELECT CASE style
		CASE 0:		XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
							GOSUB Resize
		CASE 1:		XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
							GOSUB Resize
							XuiSendMessage (list, #ShowWindow, 0, 0, 0, 0, 0, 0)
	END SELECT
'
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
	v0 = style
END SUB
'
'
' *****  SetTextCursor  *****
'
SUB SetTextCursor
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IF (v1 >= 0) THEN XuiSendMessage (list, #SetTextCursor, 0, v1, 0, 0, 0, 0)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Button, @r1$)
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	XuiGetValues (grid, #GetValues, @list, @listState, 0, 0, 0, 0)
	IFZ list THEN EXIT SUB
	key = v2{$$VirtualKey}
'
	IF (v2 AND $$AltBit) THEN
		SELECT CASE key
			CASE $$KeyUpArrow		: GOSUB PullUp		: r0 = -1			' cancel
			CASE $$KeyDownArrow	: GOSUB PullDown	: r0 = -1			' cancel
		END SELECT
	ELSE
		IF (r0 != $List) THEN		' avoid infinite loop stack overflow
			IF listState THEN
				SELECT CASE key
					CASE $$KeyUpArrow, $$KeyDownArrow
								XuiSendMessage (list, #KeyDown, v0, v1, v2, v3, 0, list)
								r0 = -1
					CASE $$KeyEnter
								XuiSendMessage (list, #KeyDown, v0, v1, v2, v3, 0, list)
								r0 = -1
					CASE $$KeyEscape
								GOSUB PullUp
								r0 = -1
				END SELECT
			END IF
		END IF
	END IF
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#GetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#GetTextString]			= 0
	func[#Resize]							= 0
	func[#SetStyle]						= 0
	func[#SetTextArray]				= 0
	func[#GetTextArrayLine]		= 0
	func[#SetTextString]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextArray]				= SUBADDRESS (GetTextArray)
	sub[#GetTextArrayLine]		= SUBADDRESS (GetTextArrayLine)
	sub[#GetTextCursor]				= SUBADDRESS (GetTextCursor)
	sub[#GetTextString]				= SUBADDRESS (GetTextString)
'	sub[#Redraw]							= SUBADDRESS (RedrawGrid)
'	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
	sub[#SetTextArrayLine]		= SUBADDRESS (SetTextArrayLine)
	sub[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
'
	IF func[0] THEN PRINT "XuiListButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiListButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiListButton, @"XuiListButton", &XuiListButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiListButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"styleMax",        1)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ################################
' #####  XuiListDialog2B ()  #####  Label, List, TextLine, and 2 PushButtons
' ################################
'
FUNCTION  XuiListDialog2B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiListDialog2B
'
	$Dialog		= 0
	$Label		= 1
	$List			= 2
	$Text			= 3
	$Button0	= 4
	$Button1	= 5
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiListDialog2B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	IF (r1 = #Selection) THEN
		XuiCallback (grid, message, v0, v1, v2, v3, r0, r1)
	ELSE
		message = r1
		callback = message
		IF (message <= upperMessage) THEN GOSUB @sub[message]
	END IF
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiListDialog2B, @v0, @v1, @v2, @v3, r0, r1, &XuiListDialog2B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiList        (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListDialog2B(), -1, -1, $List, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"List")
	XuiTextLine    (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListDialog2B(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextLine")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListDialog2B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiListDialog2B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiListDialog2B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, 10, 8, @listWidth, @listHeight, $List, 64)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, 0, @textHeight, $Text, 8)
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button1
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth + buttonWidth
	IF (width < labelWidth) THEN width = labelWidth
	IF (width < listWidth) THEN width = listWidth
	v2 = width + bw + bw
	v3 = labelHeight + listHeight + buttonHeight + textHeight + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
'	Resize grid
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	h = labelHeight + listHeight + buttonHeight + textHeight + bw + bw
	IF (v3 >= h + 4) THEN
		buttonHeight = buttonHeight + 4 : h = h + 4
		IF (v3 >= h + 4) THEN
			textHeight = textHeight + 4 : h = h + 4
			IF (v3 >= h + 4) THEN
				labelHeight = labelHeight + 4
			END IF
		END IF
	END IF
'
'	Resize kids
'
	x = bw
	y = bw
	w = v2 - bw - bw
	XuiSendToKid (grid, #Resize, x, y, w, labelHeight, $Label, 0)
'
	y = y + labelHeight
	h = v3 - labelHeight - textHeight - buttonHeight - bw - bw
	XuiSendToKid (grid, #Resize, x, y, w, h, $List, 0)
'
	y = y + h
	XuiSendToKid (grid, #Resize, x, y, w, textHeight, $Text, 0)
'
	y = y + textHeight
	h = buttonHeight
	w1 = w >> 1
	w2 = v2 - w1 - bw - bw
	XuiSendToKid (grid, #Resize, x, y, w2, h, $Button0, 0) : x = x + w2
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  GotKeyboardFocus  *****
'
SUB GotKeyboardFocus
	XuiSendToKid (grid, #ShowTextCursor, -1, -1, -1, -1, $Text, 0)
END SUB
'
'
' *****  LostKeyboardFocus  *****
'
SUB LostKeyboardFocus
	XuiSendToKid (grid, #HideTextCursor, -1, -1, -1, -1, $Text, 0)
END SUB
'
'
' *****  KeyDown  *****  Send upArrow, downArrow, pageUp, pageDown to XuiList
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	IF (v2{$$KeyKind} = $$KeyKindVirtual) THEN
		key = v2{8,0}
		SELECT CASE key
			CASE $$KeyUpArrow, $$KeyDownArrow, $$KeyPageUp, $$KeyPageDown
						XuiSendToKid (grid, #KeyDown, v0, v1, v2, v3, $List, r1)
			CASE ELSE
						XuiSendToKid (grid, #KeyDown, v0, v1, v2, v3, $Text, r1)
		END SELECT
	ELSE
		XuiSendToKid (grid, #KeyDown, v0, v1, v2, v3, $Text, r1)
	END IF
END SUB
'
'
' *****  TextEvent  *****
'
SUB TextEvent
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @r0, grid)
	IF (r0 = -1) THEN EXIT SUB
	contents = v2{$$StateContents}
	IF (contents = 1) THEN XgrJamMessage (grid, #TextModified, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  TextModified  *****
'
SUB TextModified
	XuiSendToKid (grid, #GetTextString, 0, 0, 0, 0, $Text, @text$)
	IFZ text$ THEN EXIT SUB
	XuiSendToKid (grid, #GrabTextArray, 0, 0, 0, 0, $List, @list$[])
	IFZ list$[] THEN EXIT SUB
	uList = UBOUND(list$[])
	IF (uList = 0) THEN
		XuiSendToKid (grid, #PokeTextArray, 0, 0, 0, 0, $List, @list$[])
		EXIT SUB
	END IF
	lenText = LEN(text$)
	FOR line = 0 TO uList
		lenLine = LEN(list$[line])
		IF (lenLine < lenText) THEN DO NEXT
		IF (text$ = LEFT$(list$[line],lenText)) THEN EXIT FOR
	NEXT line
	XuiSendToKid (grid, #PokeTextArray, 0, 0, 0, 0, $List, @list$[])
	IF (line <= uList) THEN
		XuiSendToKid (grid, #SetTextCursor, 0, line, -1, -1, $List, 0)
	END IF
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]		= 0
	func[#MouseDown]					= &XuiMouseDownSetKeyboardFocus()
	func[#Resize]							= 0
	func[#Selection]					= &XuiCallback()
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#GotKeyboardFocus]		= SUBADDRESS (GotKeyboardFocus)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#LostKeyboardFocus]		= SUBADDRESS (LostKeyboardFocus)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#TextEvent]						= SUBADDRESS (TextEvent)
	sub[#TextModified]				= SUBADDRESS (TextModified)
'
	IF func[0] THEN PRINT "XuiListDialog2B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiListDialog2B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiListDialog2B, @"XuiListDialog2B", &XuiListDialog2B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 96
	designHeight = 96
'
	gridType = XuiListDialog2B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        designWidth)
	XuiSetGridTypeProperty (gridType, @"minHeight",       designHeight)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiMenu ()  #####
' ########################
'
FUNCTION  XuiMenu (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	originalFocusGrid
	STATIC	SUBADDR  sub[]
	STATIC	menuBarGrid[]
	STATIC	upperMessage
	STATIC	XuiMenu
	STATIC  downEntry
	STATIC  downGrid
	STATIC  outside
	STATIC	downX
	STATIC  downY
	MENUENTRY  hold[]
'
	$Menu     		= 0
	$PullDown			= 1
'
	$StyleHotKey	= 1
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMenu) THEN RETURN
	IF sub[message] THEN GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiMenu, @v0, @v1, @v2, @v3, r0, r1, &XuiMenu())
	XuiMonitorKeyboard (grid, #MonitorKeyboard, grid, &XuiMenu(), 0, 0, 0, $$TRUE)
	GOSUB CreatePullDown
	GOSUB Resize
END SUB
'
'
' *****  CreatePullDown  *****
'
SUB CreatePullDown
	XgrGetGridWindow (grid, @window)
	XgrConvertWindowToDisplay (grid, v0, v1+20, @xDisp, @yDisp)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoSelect OR $$WindowTypeNoFrame OR $$WindowTypeNoIcon OR window
	XuiPullDown    (@g, #CreateWindow, xDisp, yDisp, v2, v3, windowType, 0)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMenu(), -1, -1, $PullDown, grid)
	XuiSendMessage ( g, #SetStyle, $StyleHotKey, -1, 0, 0, 0, 0)
	XuiSendMessage (grid, #SetValues, 0, 0, g, 0, 0, 0)
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	upper = UBOUND(k[])
	IF (upper < $PullDown) THEN REDIM k[$PullDown]
	k[$PullDown] = g
	XuiSendMessage (grid, #SetKidArray, 0, 0, 0, 0, 0, @k[])
'
' start with no menu entries
'
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMenu")
END SUB
'
'
' *****  Cancel  *****
'
SUB Cancel
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	IF hold[] THEN
		hold[0].entry = 0
		XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
		GOSUB Redraw
	END IF
END SUB
'
'
' *****  ContextChange  *****
'
SUB ContextChange
	GOSUB SelectionCancel
	GOSUB Cancel
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiGetValues (grid, #GetValues, 0, 0, @pulldown, 0, 0, 0)
'	XuiSendMessage (pulldown, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @textOrig$)
	IFZ textOrig$ THEN
		XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
	ELSE
		lenTextOrig = LEN(textOrig$)
		text$ = NULL$(lenTextOrig)
		j = -1
		FOR i = 0 TO lenTextOrig - 1
			cchar = textOrig${i}
			IF (cchar != '_') THEN INC j: text${j} = cchar
		NEXT i
		IF (j >= 0) THEN
			text$ = LEFT$(text$, j + 1)
			redraw = $$RedrawDefault AND NOT $$RedrawTextArray
			XuiGetRedrawFlags (grid, #GetRedrawFlags, @redrew, 0, 0, 0, 0, 0)
			XuiSetRedrawFlags (grid, #SetRedrawFlags, @redraw, 0, 0, 0, 0, 0)
			XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
			XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
			XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @textOrig$)
			XuiSetRedrawFlags (grid, #SetRedrawFlags, @redrew, 0, 0, 0, 0, 0)
			v3 = v3 + 2
		ELSE
			XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
			v3 = v3 + 2
		END IF
	END IF
END SUB
'
'
' *****  KeyDown  *****
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	cancel = r0
	IFZ (v2 AND $$AltBit) THEN
		XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
		IFZ pulldown THEN EXIT SUB
		IFZ active THEN EXIT SUB
		XuiSendMessage (pulldown, #KeyDown, v0, v1, v2, v3, 0, r1)
		cancel = $$TRUE
	ELSE
		XuiGetWindow (grid, #GetWindow, @window, 0, 0, 0, 0, 0)
		XgrGetWindowState (window, @state)
		IF (state != 1) THEN EXIT SUB						' window not displayed
		IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
		IFZ hold[] THEN EXIT SUB
		oldEntry = hold[0].entry
		testChar = v2{$$KeyASCII}
		u = UBOUND (hold[])
		entry = $$FALSE
		FOR i = 1 TO u
			IF (testChar == hold[i].hotChar) THEN
				cancel = $$TRUE
				entry = i
				EXIT FOR
			END IF
		NEXT i
		GOSUB NewEntry
	END IF
	r0 = cancel
END SUB
'
'
' *****  Selection  *****  (v0 = r0 = 0 means click outside Menu and PullDownList)
'
'		r0 = source of #Selection message (2+ = pullDownList)
'		v0 = PullDownList entry (0+)
'		v2 = xDrop  (nothing from PullDownLists)
'		v3 = yDrop  (nothing from PullDownLists)
'		r1 = grid
'
SUB Selection
	IF (r0 < 0) THEN EXIT SUB
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	IF ((r0 = 0) AND (v0 <= 0)) THEN GOSUB SelectionCancel : EXIT SUB
	IF (v0 < 0) THEN GOSUB SelectionCancel : EXIT SUB
	IFZ r0 THEN
		INC v0
		IF (v0 = active) THEN EXIT SUB
		IF active THEN
			IF pulldown THEN
				XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
				XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
				XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
			END IF
		END IF
		IF (maxentry < v0) THEN EXIT SUB
		yTop = v1 : xDrop = v2 : yDrop = v3
		XgrGetGridBoxLocal (pulldown, @xw, @yw, @ww, @hh)
		IF ((yDrop + hh) > #displayHeight) THEN
			IF ((yTop - hh) > 0) THEN yDrop = yTop - hh
		END IF
		XgrGetGridWindow (pulldown, @window)
		XuiSendMessage (pulldown, #SetTextCursor, 0, -1, 0, 0, 0, 0)
		XgrSetWindowPositionAndSize (window, xDrop, yDrop, -1, -1)
		XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
		entry = v0
		GOSUB UpdateColor
		GOSUB GetEntryTextArray
'		PRINT "XuiMenu() : #SetCallback : kid = "; entry
		XuiSendMessage (pulldown, #SetCallback, grid, &XuiMenu(), -1, -1, entry, grid)
		XuiSendMessage (pulldown, #SetTextArray, 0, 0, 0, 0, 0, @drop$[])
		XuiSendMessage (pulldown, #Resize, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (pulldown, #ShowWindow, 0, 0, 0, 0, 0, 0)
		XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$TRUE)
		XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$TRUE)
		XuiSetValues (grid, #SetValues, entry, maxentry, pulldown, 0, 0, 0)
	ELSE
		entry = 0
		XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
		XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
		XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
		XuiSetValues (grid, #SetValues, entry, maxentry, pulldown, 0, 0, 0)
		XuiCallback (grid, #Selection, r0-1, v0, 0, 0, r0, grid)
		GOSUB Cancel
	END IF
END SUB
'
'
' *****  SelectionCancel  *****
'
SUB SelectionCancel
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	IFZ active THEN EXIT SUB
	IF (r1 = pulldown) THEN EXIT SUB
	XuiSendMessage (pulldown, #HideWindow, 0, 0, 0, 0, 0, 0)
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
	XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
	GOSUB Cancel
	entry = 0
	XuiSetValues (grid, #SetValues, entry, maxentry, pulldown, 0, 0, 0)
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ hold[] THEN EXIT SUB
'
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
'
	XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$FALSE)
'
	IF (r1 != grid) THEN
		IF XuiGridContainsGridCoord (pulldown, r1, v0, v1, @xx, @yy) THEN
			XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
			EXIT SUB
		END IF
	END IF
'
	entry = 0
	x = v0 : y = v1
	oldEntry = hold[0].entry
	IF (grid == r1) THEN GOSUB FindEntry
	outside = $$FALSE
	downEntry = entry
	downGrid = grid
	GOSUB NewEntry
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ hold[] THEN EXIT SUB
'
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
'
	XuiGridContainsGridCoord (pulldown, r1, v0, v1, @xx, @yy)
	XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
	IF outside THEN EXIT SUB
'
	oldEntry = hold[0].entry
	IFZ oldEntry THEN EXIT SUB
'
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB NewEntry
END SUB
'
'
' *****  MouseEnter  *****
'
SUB MouseEnter
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	IF (downGrid AND (grid = r1)) THEN outside = $$FALSE
	IFZ hold[] THEN EXIT SUB
	oldEntry = hold[0].hover
	IF (grid != r1) THEN EXIT SUB
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseExit  *****
'
SUB MouseExit
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	IF (downGrid AND (grid = r1)) THEN outside = $$TRUE
	IFZ hold[] THEN EXIT SUB
	oldEntry = hold[0].hover
	IF (grid != r1) THEN EXIT SUB
	x = v0 : y = v1
	entry = 0
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseMove  *****
'
SUB MouseMove
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ hold[] THEN EXIT SUB
	IF (outside OR (grid != r1)) THEN EXIT SUB
	oldEntry = hold[0].hover
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	IFZ outside THEN
		XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiMenu(), 0, 0, 0, $$TRUE)
		XuiMonitorContext (grid, #MonitorContext, grid, &XuiMenu(), 0, 0, 0, $$TRUE)
	END IF
	IFZ hold[] THEN EXIT SUB
'
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
'
	entry = 0
	x = v0 : y = v1
	oldEntry = hold[0].entry
'
	IFZ outside THEN
		GOSUB FindEntry
		IF (entry != downEntry) THEN entry = 0
		GOSUB NewEntry
	ELSE
		IF active THEN
			entry = 0
			GOSUB NewEntry
			IF XuiGridContainsGridCoord (pulldown, r1, x, y, @xx, @yy) THEN
				XuiSendMessage (pulldown, message, xx, yy, v2, v3, 0, pulldown)
			END IF
		END IF
	END IF
'
	downEntry = $$FALSE
	downGrid = $$FALSE
	outside = $$FALSE
END SUB
'
'
' *****  MoveEntry  *****
'
SUB MoveEntry
	IFZ hold[] THEN EXIT SUB
	IF (oldEntry == entry) THEN
'		xEntry = hold[entry].firstPixel
		EXIT SUB
	END IF
	IF oldEntry THEN
		color = -1
		SWAP entry, oldEntry
		GOSUB DrawEntry
		SWAP entry, oldEntry
	END IF
	IF entry THEN
		accentoid = $$TRUE
		xEntry = hold[entry].firstPixel
		XuiGetColorExtra (grid, #GetColorExtra, 0, @color, 0, 0, 0, 0)
		GOSUB DrawEntry
	END IF
	hold[0].hover = entry
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
END SUB
'
'
' *****  NewEntry  *****
'
SUB NewEntry
	IFZ hold[] THEN EXIT SUB
	IF (oldEntry == entry) THEN EXIT SUB
	IF oldEntry THEN
		color = -1
		SWAP entry, oldEntry
		GOSUB DrawEntry
		SWAP entry, oldEntry
	END IF
	IF entry THEN
		accentoid = $$TRUE
		xEntry = hold[entry].firstPixel
		XuiGetColorExtra (grid, #GetColorExtra, 0, @color, 0, 0, 0, 0)
		GOSUB DrawEntry
	END IF
	hold[0].entry = hover
	hold[0].entry = entry
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	GOSUB CallbackSelection
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XgrClearGrid (grid, -1)
	IF hold[] THEN
		XuiGetColorExtra (grid, #GetColorExtra, 0, @selectionColor, 0, 0, 0, 0)
		selection = hold[0].entry
		upper = UBOUND (hold[])
		FOR entry = 1 TO upper
			IF (entry == selection) THEN color = selectionColor ELSE color = -1
			IF hold[entry].break THEN GOSUB DrawEntry
		NEXT entry
	ELSE
		PRINT "XuiMenu() : Redraw : error (empty temp[])"; grid
	END IF
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  Resize  *****  move/size Menu, then move/size pulldowns
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiGetAlign (grid, #GetAlign, 0, 0, 0, @indentY, 0, @borderWidth)
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
'	height = maxCharHeight - gap + 1
	height = maxCharHeight + 3
	minY = (borderWidth << 1) + (indentY << 1) + height
	v3 = MAX (v3, minY)
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	GOSUB SetMenuString
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
'
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiSendMessage (pulldown, #Resize, 0, 0, 0, 0, 0, 0)
	XuiResizeWindowToGrid (pulldown, #ResizeWindowToGrid, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *********************************
' *****  UTILITY SUBROUTINES  *****
' *********************************
'
'
' *****  CallbackSelection  *****
'
SUB CallbackSelection
	xDrop = 0
	yDrop = 0
	IF entry THEN
		XgrGetGridBoxDisplay (grid, @x1Disp, @y1Disp, @x2Disp, @y2Disp)
		xDrop = x1Disp + xEntry - 5
		yDrop = y2Disp + 1
		yTop = y1Disp - 1
		v0 = entry
		v1 = yTop
		v2 = xDrop
		v3 = yDrop
		r1 = grid
	ELSE
		v0 = -1
		v1 = r1
		v2 = xDrop
		v3 = yDrop
	END IF
	GOSUB Selection
END SUB
'
'
' *****  CollectEntry  *****  index defined for this grid
'
SUB CollectEntry
	IFZ hold[] THEN EXIT SUB
	first = i
	DO WHILE (i <= length)
		IF ((char == ' ') OR (char == '\t') OR (char == '\r') OR (char == '\n') OR (char == 0x00)) THEN		' whitespace terminator
			name$		= MID$ (text$, first+1, i-first)
			prior$	= LEFT$ (text$, first)
			after$	= LEFT$ (text$, i)
			XgrGetTextImageSize (font, @prior$, 0, 0, @priorWidth, 0, @gap, @space)
			XgrGetTextImageSize (font, @after$, 0, 0, @afterWidth, 0, 0, 0)
			hold[entry].name				= name$
			hold[entry].entry				= entry
			hold[entry].height			= height
			hold[entry].indentY			= indentY
			hold[entry].gap					= gap
			hold[entry].firstChar		= first
			hold[entry].firstPixel	= priorWidth + 5
			hold[entry].afterPixel	= afterWidth + 5
			hold[entry].break				= afterWidth + 4095
			hold[entry-1].break			= (hold[entry-1].afterPixel + priorWidth + 6) >> 1
			EXIT DO
		END IF
		IF (char = '_') THEN
			previousChar = 0
			IF (i > 0) THEN previousChar = text${i-1}
			IF (previousChar != '\\') THEN
				hotChar = hold[entry].hotChar
				IFZ hotChar THEN
					hotChar = text${i+1}
					IF ((hotChar >= 'a') AND (hotChar <= 'z')) THEN hotChar = hotChar - 0x20
					IF ((hotChar > ' ') AND (hotChar < 0x7F)) THEN hold[entry].hotChar = hotChar
				END IF
			END IF
			IF i THEN
				text$ = LEFT$ (text$, i) + MID$ (text$, i+2)
			ELSE
				text$ = MID$ (text$, 2)
			END IF
			prior$	= LEFT$ (text$, i)
			after$	= LEFT$ (text$, i+1)
			IFZ hold[entry].afterUnder THEN
				XgrGetTextImageSize (font, @prior$, 0, 0, @firstUnder, 0, 0, 0)
				XgrGetTextImageSize (font, @after$, 0, 0, @afterUnder, 0, 0, 0)
				hold[entry].firstUnder = firstUnder + 5
				hold[entry].afterUnder = afterUnder + 3
			END IF
			DEC length
			DEC i
		END IF
		INC i
		char = text${i}
	LOOP
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
END SUB
'
'
' *****  DrawEntry  *****
'
SUB DrawEntry
	IFZ hold[] THEN XuiGetMenuEntryArray (grid, #GetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
	IFZ hold[] THEN EXIT SUB
	IFZ entry THEN EXIT SUB
	afterPixel = hold[entry].afterPixel + 3
	XgrGetGridBoxLocal (grid, @xx1, @yy1, @xx2, @yy2)
	IF (xx2 < afterPixel) THEN EXIT SUB
	height = hold[entry].height
	y2 = hold[entry].indentY
	gap = hold[entry].gap
	XgrMoveTo (grid, hold[entry].firstPixel, y2)
	name$	= hold[entry].name
'
	XgrDrawText (grid, color, @name$)
	IF hold[entry].afterUnder THEN
'		IF gap THEN INC height
		first = hold[entry].firstUnder
		after	= hold[entry].afterUnder
		XgrDrawLine (grid, color, first, y2+height, after, y2+height)
	END IF
END SUB
'
'
' *****  FindEntry  *****
'
SUB FindEntry
	u = UBOUND (hold[])
	found = 0
	FOR entry = 1 TO u
		check = hold[entry].entry
		IF check THEN
			IF (x < hold[entry].break) THEN
				found = entry
				EXIT FOR
			END IF
		END IF
	NEXT
	entry = found
END SUB
'
'
' *****  GetIndentY  *****  In:  height (maxCharHeight - gap + 1)
'
SUB GetIndentY
	XuiGetAlign (grid, #GetAlign, @align, 0, 0, 0, 0, @borderHeight)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	gridHeight	= y2 - y1
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentY = indentTop + borderHeight
		CASE $$AlignUpperCenter		: indentY = indentTop + borderHeight
		CASE $$AlignUpperRight		: indentY = indentTop + borderHeight
		CASE $$AlignMiddleLeft		: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignMiddleCenter	: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignMiddleRight		: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignLowerLeft			: indentY = ((gridHeight - height) - indentBottom) - 2
		CASE $$AlignLowerCenter		: indentY = ((gridHeight - height) - indentBottom) - 2
		CASE $$AlignLowerRight		: indentY = ((gridHeight - height) - indentBottom) - 2
	END SELECT
	IF (indentY < 0) THEN indentY = 0
	IF (indentY < borderHeight) THEN indentY = borderHeight
END SUB
'
'
' *****  SkipWhitespace  *****
'
SUB SkipWhitespace
	DO WHILE (i < length)
		char = text${i}
		SELECT CASE char
			CASE ' '		:	text${i} = ' '		' leave space a space
			CASE '\t'		: text${i} = ' '		' convert tab to space
			CASE '\r'		: text${i} = ' '		' convert return to space
			CASE '\n'		: text${i} = ' '		' convert newline to space
			CASE ELSE		: EXIT DO
		END SELECT
		INC i
	LOOP
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiSendMessage (pulldown, #SetColor, v0, v1, v2, v3, -1, r1)
END SUB
'
'
' *****  SetColorExtra  *****
'
SUB SetColorExtra
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiSendMessage (pulldown, #SetColorExtra, v0, v1, v2, v3, -1, r1)
END SUB
'
'
' *****  UpdateColor  *****
'
SUB UpdateColor
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiGetColor (grid, #GetColor, @back, @draw, @low, @high, 0, 0)
	XuiGetColorExtra (grid, #GetColorExtra, @dull, @acc, @lo, @hi, 0, 0)
	XuiSendMessage (pulldown, #SetColor, back, draw, low, high, -1, 0)
	XuiSendMessage (pulldown, #SetColorExtra, dull, acc, lo, hi, -1, 0)
END SUB
'
'
' *****  GetEntryTextArray  *****
'
' entry = entry on XuiMenuBar (1=file, 2=edit, 3=view, etc)
' drop$[] = text that belongs in the pulldown list
'
SUB GetEntryTextArray
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @raw$[])
	upper = UBOUND (raw$[])
	DIM drop$[]
'
	IF (upper < 0) THEN EXIT SUB
'
	v = 1
	drop = -1
	tops = $$FALSE
'
	FOR t = 0 TO upper
		a$ = raw$[t]
		IF a$ THEN
			char = a${0}
			package = $$TRUE
			IF ((char = ' ') OR (char = '\t')) THEN		' PullDown entry
				IF (v < 2) THEN DO NEXT									' no MenuBar entry yet
				INC drop
				a$ = TRIM$ (a$)
				drop$[drop] = a$
				package = $$FALSE
				IF (t == upper) THEN tops = $$TRUE
			END IF
			IF tops OR package THEN										' MenuBar entry or done
				IF (v >= 2) THEN
					IF (v == entry) THEN
						IF (drop < 0) THEN DIM drop$[] ELSE REDIM drop$[drop]
						EXIT FOR
					END IF
				END IF
				IFZ tops THEN
					um = UBOUND (a$)
					last = a${um}
					IF (last != ' ') THEN a$ = a$ + "  "
					text$ = text$ + a$
				END IF
				DIM drop$[upper]
				drop = -1
				INC v																		' next MenuBar entry
			END IF
		END IF
	NEXT t
END SUB
'
'
' *****  SetTextArray  *****  r1$[0] = MenuString : r1$[1+] = PullDownLists
'
SUB SetTextArray
	XuiGetValues (grid, #GetValues, @active, @maxentry, @pulldown, 0, 0, 0)
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiSetTextArray (grid, #SetTextArray, 0, 0, 0, 0, 0, @r1$[])
	ut = UBOUND (r1$[])
	text$ = ""
'
	IFZ r1$[] THEN
		GOSUB SetMenuString
		EXIT SUB
	END IF
'
'	create pulldown menu windows
'
	v = 1
	XgrGetGridWindow (grid, @window)
	windowType = $$WindowTypeTopMost OR $$WindowTypeNoSelect OR $$WindowTypeNoFrame OR window
'
' collect MenuBar entries and PullDown text array for each MenuBar entry
'
	FOR t = 0 TO ut
		a$ = r1$[t]
		IF a$ THEN
			char = a${0}
			package = $$TRUE
			IF ((char = ' ') OR (char = '\t')) THEN		' PullDown entry
				IF (v < 2) THEN DO NEXT									' no MenuBar entry yet
				package = $$FALSE
				IF (t = ut) THEN tops = $$TRUE
			END IF
			IF tops OR package THEN										' MenuBar entry or done
				IFZ tops THEN
					um = UBOUND (a$)
					last = a${um}
					IF (last != ' ') THEN a$ = a$ + "  "
					text$ = text$ + a$
				END IF
				drop = -1
				INC v																		' next MenuBar entry
			END IF
		END IF
	NEXT t
	active = 0
	maxentry = v
	text$ = RTRIM$ (text$)
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
	XuiSetValues (grid, #SetValues, active, maxentry, pulldown, 0, 0, 0)
	GOSUB SetMenuString
END SUB
'
'
' *****  SetMenuString  *****
'
SUB SetMenuString
	top = 7
	DIM hold[]
	DIM hold[top]
'
	hold[0].name = ""
	hold[0].entry = 0
	hold[0].break = 0
	hold[0].height = 0
'	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
'
	IF text$ THEN
		XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
'		height = maxCharHeight - gap + 1
		height = maxCharHeight + 1
'
		length = -1
		GOSUB GetIndentY
		length = LEN (text$)
		FOR offset = 0 TO length
			char = text${offset}
			SELECT CASE char
				CASE ' '	: length = offset
				CASE '\t'	: length = offset
				CASE '\r'	: length = offset
				CASE '\n' : length = offset
				CASE 0x00	: length = offset
			END SELECT
		NEXT offset
		IF (length < 0) THEN length = 0
		text$ = LEFT$ (text$, length)
		offset = 0
		entry = 0
		i = 0
'
		DO WHILE (i < length)
			GOSUB SkipWhitespace
			IF (i >= length) THEN EXIT DO
			INC entry
			IF (entry > top) THEN
				top = (top + 8) OR 7
				REDIM hold[top]
			END IF
			GOSUB CollectEntry
		LOOP
		IFZ entry THEN text$ = ""
	END IF
	XuiSetMenuEntryArray (grid, #SetMenuEntryArray, 0, 0, 0, 0, 0, @hold[])
END SUB
'
'
' *****  SetFont  *****
'
SUB SetFont
	r = r1 : r1 = 0
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	r1 = r
END SUB
'
'
' *****  SetFontNumber  *****
'
SUB SetFontNumber
	r = r1 : r1 = 0
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
	GOSUB SetTextArray
	r1 = r
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= 0
	func[#Destroy]						= 0
	func[#MouseDown]					= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#Selection]					= 0
	func[#SetTextArray]				= 0
	func[#SetTextString]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Cancel]							= SUBADDRESS (Cancel)
	sub[#ContextChange]				= SUBADDRESS (ContextChange)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseEnter]					= SUBADDRESS (MouseEnter)
	sub[#MouseExit]						= SUBADDRESS (MouseExit)
	sub[#MouseMove]						= SUBADDRESS (MouseMove)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetColor]						= SUBADDRESS (SetColor)
	sub[#SetColorExtra]				= SUBADDRESS (SetColorExtra)
	sub[#SetFont]							= SUBADDRESS (SetFont)
	sub[#SetFontNumber]				= SUBADDRESS (SetFontNumber)
	sub[#SetTextArray]				= SUBADDRESS (SetTextArray)
'
	IF func[0] THEN PRINT "XuiMenu() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMenu() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMenu, @"XuiMenu", &XuiMenu(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiMenu
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        12)
	XuiSetGridTypeProperty (gridType, @"minHeight",       12)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleLeft)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###########################
' #####  XuiMenuBar ()  #####
' ###########################
'
FUNCTION  XuiMenuBar (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1$[]))
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMenuBar
	STATIC  downGrid
	STATIC  outside
	STATIC	downX
	STATIC  downY
	MENUENTRY  temp[]
	MENUENTRY  copy[]
'
	$Menu     = 0
	$PullDown = 1
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMenuBar) THEN RETURN
	IF sub[message] THEN
		GOSUB CopyArray
		GOSUB @sub[message]
		XuiPokeArray (grid, #PokeArray, 0, 0, 0, 0, 0, @temp[])
	END IF
	RETURN
'
'
' *****  Blowback  *****
'
SUB Blowback
	XuiGrabArray (grid, #GrabArray, 0, 0, 0, 0, 0, @copy[])
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiMenuBar, @v0, @v1, @v2, @v3, r0, r1, &XuiMenuBar())
	XuiMonitorKeyboard (grid, #MonitorKeyboard, grid, &XuiMenuBar(), 0, 0, 0, $$TRUE)
	GOSUB CreatePullDown
	GOSUB Resize
END SUB
'
'
' *****  CreatePullDown  *****
'
SUB CreatePullDown
	DIM temp[]
	DIM copy[]
	XuiPokeArray (grid, #PokeArray, 0, 0, 0, 0, 0, @copy[])
END SUB
'
'
' *****  CopyArray  *****
'
SUB CopyArray
	DIM temp[]
	XuiGrabArray (grid, #GrabArray, 0, 0, 0, 0, 0, @copy[])
	IF copy[] THEN
		upper = UBOUND (copy[])
		DIM temp[upper]
		FOR me = 0 TO upper
			temp[me] = copy[me]
		NEXT me
	END IF
	XuiPokeArray (grid, #PokeArray, 0, 0, 0, 0, 0, @copy[])
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMenuBar")
END SUB
'
'
' *****  Cancel  *****
'
SUB Cancel
	IF temp[] THEN
		temp[0].entry = 0
		GOSUB Redraw
	END IF
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @textOrig$)
	IFZ textOrig$ THEN
		XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
	ELSE
		lenTextOrig = LEN(textOrig$)
		text$ = NULL$(lenTextOrig)
		j = -1
		FOR i = 0 TO lenTextOrig - 1
			cchar = textOrig${i}
			IF (cchar != '_') THEN INC j: text${j} = cchar
		NEXT i
		IF (j >= 0) THEN
			text$ = LEFT$(text$, j + 1)
			redraw = $$RedrawDefault AND NOT $$RedrawTextArray
			XuiGetRedrawFlags (grid, #GetRedrawFlags, @redrew, 0, 0, 0, 0, 0)
			XuiSetRedrawFlags (grid, #SetRedrawFlags, @redraw, 0, 0, 0, 0, 0)
			XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
			XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
			XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @textOrig$)
			XuiSetRedrawFlags (grid, #SetRedrawFlags, @redrew, 0, 0, 0, 0, 0)
			v3 = v3 + 2
		ELSE
			XuiGetSmallestSize (grid, #GetSmallestSize, 0, 0, @v2, @v3, 0, 0)
			v3 = v3 + 2
		END IF
	END IF
END SUB
'
'
' *****  KeyDown  *****
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	IFZ (v2 AND $$AltBit) THEN EXIT SUB
	XuiGetWindow (grid, #GetWindow, @window, 0, 0, 0, 0, 0)
	XgrGetWindowState (window, @state)
	IF (state != 1) THEN EXIT SUB						' window not displayed
	IFZ temp[] THEN EXIT SUB
	testChar = v2{$$KeyASCII}
	oldEntry = temp[0].entry
	upper = UBOUND (temp[])
	entry = $$FALSE
	FOR i = 1 TO upper
		IF (testChar = temp[i].hotChar) THEN
			r0 = $$TRUE
			entry = i
			EXIT FOR
		END IF
	NEXT i
	GOSUB NewEntry
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ temp[] THEN EXIT SUB
	x = v0 : y = v1
	oldEntry = temp[0].entry
	IF (grid = r1) THEN GOSUB FindEntry ELSE entry = 0
	outside = $$FALSE
	downGrid = grid
	GOSUB NewEntry
	IF (entry = oldEntry) THEN GOSUB CallbackSelection
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ temp[] THEN EXIT SUB
	IF (outside OR (grid != r1)) THEN EXIT SUB
	oldEntry = temp[0].entry
	IFZ oldEntry THEN EXIT SUB
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB NewEntry
END SUB
'
'
' *****  MouseEnter  *****
'
SUB MouseEnter
	IF downGrid THEN outside = $$FALSE
	IFZ temp[] THEN EXIT SUB
	oldEntry = temp[0].hover
	IF (grid != r1) THEN EXIT SUB
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseExit  *****
'
SUB MouseExit
	IF downGrid THEN outside = $$TRUE
	IFZ temp[] THEN EXIT SUB
	oldEntry = temp[0].hover
	IF (grid != r1) THEN EXIT SUB
	x = v0 : y = v1
	entry = 0
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseMove  *****
'
SUB MouseMove
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IFZ temp[] THEN EXIT SUB
	IF (outside OR (grid != r1)) THEN EXIT SUB
	oldEntry = temp[0].hover
	x = v0 : y = v1
	GOSUB FindEntry
	GOSUB MoveEntry
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	IFZ temp[] THEN EXIT SUB
	x = v0 : y = v1
	IF (grid = r1) THEN GOSUB FindEntry ELSE entry = 0
	oldEntry = temp[0].entry
	temp[0].entry = 0
	SWAP entry, oldEntry
	GOSUB DrawEntry
	SWAP entry, oldEntry
	downGrid = $$FALSE
	outside = $$FALSE
	IFZ entry THEN GOSUB CallbackSelection
END SUB
'
'
' *****  MoveEntry  *****
'
SUB MoveEntry
	IF (oldEntry = entry) THEN
		xEntry = temp[entry].firstPixel
		EXIT SUB
	END IF
	IF oldEntry THEN
		color = -1
		SWAP entry, oldEntry
		GOSUB DrawEntry
		SWAP entry, oldEntry
	END IF
	IF entry THEN
		accentoid = $$TRUE
		xEntry = temp[entry].firstPixel
		XuiGetColorExtra (grid, #GetColorExtra, 0, @color, 0, 0, 0, 0)
		GOSUB DrawEntry
	END IF
	temp[0].hover = entry
END SUB
'
'
' *****  NewEntry  *****
'
SUB NewEntry
	IF (oldEntry = entry) THEN
		xEntry = temp[entry].firstPixel
		EXIT SUB
	END IF
	IF oldEntry THEN
		color = -1
		SWAP entry, oldEntry
		GOSUB DrawEntry
		SWAP entry, oldEntry
	END IF
	IF entry THEN
		accentoid = $$TRUE
		xEntry = temp[entry].firstPixel
		XuiGetColorExtra (grid, #GetColorExtra, 0, @color, 0, 0, 0, 0)
		GOSUB DrawEntry
	END IF
	temp[0].hover = entry
	temp[0].entry = entry
	GOSUB CallbackSelection
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XgrClearGrid (grid, -1)
	IF temp[] THEN
		XuiGetColorExtra (grid, #GetColorExtra, 0, @selectionColor, 0, 0, 0, 0)
		selection = temp[0].entry
		upper	= UBOUND (temp[])
		FOR entry = 1 TO upper
			IF (entry = selection) THEN color = selectionColor ELSE color = -1
			IF temp[entry].break THEN GOSUB DrawEntry
		NEXT entry
	ELSE
'		PRINT "XuiMenuBar() : Redraw : error (empty temp[])"; grid
	END IF
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize				' returns bw and heights
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
'	height = maxCharHeight - gap + 1
	height = maxCharHeight + 3
	minY = borderWidth + borderWidth + indentTop + indentBottom + height
	v3 = MAX (v3, minY)
	XuiPositionGrid (grid, v0, v1, @v2, @v3)
'
'	reset text in case of font change
'
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	GOSUB SetMenuString
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  SetFont  *****
'
SUB SetFont
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	GOSUB SetMenuString
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  SetFontNumber  *****
'
SUB SetFontNumber
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	GOSUB SetMenuString
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	text$ = r1$
	GOSUB SetMenuString
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  SetMenuString  *****
'
SUB SetMenuString
	top = 7
	DIM temp[]
	DIM temp[top]
	temp[0].name = ""
	temp[0].entry = 0
	temp[0].break = 0
	temp[0].height = 0
'	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
'
	IF text$ THEN
		XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
'		height = maxCharHeight - gap + 1
		height = maxCharHeight + 1
'
		length = -1
		GOSUB GetIndentY
		length = LEN (text$)
		FOR offset = 0 TO length
			char = text${offset}
			SELECT CASE char
				CASE ' '	: length = offset
				CASE '\t'	: length = offset
				CASE '\r'	: length = offset
				CASE '\n' : length = offset
				CASE 0x00	: length = offset
			END SELECT
		NEXT offset
		IF (length < 0) THEN length = 0
		text$ = LEFT$ (text$, length)
		offset = 0
		entry = 0
		i = 0
'
		DO WHILE (i < length)
			GOSUB SkipWhitespace
			IF (i >= length) THEN EXIT DO
			INC entry
			IF (entry > top) THEN
				top = (top + 8) OR 7
				REDIM temp[top]
			END IF
			GOSUB CollectEntry
		LOOP
		IFZ entry THEN text$ = ""
	END IF
END SUB
'
'
' *********************************
' *****  UTILITY SUBROUTINES  *****
' *********************************
'
'
' *****  CallbackSelection  *****
'
SUB CallbackSelection
	xDrop = 0
	yDrop = 0
	IF entry THEN
		XgrGetGridWindow (grid, @menuWindow)
		XgrGetWindowPositionAndSize (menuWindow, @xDisp, @yDisp, 0, 0)
		XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
		xDrop = xDisp + x1 + xEntry - 5
		yDrop = yDisp + y2 + 1
		yTop = yDisp - 1
		XuiCallback (grid, #Selection, entry, yTop, xDrop, yDrop, 0, grid)
	ELSE
		XuiCallback (grid, #Selection, -1, r1, xDrop, yDrop, 0, grid)
	END IF
END SUB
'
'
' *****  CollectEntry  *****  index defined for this grid
'
SUB CollectEntry
	first = i
	DO WHILE (i <= length)
		IF ((char == ' ') OR (char == '\t') OR (char == '\r') OR (char == '\n') OR (char == 0x00)) THEN		' whitespace terminator
			name$ = MID$ (text$, first+1, i-first)
			prior$ = LEFT$ (text$, first)
			after$ = LEFT$ (text$, i)
			XgrGetTextImageSize (font, @prior$, 0, 0, @priorWidth, 0, @gap, @space)
			XgrGetTextImageSize (font, @after$, 0, 0, @afterWidth, 0, 0, 0)
			temp[entry].name				= name$
			temp[entry].entry				= entry
			temp[entry].height			= height
			temp[entry].indentY			= indentY
			temp[entry].gap					= gap
			temp[entry].firstChar		= first
			temp[entry].firstPixel	= priorWidth + 5
			temp[entry].afterPixel	= afterWidth + 5
			temp[entry].break				= afterWidth + 4095
			temp[entry-1].break			= (temp[entry-1].afterPixel + priorWidth + 6) >> 1
			EXIT DO
		END IF
		IF (char = '_') THEN
			previousChar = 0
			IF (i > 0) THEN previousChar = text${i-1}
			IF (previousChar != '\\') THEN
				hotChar = temp[entry].hotChar
				IFZ hotChar THEN
					hotChar = text${i+1}
					IF ((hotChar >= 'a') AND (hotChar <= 'z')) THEN hotChar = hotChar - 0x20
					IF ((hotChar > ' ') AND (hotChar < 0x7F)) THEN temp[entry].hotChar = hotChar
				END IF
			END IF
			IF i THEN
				text$ = LEFT$ (text$, i) + MID$ (text$, i+2)
			ELSE
				text$ = MID$ (text$, 2)
			END IF
			prior$	= LEFT$ (text$, i)
			after$	= LEFT$ (text$, i+1)
			IFZ temp[entry].afterUnder THEN
				XgrGetTextImageSize (font, @prior$, 0, 0, @firstUnder, 0, 0, 0)
				XgrGetTextImageSize (font, @after$, 0, 0, @afterUnder, 0, 0, 0)
				temp[entry].firstUnder = firstUnder + 5
				temp[entry].afterUnder = afterUnder + 3
			END IF
			DEC length
			DEC i
		END IF
		INC i
		char = text${i}
	LOOP
END SUB
'
'
' *****  DrawEntry  *****  index defined for this grid
'		Here we "clip" the gap--possible DANGER
'		NOTE:  CANNOT use XgrDrawTextFill() as it will fill the gap...
'
SUB DrawEntry
	IFZ entry THEN EXIT SUB
	afterPixel = temp[entry].afterPixel + 3
	XgrGetGridBoxLocal (grid, @xx1, @yy1, @xx2, @yy2)
	IF (xx2 < afterPixel) THEN EXIT SUB
	height = temp[entry].height
	y2 = temp[entry].indentY
	gap = temp[entry].gap
'	IF gap THEN y2 = y2 - gap + 1
	XgrMoveTo (grid, temp[entry].firstPixel, y2)
	name$	= temp[entry].name
'
	XgrDrawText (grid, color, @name$)
	IF temp[entry].afterUnder THEN
'		IF gap THEN INC height
		first = temp[entry].firstUnder
		after	= temp[entry].afterUnder
		XgrDrawLine (grid, color, first, y2+height, after, y2+height)
	END IF
'
'	IF accentoid THEN
'		x0 = temp[entry-1].break
'		x1 = temp[entry].firstPixel
'		x2 = temp[entry].afterPixel
'		x3 = temp[entry].break
'		IF (entry == 1) THEN x0 = 0
'		IF (x3 > xx2) THEN x3 = xx2
'		xx = (x0 + x1) >> 1
'		XgrDrawBorder (grid, $$BorderRaise1, -1, -1, -1, x0, yy1+1, x3, yy2-1)
'	ELSE
'		x0 = temp[entry-1].break
'		x1 = temp[entry].firstPixel
'		x2 = temp[entry].afterPixel
'		x3 = temp[entry].break
'		IF (entry == 1) THEN x0 = 0
'		IF (x3 > xx2) THEN x3 = xx2
'		xx = (x0 + x1) >> 1
'		XgrDrawBorder (grid, $$BorderFlat1, -1, -1, -1, x0, yy1+1, x3, yy2-1)
'	END IF
END SUB
'
'
' *****  FindEntry  *****
'
SUB FindEntry
	found = 0
	IFZ outside THEN
		upper = UBOUND (temp[])
		FOR entry = 1 TO upper
			check = temp[entry].entry
			IF check THEN
				IF (x < temp[entry].break) THEN
					found = entry
					EXIT FOR
				END IF
			END IF
		NEXT
	END IF
	entry = found
END SUB
'
'
' *****  GetIndentY  *****  In:  height (maxCharHeight - gap + 1)
'
SUB GetIndentY
	XuiGetAlign (grid, #GetAlign, @align, 0, 0, 0, 0, @borderHeight)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	gridHeight	= y2 - y1
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentY = indentTop + borderHeight
		CASE $$AlignUpperCenter		: indentY = indentTop +  borderHeight
		CASE $$AlignUpperRight		: indentY = indentTop + borderHeight
		CASE $$AlignMiddleLeft		: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignMiddleCenter	: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignMiddleRight		: indentY = ((gridHeight - height) >> 1)
		CASE $$AlignLowerLeft			: indentY = ((gridHeight - height) - indentBottom) - 2
		CASE $$AlignLowerCenter		: indentY = ((gridHeight - height) - indentBottom) - 2
		CASE $$AlignLowerRight		: indentY = ((gridHeight - height) - indentBottom) - 2
	END SELECT
	IF (indentY < 0) THEN indentY = 0
	IF (indentY < borderHeight) THEN indentY = borderHeight
END SUB
'
'
' *****  SkipWhitespace  *****
'
SUB SkipWhitespace
	DO WHILE (i < length)
		char = text${i}
		SELECT CASE char
			CASE ' '		:	text${i} = ' '		' leave space a space
			CASE '\t'		: text${i} = ' '		' convert tab to space
			CASE '\r'		: text${i} = ' '		' convert return to space
			CASE '\n'		: text${i} = ' '		' convert newline to space
			CASE ELSE		: EXIT DO
		END SELECT
		INC i
	LOOP
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetTextString]			= 0
'
	DIM sub[upperMessage]
	sub[#Blowback]						= SUBADDRESS (Blowback)
	sub[#Cancel]							= SUBADDRESS (Cancel)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Blowback)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseEnter]					= SUBADDRESS (MouseEnter)
	sub[#MouseExit]						= SUBADDRESS (MouseExit)
	sub[#MouseMove]						= SUBADDRESS (MouseMove)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetFont]							= SUBADDRESS (SetFont)
	sub[#SetFontNumber]				= SUBADDRESS (SetFontNumber)
	sub[#SetTextString]				= SUBADDRESS (SetTextString)
'
	IF func[0] THEN PRINT "XuiMenuBar() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMenuBar() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMenuBar, @"XuiMenuBar", &XuiMenuBar(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiMenuBar
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        12)
	XuiSetGridTypeProperty (gridType, @"minHeight",       12)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleLeft)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##################################
' #####  XuiMenuTextArea1B ()  #####
' ##################################
'
FUNCTION  XuiMenuTextArea1B (grid, message, v0, v1, v2, v3, r0, r1)
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMenuTextArea1B
'
	$XuiMenuTextArea1B  = 0
	$Menu               = 1
	$Text               = 2
	$Button             = 3
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMenuTextArea1B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiMenuTextArea1B, @v0, @v1, @v2, @v3, r0, r1, &XuiMenuTextArea1B())
	DIM text$[8]
	text$[0] = "_File"
  text$[1] = " _Load"
	text$[2] = " _Save"
	text$[3] = " _Quit"
	text$[4] = "_Edit"
	text$[5] = " _Cut"
	text$[6] = " _Grab"
	text$[7] = " _Paste"
	text$[8] = " _Erase"
	XuiMenu        (@g, #Create, 4, 4, 256, 20, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMenuTextArea1B(), -1, -1, $Menu, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Menu")
	XuiSendMessage ( g, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
	XuiTextArea    (@g, #Create, 4, 24, 256, 128, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMenuTextArea1B(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextArea")
	XuiPushButton  (@g, #Create, 4, 152, 256, 20, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" another ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiMenuTextArea1B(), -1, -1, $Button, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMenuTextArea1B")
END SUB
'
'
' *****  Destroyed  *****
'
SUB Destroyed
	XuiCallback (grid, #Destroyed, 0, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, @x1, @y1, @w1, @h1, $Menu, 0)
	XuiSendToKid (grid, #GetSmallestSize, @x2, @y2, @w2, @h2, $Text, 0)
	XuiSendToKid (grid, #GetSmallestSize, @x3, @y3, @w3, @h3, $Button, 0)
'
	h1 = h1 + 2
	h3 = h3 + 2
	IF (w2 < w1) THEN w2 = w1 ELSE w1 = w2
	IF (w3 < w2) THEN w3 = w2 ELSE w2 = w3 : w1 = w3
'
	v2 = bw + w1 + bw
	v3 = bw + h1 + h2 + h3 + bw
END SUB
'
'
' *****  Resize  *****		Resize window to specified size or larger if necessary
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	IF (v2 < vv2) THEN SWAP v2, vv2
	IF (v3 < vv3) THEN SWAP v3, vv3
'
	w1 = v2 - bw - bw
	w2 = v2 - bw - bw
	w3 = v2 - bw - bw
	h2 = v3 - bw - h1 - h3 - bw
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
'
'	*****  Resize Kids  *****
'
	x = bw : y = bw
	XuiSendToKid (grid, #Resize, x, y, w1, h1, $Menu, 0)
'
	x	= bw : y = y + h1
	XuiSendToKid (grid, #Resize, x, y, w2, h2, $Text, 0)
'
	x	= bw : y = y + h2
	XuiSendToKid (grid, #Resize, x, y, w3, h3, $Button, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]					= &XuiCallback()
	func[#MouseDown]				= &XuiMouseDownSetKeyboardFocus()
	func[#Resize]						= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#Destroyed]					= SUBADDRESS (Destroyed)
	sub[#GetSmallestSize]		= SUBADDRESS (GetSmallestSize)
	sub[#Resize]						= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiMenuTextArea1B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMenuTextArea1B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMenuTextArea1B, @"XuiMenuTextArea1B", &XuiMenuTextArea1B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 264
	designHeight = 176
'
	gridType = XuiMenuTextArea1B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        80)
	XuiSetGridTypeProperty (gridType, @"minHeight",       80)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextArray)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextArray",   $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiMessage1B ()  #####  Label and PushButton
' #############################
'
FUNCTION  XuiMessage1B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMessage1B
'
	$Message1B		= 0
	$Label				= 1
	$Button0			= 2
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMessage1B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiMessage1B, @v0, @v1, @v2, @v3, r0, r1, &XuiMessage1B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage1B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMessage1B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
'
	XuiSendToKid (grid, #GetSmallestSize, @labelWidth, @labelHeight, 0, 0, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, @width, @height, 0, 0, $Button0, 8)
	IF (width > buttonWidth) THEN buttonWidth = width
	IF (height > buttonHeight) THEN buttonHeight = height
'
	width = buttonWidth
	height = labelHeight + buttonHeight
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = height + bw + bw
END SUB
'
'
' *****  Resize  *****		This reconfigures window to current text sizes
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	IF (v3 >= (labelHeight + buttonHeight + bw + bw + 4)) THEN buttonHeight = buttonHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - bw - bw
	buttonWidth	= labelWidth
'
	x = bw
	y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, buttonWidth, buttonHeight, $Button0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiMessage1B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMessage1B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMessage1B, @"XuiMessage1B", &XuiMessage1B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 48
'
	gridType = XuiMessage1B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button0)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiMessage2B ()  #####  Label and 2 PushButtons
' #############################
'
FUNCTION  XuiMessage2B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMessage2B
'
	$Message2B		= 0
	$Label				= 1
	$Button0			= 2
	$Button1			= 3
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMessage2B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiMessage2B, @v0, @v1, @v2, @v3, r0, r1, &XuiMessage2B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage2B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage2B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMessage2B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, @labelWidth, @labelHeight, 0, 0, $Label, 8)
	FOR i = $Button0 TO $Button1
		XuiSendToKid (grid, #GetSmallestSize, @width, @height, 0, 0, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth + buttonWidth
	height = labelHeight + buttonHeight
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = height + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	IF (v3 >= (labelHeight + buttonHeight + bw + bw + 4)) THEN buttonHeight = buttonHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - bw - bw
	buttonWidth	= labelWidth >> 1
	width0			= buttonWidth
	width1			= labelWidth - width0
'
	x = bw : y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	h = buttonHeight
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, width0, h, $Button0, 0) : x = x + width0
	XuiSendToKid (grid, #Resize, x, y, width1, h, $Button1, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiMessage2B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMessage2B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMessage2B, @"XuiMessage2B", &XuiMessage2B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 160
	designHeight = 48
'
	gridType = XuiMessage2B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button0)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiMessage3B ()  #####  Label and 3 PushButtons
' #############################
'
FUNCTION  XuiMessage3B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMessage3B
'
	$Message3B		= 0
	$Label				= 1
	$Button0			= 2
	$Button1			= 3
	$Button2			= 4
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMessage3B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiMessage3B, @v0, @v1, @v2, @v3, r0, r1, &XuiMessage3B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage3B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage3B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" option ")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage3B(), -1, -1, $Button2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMessage3B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, @labelWidth, @labelHeight, 0, 0, $Label, 8)
	FOR i = $Button0 TO $Button2
		XuiSendToKid (grid, #GetSmallestSize, @width, @height, 0, 0, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth + buttonWidth + buttonWidth
	height = labelHeight + buttonHeight
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = height + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	v2 = MAX(vv2, v2)
	v3 = MAX(vv3, v3)
'
	width				= buttonWidth + buttonWidth + buttonWidth
	height			= labelHeight + buttonHeight + bw + bw
	IF (width < labelWidth) THEN width = labelWidth
	width				= width + bw + bw
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	IF (v3 >= (labelHeight + buttonHeight + bw + bw + 4)) THEN buttonHeight = buttonHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - bw - bw
	buttonWidth	= labelWidth / 3
	width0			= buttonWidth
	width1			= buttonWidth
	width2			= labelWidth - width0 - width1
'
	x = bw
	y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	h = buttonHeight
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, width0, h, $Button0, 0) : x = x + width0
	XuiSendToKid (grid, #Resize, x, y, width1, h, $Button1, 0) : x = x + width1
	XuiSendToKid (grid, #Resize, x, y, width2, h, $Button2, 0) : x = x + width2
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiMessage3B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMessage3B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMessage3B, @"XuiMessage3B", &XuiMessage3B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 240
	designHeight = 48
'
	gridType = XuiMessage3B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button0)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiMessage4B ()  #####  Label and 4 PushButtons
' #############################
'
FUNCTION  XuiMessage4B (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiMessage4B
'
	$Message4B	= 0  ' kid 0
	$Label			= 1  ' kid 1
	$Button0		= 2  ' kid 2
	$Button1		= 3  ' kid 3
	$Button2		= 4  ' kid 4
	$Button3		= 5  ' kid 5
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiMessage4B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiMessage4B, @v0, @v1, @v2, @v3, r0, r1, &XuiMessage4B())
	XuiLabel       (@g, #Create, 4, 4, 400, 28, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiPushButton  (@g, #Create, 4, 32, 100, 28, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage4B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiPushButton  (@g, #Create, 104, 32, 100, 28, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage4B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" update ")
	XuiPushButton  (@g, #Create, 204, 32, 100, 28, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage4B(), -1, -1, $Button2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" retry ")
	XuiPushButton  (@g, #Create, 304, 32, 100, 28, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiMessage4B(), -1, -1, $Button3, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button3")
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiMessage4B")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, @labelWidth, @labelHeight, 0, 0, $Label, 8)
	FOR i = $Button0 TO $Button3
		XuiSendToKid (grid, #GetSmallestSize, @width, @height, 0, 0, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
	width = buttonWidth << 2
	height = labelHeight + buttonHeight
	IF (width < labelWidth) THEN width = labelWidth
	v2 = width + bw + bw
	v3 = height + bw + bw
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	v2 = MAX (vv2, v2)
	v3 = MAX (vv3, v3)
'
	width				= buttonWidth + buttonWidth + buttonWidth
	height			= labelHeight + buttonHeight + bw + bw
	IF (width < labelWidth) THEN width = labelWidth
	width				= width + bw + bw
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	IF (v3 >= (labelHeight + buttonHeight + bw + bw + 4)) THEN buttonHeight = buttonHeight + 4
'
	labelWidth	= v2 - bw - bw
	labelHeight	= v3 - buttonHeight - bw - bw
	buttonWidth	= labelWidth >> 2
	width0			= buttonWidth
	width1			= buttonWidth
	width2			= buttonWidth
	width3			= labelWidth - width0 - width1 - width2
'
	x = bw
	y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	h = buttonHeight
	y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, width0, h, $Button0, 0) : x = x + width0
	XuiSendToKid (grid, #Resize, x, y, width1, h, $Button1, 0) : x = x + width1
	XuiSendToKid (grid, #Resize, x, y, width2, h, $Button2, 0) : x = x + width2
	XuiSendToKid (grid, #Resize, x, y, width3, h, $Button3, 0) : x = x + width3
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]						= &XuiCallback()
	func[#GetSmallestSize]		= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Resize]							= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiMessage4B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiMessage4B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiMessage4B, @"XuiMessage4B", &XuiMessage4B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 320
	designHeight = 48
'
	gridType = XuiMessage4B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Button0)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###############################
' #####  XuiPressButton ()  #####
' ###############################
'
FUNCTION  XuiPressButton (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiPressButton
	STATIC	downGrid
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiPressButton) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiPressButton, @v0, @v1, @v2, @v3, r0, r1, &XuiPressButton())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiPressButton")
END SUB
'
'
' *****  KeyDown  *****  #Selection on $$KeyEnter
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort != -1) THEN
		IF (v2{8,24} = $$KeyEnter) THEN
			XuiCallback (grid, #Selection, v0, v1, v2, v3, 0, grid)
		END IF
	END IF
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF downGrid THEN downGrid = 0 : EXIT SUB
	XuiGetValue (grid, #GetValue, @on, 0, 0, 0, 0, 0)
	IF on THEN EXIT SUB
	XuiCallback (grid, #Selection, 0, 0, v2, v3, 0, grid)
	XuiGetTimer (grid, #GetTimer, @timer, 0, 0, 0, 0, 0)
	IFZ timer THEN EXIT SUB
	XuiStartTimer (grid, #StartTimer, 0, 0, 0, 0, 0, 0)
	XuiSetValue (grid, #SetValue, 1, 0, 0, 0, 0, 0)
	downGrid = grid
END SUB
'
'
' *****  RedrawGrid  *****  executes after func[#RedrawGrid]
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetValues (grid, #GetValues, @x1, @y1, @x2, @y2, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetSize (grid, #GetSize, 0, 0, @w, @h, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	IF (style AND 0x001E) THEN
		direction = style AND 0x001E
		XgrFillTriangle (grid, -1, 0, direction, x1, y1, x2, y2)
	END IF
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  TimeOff  *****
'
SUB TimeOff
	downGrid = 0
	XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  TimeOut  *****
'
SUB TimeOut
	XuiGetValue (grid, #GetValue, @on, 0, 0, 0, 0, 0)
	XuiGetTimer (grid, #GetTimer, @timer, 0, 0, 0, 0, 0)
	callback = $$TRUE
	SELECT CASE on
		CASE 0		: callback = $$FALSE
		CASE 2		: callback = $$FALSE
	END SELECT
	IF callback THEN XuiCallback (grid, #Selection, 0, 0, v2, v3, 0, grid)
	restart = on && timer && downGrid
	on = on + 1
'
	IF restart THEN
		XuiStartTimer (grid, #StartTimer, 0, 0, 0, 0, 0, 0)
		XuiSetValue (grid, #SetValue, on, 0, 0, 0, 0, 0)
	ELSE
		XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, 0)
		downGrid = 0
	END IF
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseExit]						= SUBADDRESS (TimeOff)
	sub[#MouseUp]							= SUBADDRESS (TimeOff)
	sub[#Redraw]							= SUBADDRESS (RedrawGrid)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#TimeOut]							= SUBADDRESS (TimeOut)
'
	IF func[0] THEN PRINT "XuiPressButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiPressButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiPressButton, @"XuiPressButton", &XuiPressButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiPressButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",          4)
	XuiSetGridTypeProperty (gridType, @"minHeight",         4)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleCenter)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderUp",        $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"borderDown",      $$BorderLower1)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiProgress ()  #####
' ############################
'
FUNCTION  XuiProgress (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiProgress
'
	$Progress		= 0
'
	$position		= 0
	$fullScale	= 1
'
	$Style0			= 0		' default
	$Style1			= 1		' display percent text
	$Style2			= 2		' display progress bars
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiProgress) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiProgress, @v0, @v1, 120, 40, r0, r1, &XuiProgress())
	XuiSendMessage ( grid, #SetColorExtra, -1, $$LightGreen, -1, -1, 0, 0)
	XuiSendMessage ( grid, #SetValues, 0, 100, 0, 0, 0, $position)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiProgress")
END SUB
'
'
' ****  Resize  *****
'
SUB Resize
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  SetValue  *****
'
SUB SetValue
	XuiGetValues (grid, #GetValues, @position, @fullScale, 0, 0, 0, 0)
	XuiSetValue (grid, #SetValue, v0, v1, v2, v3, 0, r1)
	GOSUB UpdatePosition
END SUB
'
'
' *****  SetValues  *****
'
SUB SetValues
	XuiGetValues (grid, #GetValues, @position, @fullScale, 0, 0, 0, 0)
	XuiSetValues (grid, #SetValues, v0, v1, v2, v3, 0, r1)
	GOSUB UpdatePosition
END SUB
'
'
' *****  UpdatePosition  *****
'
SUB UpdatePosition
	XuiGetValues (grid, #GetValues, @v0, @v1, 0, 0, 0, 0)
	IF (v0 < 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = fullScale
	IF (v0 > v1) THEN v0 = v1
	XuiSetValues (grid, #SetValues, v0, v1, 0, 0, 0, 0)
	IF ((v0 = position) AND (v1 = fullScale)) THEN EXIT SUB
	IF (v0 > position) THEN
		XgrGetGridPositionAndSize (grid, 0, 0, @w, @h)
		XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
		XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
		XuiGetColorExtra (grid, #GetColorExtra, @dull, @accent, @lowtext, @hightext, 0, 0)
'
		m# = DOUBLE (v0) / DOUBLE (v1)
		w1 = m# * (w-bw-bw)
		IF (w1 < 1) THEN w1 = 1
'
		SELECT CASE style
			CASE 0
				XgrFillBox (grid, accent, bw, bw, bw+w1-1, h-bw-1)
			CASE 1
				XgrFillBox (grid, accent, bw, bw, bw+w1-1, h-bw-1)
				IF ((w-bw-1) >= (bw+w1)) THEN
					XgrFillBox (grid, dull, bw+w1, bw, w-bw-1, h-bw-1)
				END IF
				XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
				percent$ = STRING$(INT(m#*100)) + "%"
				XgrGetTextImageSize (font, @percent$, @textw, @texth, @tw, @th, @tg, @ts)
				XgrMoveTo (grid, (w/2)-(tw/2), (h/2)-(th/2))
				XgrDrawText (grid, lowtext, percent$)
			CASE 2
				wb = 6						' individual box width
				sb = 4						' spacing between boxes
				n = w1 / (wb+sb)	' number of boxes to draw
				FOR i = 1 TO n
					XgrFillBox (grid, accent, bw+((i-1)*(wb+sb)), bw+2, bw+((i-1)*(wb+sb))+wb, h-bw-1-2)
				NEXT i
		END SELECT
	ELSE
		GOSUB RedrawGrid
	END IF
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XgrGetGridPositionAndSize (grid, @vv0, @vv1, @vv2, @vv3)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiGetColorExtra (grid, #GetColorExtra, @dull, @accent, 0, 0, 0, 0)
	XuiGetValues (grid, #GetValues, @position, @fullScale, 0, 0, 0, $position)
	m# = DOUBLE (position) / DOUBLE (fullScale)
	w = vv2 : h = vv3

	w1 = m# * (vv2-bw-bw)
	IF (w1 < 1) THEN w1 = 1
'
	SELECT CASE style
		CASE 0
			XgrFillBox (grid, accent, bw, bw, bw+w1-1, h-bw-1)
		CASE 1
			XgrFillBox (grid, accent, bw, bw, bw+w1-1, h-bw-1)
			IF ((w-bw-1) >= (bw+w1)) THEN
				XgrFillBox (grid, dull, bw+w1, bw, w-bw-1, h-bw-1)
			END IF
			XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
			percent$ = STRING$(INT(m#*100)) + "%"
			XgrGetTextImageSize (font, @percent$, @textw, @texth, @tw, @th, @tg, @ts)
			XgrMoveTo (grid, (w/2)-(tw/2), (h/2)-(th/2))
			XgrDrawText (grid, lowtext, percent$)
		CASE 2
			wb = 6						' individual box width
			sb = 4						' spacing between boxes
			n = w1 / (wb+sb)	' number of boxes to draw
			FOR i = 1 TO n
				XgrFillBox (grid, accent, bw+((i-1)*(wb+sb)), bw+2, bw+((i-1)*(wb+sb))+wb, h-bw-1-2)
			NEXT i
	END SELECT
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
'
' the old code - before multiple styles
'
'	XgrFillBox (grid, $$Grey, bw, bw, vv2-bw-1, vv3-bw-1)
'	XgrFillBox (grid, accent, bw, bw, bw+w-1, vv3-bw-1)
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 2) THEN style = 0
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]		= &XuiGetMaxMinSize()
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetPosition]				= 0
	func[#SetStyle]						= 0
	func[#SetValue]						= 0
	func[#SetValues]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#SetPosition]				  = SUBADDRESS (SetValues)
	sub[#SetValue]						= SUBADDRESS (SetValue)
	sub[#SetValues]						= SUBADDRESS (SetValues)
	sub[#Redraw]							= SUBADDRESS (RedrawGrid)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
'
	IF func[0] THEN PRINT "XuiProgress() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiProgress() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiProgress, @"XuiProgress", &XuiProgress(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 40
'
	gridType = XuiProgress
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        24)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawClearBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiPullDown ()  #####
' ############################
'
FUNCTION  XuiPullDown (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	textArray$[]
	SHARED	UBYTE  charsetTextChar[]
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiPullDown
	STATIC  UBYTE  lCase[]
'
	$XuiPullDown	= 0
	$Text					= 1
'
	$StyleHotKey	= 1			' first underline character is hotkey indicator
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiPullDown) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiPullDown, @v0, @v1, @v2, @v3, r0, r1, &XuiPullDown())
	XuiSendMessage ( grid, #CreateValueArray, 3, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiSendMessage ( grid, #GetColor, @b, @d, @l, @h, 0, 0)
	XuiSendMessage ( grid, #GetColorExtra, @dull, @a, @lt, @ht, 0, 0)
	XuiSendMessage ( grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	dx = borderWidth + indentLeft
	dy = borderWidth + indentTop
	dx2 = dx + borderWidth + indentRight
	dy2 = dy + borderWidth + indentBottom
	XuiArea        (@g, #Create, @v0, @v1, @v2, @v3, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiPullDown(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Area")
	XuiSendMessage ( g, #SetFontNumber, font, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #SetColor, b, d, l, h, 0, 0)
	XuiSendMessage ( g, #SetColorExtra, dull, a, lt, ht, 0, 0)
	XgrSetGridClip ( g, g)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiPullDown")
END SUB
'
'
' *****  Destroy  *****
'
SUB Destroy
	XuiDestroy (grid, #Destroy, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  KeyDown  *****
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	cursorMessage = 0
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyUpArrow
					cursorMessage = #CursorV
					action = #OneLess											' up one line
		CASE $$KeyDownArrow
					cursorMessage = #CursorV
					action = #OneMore											' down one line
	END SELECT
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort = -1) THEN EXIT SUB
	SELECT CASE v2{$$VirtualKey}
		CASE $$KeyEnter
					XuiGetValues (grid, #GetValues, 0, @cursorLine, 0, 0, 0, 0)
					XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, 0)
		CASE $$KeyEscape
					XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, 0)
		CASE ELSE																									' select line???
					IF (style AND $StyleHotKey) THEN										' _hotkey okay
						IF (v2{$$StateContents} = 1) THEN										' ASCII
							key = v2{8,0}
							IF charsetTextChar[key] THEN
								XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
								IF text$[] THEN
									uText = UBOUND(text$[])
									FOR i = 0 TO uText
										under = INSTR (text$[i], "_")
										IF ((under <= 0) OR (under >= LEN(text$[i]))) THEN DO NEXT
										underChar = text$[i]{under}
										IF (lCase[underChar] = lCase[key]) THEN
											XuiSetTextArray (grid, #SetTextArray, 0, 0, 0, 0, 0, @text$[])
											XuiGetValues (grid, #GetValues, 0, @cursorLine, 0, 0, 0, 0)
											IF (i != cursorLine) THEN
												PullDownMessage (grid, #SetTextCursor, 0, @i, 0, 0, 0, 0)
												PullDownMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
											END IF
											XuiCallback (grid, #Selection, i, 0, 0, 0, 0, 0)
											EXIT SUB
										END IF
									NEXT i
									XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
								END IF
							END IF
						END IF
					END IF
	END SELECT
	IF cursorMessage THEN PullDownMessage (grid, cursorMessage, 0, 0, 0, action, 0, action)
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ (state AND mouse) THEN EXIT SUB
	vv0 = v0 : vv1 = v1
'
	IFZ callback THEN
		XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, 0, 0, 0, @bw)
		vv0 = vv0 - bw - indentLeft
		vv1 = vv1 - bw - indentTop
	END IF
'	PRINT "Down: "; vv0; vv1; bw; indentLeft; indentTop; grid; r1; callback
	PullDownMessage (grid, #CursorV, vv0, vv1, 0, #Change, 0, #Change)
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ (state AND mouse) THEN EXIT SUB
	vv0 = v0 : vv1 = v1
'
	IFZ callback THEN
		XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, 0, 0, 0, @bw)
		vv0 = vv0 - bw - indentLeft
		vv1 = vv1 - bw - indentTop
	END IF
'	PRINT "Drag: "; vv0; vv1; bw; indentLeft; indentTop; grid; r1; callback
	PullDownMessage (grid, #CursorV, vv0, vv1, 0, #Change, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	vv0 = v0 : vv1 = v1
'
	IFZ callback THEN
		XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, 0, 0, 0, @bw)
		vv0 = vv0 - bw - indentLeft
		vv1 = vv1 - bw - indentTop
	END IF
'	PRINT "  Up: "; vv0; vv1; bw; indentLeft; indentTop; grid; r1; callback
'
	XuiGetKids (grid, #GetKids, @g, @textGrid, 0, 0, 0, 0)
	XgrGetGridBoxLocal (textGrid, @xUL, @yUL, @xLR, @yLR)
	IF ((vv0 >= xUL) AND (vv0 <= xLR) AND (vv1 >= yUL) AND (vv1 <= yLR)) THEN
		PullDownMessage (grid, #CursorV, vv0, vv1, 0, #Change, 0, #Change)
		XuiGetValues (grid, #GetValues, 0, @cursorLine, 0, 0, 0, 0)
		XuiCallback (grid, #Selection, cursorLine, 0, 0, 0, 0, grid)
	ELSE
		XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, grid)
	END IF
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XgrClearGrid (grid, -1)
	PullDownMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Resize  *****  Resize based on menu list  (v2 can extend width)
'
SUB Resize
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @bw)
	dx = bw + indentLeft
	dy = bw + indentTop
	dx2 = dx + bw + indentRight
	dy2 = dy + bw + indentBottom
'
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	IFZ text$[] THEN
		maxWidth = 4
		totalHeight = 4
	ELSE
		maxWidth = 1
		totalHeight = 0
		uText = UBOUND(text$[])
		FOR i = 0 TO uText
			XgrGetTextImageSize (font, text$[i], 0, 0, @width, @height, 0, 0)
			IF (width > maxWidth) THEN maxWidth = width
			totalHeight = totalHeight + height + 2
		NEXT i
	END IF
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
	width = dx2 + maxWidth
	height = dy2 + totalHeight
	IF (v2 > width) THEN width = v2
	IF (v3 > height) THEN height = v3
	XuiPositionGrid (grid, @v0, @v1, @width, @height)
	XuiSendToKid (grid, #Resize, dx, dy, width-dx2, height-dy2, $Text, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, width, height, 0, 0)
END SUB
'
'
' *****  SendToKid  *****
'
SUB SendToKid
	XuiSendToKid (grid, message, @v0, @v1, @v2, @v3, $Text, @r1)
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	XuiGetValues (grid, #GetValues, @v0, @v1, @v2, @v3, 0, 0)
END SUB
'
'
' *****  PassToPullDownMessage  *****
'
SUB PassToPullDownMessage
	PullDownMessage (grid, message, @v0, @v1, @v2, @v3, r0, @r1)
END SUB
'
'
' *****  SetFont  *****
'
SUB SetFont
	XuiSetFont (grid, #SetFont, v0, v1, v2, v3, r0, r1)
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
	GOSUB Resize
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
END SUB
'
'
' *****  SetFontNumber  *****
'
SUB SetFontNumber
	XuiSetFontNumber (grid, #SetFontNumber, v0, v1, v2, v3, r0, r1)
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
	GOSUB Resize
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
END SUB
'
'
' *****  SetKeyboardFocus  *****
'
SUB SetKeyboardFocus
'	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	DIM lCase[255]
	FOR i = 0 TO 255
		SELECT CASE TRUE
			CASE (i >= 'A') AND (i <= 'Z'):		lCase[i] = i OR 0x20
			CASE ELSE:												lCase[i] = i
		END SELECT
	NEXT i
'
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Destroy]						= 0
	func[#GetSmallestSize]		= &XuiGetMaxMinSize ()
	func[#MouseDown]					= 0
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
	func[#Resize]							= 0
	func[#SetFont]						= 0
	func[#SetFontNumber]			= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#Destroy]							= SUBADDRESS (Destroy)
	sub[#GetTextCursor]				= SUBADDRESS (GetTextCursor)
	sub[#GotKeyboardFocus]		= SUBADDRESS (Redraw)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#LostKeyboardFocus]		= SUBADDRESS (Redraw)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetColor]						= SUBADDRESS (SendToKid)
	sub[#SetColorExtra]				= SUBADDRESS (SendToKid)
	sub[#SetFont]             = SUBADDRESS (SetFont)
	sub[#SetFontNumber]				= SUBADDRESS (SetFontNumber)
	sub[#SetKeyboardFocus]		= SUBADDRESS (SetKeyboardFocus)
	sub[#SetTextCursor]				= SUBADDRESS (PassToPullDownMessage)
'
	IF func[0] THEN PRINT "XuiPullDown() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiPullDown() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiPullDown, @"XuiPullDown", &XuiPullDown(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 80
'
	gridType = XuiPullDown
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        16)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       4)
	XuiSetGridTypeProperty (gridType, @"indentTop",        2)
	XuiSetGridTypeProperty (gridType, @"indentRight",      4)
	XuiSetGridTypeProperty (gridType, @"indentBottom",     2)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiPushButton ()  #####
' ##############################
'
FUNCTION  XuiPushButton (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiPushButton
	STATIC	downGrid
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiPushButton) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiPushButton, @v0, @v1, @v2, @v3, r0, r1, &XuiPushButton())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiPushButton")
END SUB
'
'
' *****  KeyDown  *****  #Selection callback on $$KeyEnter
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort != -1) THEN
		IF (v2{8,24} = $$KeyEnter) THEN
			XuiCallback (grid, #Selection, v0, v1, v2, v3, 0, grid)
		END IF
	END IF
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, 0, @mouse, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	IF (style == 1) THEN
		XuiCallback (grid, #Selection, 0, 0, v2, v3, 0, grid)
		EXIT SUB
	END IF
	XuiGetBorder (grid, #GetBorder, 0, 0, @border, 0, 0, 0)
	XuiSetBorder (grid, #SetBorder, border, -1, -1, 0, 0, 0)
	GOSUB RedrawGrid
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiPushButton(), 0, 0, 0, $$TRUE)
	downGrid = grid
END SUB
'
'
' *****  MouseEnter  *****
'
SUB MouseEnter
	IF (grid != r1) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetState (grid, #GetState, @state, 0, @mouse, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, @border, @up, @down, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
'
	IF (style == 2) THEN
		border = $$BorderRaise1
		IF (grid == downGrid) THEN border = down
		XuiSetBorder (grid, #SetBorder, border, -1, -1, 0, 0, 0)
	ELSE
		IF (grid != downGrid) THEN EXIT SUB
		XuiGetBorder (grid, #GetBorder, 0, 0, @border, 0, 0, 0)
		XuiSetBorder (grid, #SetBorder, border, -1, -1, 0, 0, 0)
	END IF
	GOSUB RedrawGrid
END SUB
'
'
' *****  MouseExit  *****
'
SUB MouseExit
	IF (grid != r1) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetState (grid, #GetState, @state, 0, @mouse, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, @border, @up, @down, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (style == 2) THEN
		XuiGetBorder (grid, #GetBorder, @border, @up, @down, 0, 0, 0)
		XuiSetBorder (grid, #SetBorder, up, up, down, 0, 0, 0)
	ELSE
		IF (grid != downGrid) THEN EXIT SUB
		XuiGetBorder (grid, #GetBorder, 0, @border, 0, 0, 0, 0)
		XuiSetBorder (grid, #SetBorder, border, -1, -1, 0, 0, 0)
	END IF
	GOSUB RedrawGrid
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	IFZ downGrid THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiPushButton(), 0, 0, 0, $$FALSE)
	XuiGetState (grid, #GetState, @state, 0, @mouse, 0, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	XgrGetGridBoxLocal (downGrid, @x1, @y1, @x2, @y2)
	inside = $$TRUE
	SELECT CASE TRUE
		CASE (v0 < x1)	: inside = $$FALSE
		CASE (v0 > x2)	: inside = $$FALSE
		CASE (v1 < y1)	: inside = $$FALSE
		CASE (v1 > y2)	: inside = $$FALSE
	END SELECT
	downGrid = 0
	IFZ inside THEN EXIT SUB
	XuiGetBorder (grid, #GetBorder, 0, @border, 0, 0, 0, 0)
	XuiSetBorder (grid, #SetBorder, border, -1, -1, 0, 0, 0)
	GOSUB RedrawGrid
	XuiCallback (grid, #Selection, 0, 0, v2, v3, 0, grid)
END SUB
'
'
' *****  RedrawGrid  ****
'
SUB RedrawGrid
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XuiCallback (grid, #Redrawn, 0, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	SELECT CASE v0
		CASE 0	: XuiSendMessage (grid, #SetBorder, $$BorderRaise2, $$BorderRaise2, $$BorderLower2, 0, 0, 0)
		CASE 1	: XuiSendMessage (grid, #SetBorder, $$BorderRaise2, $$BorderRaise2, $$BorderLower2, 0, 0, 0)
		CASE 2	: XuiSendMessage (grid, #SetBorder, $$BorderFlat,   $$BorderFlat,   $$BorderLower1, 0, 0, 0)
	END SELECT
	GOSUB RedrawGrid
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#KeyDown]						= SUBADDRESS (KeyDown)
	sub[#MouseDown]					= SUBADDRESS (MouseDown)
	sub[#MouseEnter]				= SUBADDRESS (MouseEnter)
	sub[#MouseExit]					= SUBADDRESS (MouseExit)
	sub[#MouseUp]						= SUBADDRESS (MouseUp)
	sub[#RedrawGrid]				= SUBADDRESS (RedrawGrid)
	sub[#SetStyle]					= SUBADDRESS (SetStyle)
'
	IF func[0] THEN PRINT "XuiPushButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiPushButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiPushButton, @"XuiPushButton", &XuiPushButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiPushButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",         4)
	XuiSetGridTypeProperty (gridType, @"minHeight",        4)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleCenter)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderUp",        $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderDown",      $$BorderLower2)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiRadioBox ()  #####
' ############################
'
FUNCTION  XuiRadioBox (grid, message, v0, v1, v2, v3, r0, r1)
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiRadioBox
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiRadioBox) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiRadioBox, @v0, @v1, @v2, @v3, r0, r1, &XuiRadioBox())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiRadioBox")
END SUB
'
'
' *****  KeyDown  *****
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	state = v2																			' v2 = state
	key = state{8,24}																' virtual key
	IF (state AND $$AltBit) THEN EXIT SUB						' disallow Alt+Enter
	IF (key = $$KeyEnter) THEN GOSUB ButtonOn				' got Enter
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	GOSUB ButtonOn
END SUB
'
'
' *****  SetValue  *****
'
SUB SetValue
	IF r1 THEN EXIT SUB
	GOSUB SetValues
END SUB
'
'
' *****  SetValues  *****
'
SUB SetValues
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IF v0 THEN GOSUB ButtonOn ELSE GOSUB ButtonOff
END SUB
'
'
' *****  ButtonOff  *****
'
SUB ButtonOff
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IFZ value0 THEN EXIT SUB
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 0)
	GOSUB RedrawGrid
	XuiCallback (grid, #Selection, 0, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  ButtonOn  *****
'
SUB ButtonOn
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IF value0 THEN EXIT SUB
	XuiSetValue  (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 0)
	GOSUB ResetOtherRadioBoxes
	GOSUB RedrawGrid
	XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  ResetOtherRadioBoxes  *****  reset grids in same .group
'
SUB ResetOtherRadioBoxes
	XuiGetEnclosingGrid (grid, #GetEnclosingGrid, @gg, 0, 0, 0, 0, 0)
	IF gg THEN XuiGetEnclosedGrids (gg, #GetEnclosedGrids, 0, 0, 0, 0, 0, @kk[])
	XuiGetGroup (grid, #GetGroup, @group, 0, 0, 0, 0, 0)
	IFZ group THEN EXIT SUB
'
	IF kk[] THEN
		FOR i = 0 TO UBOUND(kk[])
			k = kk[i]
			IF (k = grid) THEN DO NEXT
			IF k THEN XuiSendMessage (k, #GetGroup, @check, 0, 0, 0, 0, 0)
			IF (group = check) THEN XuiSendMessage (k, #SetValue, 0, 0, 0, 0, 0, 0)
		NEXT i
	END IF
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	width = x2 - x1 + 1 : height = y2 - y1 + 1
	XuiGetValue (grid, #GetValue, @state, 0, 0, 0, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetColor (grid, #GetColor, @back, @draw, @lo, @hi, 0, 0)
	XuiGetColorExtra (grid, #GetColorExtra, @dull, @acc, @lot, @hit, 0, 0)
	XuiGetAlign (grid, #GetAlign, 0, 0, @inX, @inY, 0, @bw)
	xx = x1 + ((inX - 12) >> 1) + bw - 1 + 6
	yy = y1 + (height >> 1)
	XgrMoveTo (grid, xx, yy)
'
	SELECT CASE style
		CASE 0
			XgrDrawCircle (grid, draw, 6)
			XgrDrawCircle (grid, draw, 5)
			IF state THEN
				XgrDrawCircle (grid, acc, 4)
				XgrDrawCircle (grid, acc, 3)
				XgrDrawCircle (grid, draw, 2)
				XgrDrawCircle (grid, draw, 1)
				XgrDrawCircle (grid, draw, 0)
				XgrDrawLine (grid, draw, xx-1, yy-1, xx+1, yy+1)
				XgrDrawLine (grid, draw, xx-1, yy+1, xx+1, yy-1)
			END IF
		CASE 1
'			DrawArc2 (grid, color, xCenter, yCenter, radius, startTheta, endTheta)	' where theta is 0-359
			DrawArc2 (grid, lo, xx, yy, 6, 135, 315)
			DrawArc2 (grid, lo, xx, yy, 5, 135, 315)
			DrawArc2 (grid, hi, xx, yy, 6, 316, 134)
			DrawArc2 (grid, hi, xx, yy, 5, 316, 134)
			DrawArc2 (grid, back, xx, yy, 4, 0, 359)
			DrawArc2 (grid, back, xx, yy, 3, 0, 359)
			DrawArc2 (grid, back, xx, yy, 2, 0, 359)
			DrawArc2 (grid, back, xx, yy, 1, 0, 359)
			DrawArc2 (grid, back, xx, yy, 0, 0, 359)
			IF state THEN
				DrawArc2 (grid, acc, xx, yy, 4, 0, 359)
				DrawArc2 (grid, acc, xx, yy, 3, 0, 359)
				DrawArc2 (grid, draw, xx, yy, 2, 0, 359)
				DrawArc2 (grid, draw, xx, yy, 1, 0, 359)
				DrawArc2 (grid, draw, xx, yy, 0, 0, 359)
			END IF
	END SELECT
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 1) THEN style = 0
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	GOSUB RedrawGrid
END SUB

'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#SetStyle]						= 0
	func[#SetValue]						= 0
	func[#SetValues]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#SetStyle]						= SUBADDRESS (SetStyle)
	sub[#SetValue]						= SUBADDRESS (SetValue)
	sub[#SetValues]						= SUBADDRESS (SetValues)
'
	IF func[0] THEN PRINT "XuiRadioBox() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiRadioBox() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiRadioBox, @"XuiRadioBox", &XuiRadioBox(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiRadioBox
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"indentLeft",      24)
	XuiSetGridTypeProperty (gridType, @"group",            2)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleLeft)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise1)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ###############################
' #####  XuiRadioButton ()  #####
' ###############################
'
FUNCTION  XuiRadioButton (grid, message, v0, v1, v2, v3, r0, (r1, r1[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiRadioButton
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiRadioButton) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiRadioButton, @v0, @v1, @v2, @v3, r0, r1, &XuiRadioButton())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0 == 0) THEN v0 = designX
	IF (v1 == 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiRadioButton")
END SUB
'
'
' *****  KeyDown  *****
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	IF (v2 AND $$AltBit) THEN EXIT SUB
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort != -1) THEN
		IF (v2{8,24} = $$KeyEnter) THEN GOSUB ButtonOn
	END IF
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	GOSUB ButtonOn
END SUB
'
'
' *****  SetValue  *****
'
SUB SetValue
	IF r1 THEN EXIT SUB
	GOSUB SetValues
END SUB
'
'
' *****  SetValues  *****
'
SUB SetValues
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IF v0 THEN GOSUB ButtonOn ELSE GOSUB ButtonOff
END SUB
'
'
' *****  ButtonOff  *****
'
SUB ButtonOff
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IFZ value0 THEN EXIT SUB
	XuiSetValue (grid, #SetValue, $$FALSE, 0, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, @border, 0, 0, 0, 0)
	XuiSetBorder (grid, #SetBorder, border, -1, -1, -1, 0, 0)
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XuiCallback (grid, #Selection, 0, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  ButtonOn  *****
'
SUB ButtonOn
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IF value0 THEN EXIT SUB
	XuiSetValue (grid, #SetValue, $$TRUE, 0, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, 0, 0, @border, 0, 0, 0)
	XuiSetBorder (grid, #SetBorder, border, -1, -1, -1, 0, 0)
	GOSUB ResetOtherRadioButtons
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XuiCallback (grid, #Selection, -1, 0, 0, 0, 0, grid)
END SUB
'
'
' *****  RedrawGrid  ****
'
SUB RedrawGrid
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  ResetOtherRadioButtons  *****  reset grids in same .group
'
SUB ResetOtherRadioButtons
	XuiGetEnclosingGrid (grid, #GetEnclosingGrid, @gg, 0, 0, 0, 0, 0)
	IF gg THEN XuiGetEnclosedGrids (gg, #GetEnclosedGrids, 0, 0, 0, 0, 0, @kk[])
	XuiGetGroup (grid, #GetGroup, @group, 0, 0, 0, 0, 0)
	IFZ group THEN EXIT SUB
'
	IF kk[] THEN
		FOR i = 0 TO UBOUND(kk[])
			k = kk[i]
			IF (k == grid) THEN DO NEXT
			IF k THEN XuiSendMessage (k, #GetGroup, @check, 0, 0, 0, 0, 0)
			IF (group == check) THEN XuiSendMessage (k, #SetValue, 0, 0, 0, 0, 0, 0)
		NEXT i
	END IF
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#SetValue]						= 0
	func[#SetValues]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#RedrawGrid]					= SUBADDRESS (RedrawGrid)
	sub[#SetValue]						= SUBADDRESS (SetValue)
	sub[#SetValues]						= SUBADDRESS (SetValues)
'
	IF func[0] THEN PRINT "XuiRadioButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiRadioButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiRadioButton, @"XuiRadioButton", &XuiRadioButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiRadioButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        32)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"group",            1)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderUp",        $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderDown",      $$BorderLower2)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' #########################
' #####  XuiRange ()  #####
' #########################
'
FUNCTION  XuiRange (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiRange
'
	$Range			= 0
	$Label			= 1
	$ButtonUp		= 2
	$ButtonDown	= 3
'
	$value			= 0
	$addStep		= 1
	$minimum		= 2
	$maximum		= 3
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiRange) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****  message = Callback : r1 = original message
'
SUB Callback
  message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiRange, @v0, @v1, @v2, @v3, r0, r1, &XuiRange())
	XuiSendMessage ( grid, #CreateValueArray, 3, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #SetValues, 0, 1, 0, 100, 0, 0)
	XuiLabel       (@g, #Create, 0,  0, 48, 24, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiSendMessage ( g, #SetAlign, $$AlignMiddleRight, -1, -1, -1, 0, 0)
	XuiPressButton (@g, #Create, 48, 0, 12, 12, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiRange(), -1, -1, $ButtonUp, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiSendMessage ( g, #SetTimer, 100, 0, 0, 0, 0, 0)
	XuiPressButton (@g, #Create, 48, 12, 12, 12, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiRange(), -1, -1, $ButtonDown, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiSendMessage ( g, #SetTimer, 100, 0, 0, 0, 0, 0)
	XuiSendMessage ( g, #GetRedrawFlags, @r, 0, 0, 0, 0, 0)
	r = r AND NOT $$RedrawTextArray AND NOT $$RedrawTextString
	XuiSendMessage ( grid, #SetRedrawFlags, r, 0, 0, 0, $ButtonUp, 0)
	XuiSendMessage ( grid, #SetRedrawFlags, r, 0, 0, 0, $ButtonDown, 0)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiRange")
END SUB
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @w1, @h1, $Label, 8)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @w2, @h2, $ButtonUp, 4)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @w3, @h3, $ButtonDown, 4)
	big = (h1 + 1) >> 1
	IF (big < w2) THEN big = w2
	IF (big < w3) THEN big = w3
	IF (big < h2) THEN big = h2
	IF (big < h3) THEN big = h3
	w2 = big : w3 = big : h2 = big : h3 = big
	IF (h1 < (h2 + h3)) THEN h1 = h2 + h3
	IF (h1 > (h2 + h3)) THEN
		h1 = (h1 + 1) AND -2
		big = h1 >> 1
		w2 = big : w3 = big : h2 = big : h3 = big
	END IF
	IF (w1 < 16) THEN w1 = 16
	v2 = w1 + w2
	v3 = h1
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetValue (grid, #GetValue, @value, 0, 0, 0, 0, 0)
	value$ = STRING$ (value)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Label, @value$)
	XuiRedraw (grid, #Redraw, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	vv2 = v2
	vv3 = v3
	GOSUB GetSmallestSize
	v2 = MAX (v2, vv2)
	v3 = MAX (v3, vv3)
'
	IF (v2 < ((v3 >> 1) + 16)) THEN v2 = (v3 >> 1) + 16
	IF (v2 < ((v3 >> 1) + w1)) THEN v2 = (v3 >> 1) + w1
'
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	big = v3 >> 1
	w1 = v2 - big
	w2 = big
	w3 = big
	h1 = v3
	h2 = big
	h3 = big
'
	XuiSendToKid (grid, #Resize,  0,  0, w1, h1, $Label, 0)
	XuiSendToKid (grid, #Resize, w1,  0, w2, h2, $ButtonUp, 0)
	XuiSendToKid (grid, #Resize, w1, h2, w3, h3, $ButtonDown, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Selection  *****
'
SUB Selection
	XuiGetValues (grid, #GetValues, 0, @add, 0, 0, 0, 0)
	SELECT CASE r0
		CASE $ButtonUp		: add = ABS(add)
		CASE $ButtonDown	: add = -ABS(add)
	END SELECT
	GOSUB UpdateValue
	XuiSendToKid (grid, #RedrawGrid, 0, 0, 0, 0, $Label, 0)
	XuiCallback (grid, #Selection, value, add, vMin, vMax, 0, 0)
END SUB
'
'
' *****  CheckValues  *****
'
SUB CheckValues
	XuiGetValues (grid, #GetValues, @value, @add, @vMin, @vMax, 0, 0)
	IF (value < vMin) THEN value = vMin
	IF (value > vMax) THEN value = vMax
	XuiSetValues (grid, #SetValues, value, add, vMin, vMax, 0, 0)
END SUB
'
'
' *****  TimeOut  *****
'
SUB TimeOut
	XuiGetValues (grid, #GetValues, 0, @add, 0, 0, 0, 0)
	GOSUB UpdateValue
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $Label, 0)
	XuiCallback (grid, #Selection, value, add, vMin, vMax, 0, 0)
END SUB
'
'
' *****  UpdateValue  *****
'
SUB UpdateValue
	XuiGetValues (grid, #GetValues, @value, 0, @vMin, @vMax, 0, 0)
	value = value + add
	IF (value < vMin) THEN value = vMin
	IF (value > vMax) THEN value = vMax
	XuiSetValues (grid, #SetValues, value, add, vMin, vMax, 0, 0)
	value$ = STRING$ (value)
	XuiSendToKid (grid, #SetTextString, 0, 0, 0, 0, $Label, @value$)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
	func[#Callback]						= 0
	func[#GetSmallestSize]		= 0
	func[#Redraw]							= 0
	func[#Resize]							= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (GetSmallestSize)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#Selection]						= SUBADDRESS (Selection)
	sub[#SetValue]						= SUBADDRESS (CheckValues)
	sub[#SetValues]						= SUBADDRESS (CheckValues)
'
	IF func[0] THEN PRINT "XuiRange() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiRange() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiRange, @"XuiRange", &XuiRange(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiRange
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        24)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureRaise1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiScrollBarH ()  #####
' ##############################
'
FUNCTION  XuiScrollBarH (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiScrollBarH
	STATIC	focusGrid
'
	$msTimeOut	= 10
	$minMouse		= 12
	$maxMouse		= 13
	$buttonSize	= 19
	$lastValue	= 19
'
	widen = 3
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiScrollBarH) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiScrollBarH, @v0, @v1, @v2, @v3, r0, r1, &XuiScrollBarH())
	XuiCreateValueArray (grid, #CreateValueArray, $lastValue, 0, 0, 0, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiScrollBarH")
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	msTimeOut = 60
	XuiGetValue (grid, #GetValue, @time, 0, 0, 0, 0, $msTimeOut)
	IFZ time THEN msTimeOut = 500
	XuiSetValue (grid, #SetValue, msTimeOut, 0, 0, 0, 0, $msTimeOut)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	SELECT CASE TRUE
		CASE (v0 < (zero - widen))
					XuiCallback (grid, #OneLess, 0, lo-zero, hi-zero, upper-zero, 0, 0)
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$TRUE)
					XgrSetGridTimer (grid, msTimeOut)
		CASE (v0 > (upper + widen))
					XuiCallback (grid, #OneMore, 0, lo-zero, hi-zero, upper-zero, 0, 0)
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$TRUE)
					XgrSetGridTimer (grid, msTimeOut)
		CASE (v0 < (lo - widen))
					IF v2{1,24} THEN																	' Button 1
						XuiCallback (grid, #MuchLess, 0, lo-zero, hi-zero, upper-zero, 0, 0)
						XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$TRUE)
						XgrSetGridTimer (grid, msTimeOut)
					ELSE
						XuiSetValue (grid, #SetValue, lo, 0, 0, 0, 0, 8)
						XuiSetValue (grid, #SetValue, v1, 0, 0, 0, 0, 9)
						focusGrid = grid
						GOSUB MouseDrag
					END IF
		CASE (v0 > (hi + widen))
					IF v2{1,24} THEN																	' Button 1
						XuiCallback (grid, #MuchMore, 0, lo-zero, hi-zero, upper-zero, 0, 0)
						XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$TRUE)
						XgrSetGridTimer (grid, msTimeOut)
					ELSE
						XuiSetValue (grid, #SetValue, lo, 0, 0, 0, 0, 8)
						XuiSetValue (grid, #SetValue, v1, 0, 0, 0, 0, 9)
						focusGrid = grid
						GOSUB MouseDrag
					END IF
		CASE ELSE
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$TRUE)
					XuiSetValue (grid, #SetValue, v0, 0, 0, 0, 0, 8)
					XuiSetValue (grid, #SetValue, v1, 0, 0, 0, 0, 9)
					XuiSetValue (grid, #SetValue, v0 - (lo - zero), 0, 0, 0, 0, 12)		' minMouse
					XuiSetValue (grid, #SetValue, v0 + (upper - hi), 0, 0, 0, 0, 13)	' maxMouse
					focusGrid = grid
	END SELECT
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ focusGrid THEN EXIT SUB
'
	IF (r1 = grid) THEN
		vv0 = v0 : vv1 = v1
	ELSE
		XgrConvertLocalToDisplay (r1, v0, v1, @d0, @d1)
		XgrConvertDisplayToLocal (grid, d0, d1, @vv0, @vv1)
	END IF
'
	XuiGetValues (grid, #GetValues, @minMouse, @maxMouse, 0, 0, 0, 12)
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	XuiGetValues (grid, #GetValues, @xOld, @yOld, 0, 0, 0, 8)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	IF (vv0 < minMouse) THEN vv0 = minMouse
	IF (vv0 > maxMouse) THEN vv0 = maxMouse
'
	XuiSetValue (grid, #SetValue, vv0, 0, 0, 0, 0, 8)
	XuiSetValue (grid, #SetValue, vv1, 0, 0, 0, 0, 9)
'
	IF (xOld = vv0) THEN EXIT SUB								' ignore y only motion
'
	olo = lo
	ohi = hi
	delta = vv0 - xOld
	minMove = zero - lo
	maxMove = upper - hi
	IF (delta < 0) THEN
		move = MAX (delta, minMove)
	ELSE
		move = MIN (delta, maxMove)
	END IF
'
	IFZ move THEN EXIT SUB
'
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
'
' erase current slider border
'
	oldlo = lo - widen
	oldhi = hi + widen
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1+2, oldhi, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1+1, oldhi, y2-1)
		CASE 3
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1, oldhi, y2)
	END SELECT
'
	lo = lo + move
	hi = hi + move
	IF (lo < zero) THEN
		diff = zero - lo
		lo = lo + diff
	END IF
	IF (hi > upper) THEN
		diff = upper - hi
		hi = hi + diff
	END IF
'
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
'
' draw new slider border
'
	newlo = lo - widen
	newhi = hi + widen
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+2, newhi, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+1, newhi, y2-1)
		CASE 3
			IF (newlo > buttonSize) THEN
				XgrFillBox (grid, back, x1+buttonSize, y1, newlo, y2)
				FillDottedBox (grid, dull, x1+buttonSize, y1, newlo, y2)
			END IF
			IF (newhi < (x2-buttonSize)) THEN
				XgrFillBox (grid, back, newhi, y1, x2-buttonSize, y2)
				FillDottedBox (grid, dull, newhi, y1, x2-buttonSize, y2)
			END IF
			XgrFillBox (grid, back, newlo, y1, newhi, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1, newhi, y2)
	END SELECT
'
	XuiCallback (grid, #Change, 0, lo-zero, hi-zero, upper-zero, 0, 0)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarH(), 0, 0, 0, $$FALSE)
	focusGrid = 0
	XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $msTimeOut)
	XgrSetGridTimer (grid, 0)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XgrClearGrid (grid, -1)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
'
	newlo = lo - widen
	newhi = hi + widen
'
	SELECT CASE style
		CASE 0
			XgrDrawBorder (grid, $$BorderRidge, back, loColor, hiColor, x1, y1, x2, y2)
			XgrFillBox (grid, back, x1, y1, x1+11, y2)
			XgrFillBox (grid, back, x2-11, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x1+11, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x2-11, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+2, newhi, y2-2)
		CASE 1
			XgrDrawBorder (grid, $$BorderRidge, back, loColor, hiColor, x1, y1, x2, y2)
			XgrFillBox (grid, back, x1, y1, x1+11, y2)
			XgrFillBox (grid, back, x2-11, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x1+11, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x2-11, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+2, newhi, y2-2)
			XgrFillTriangle (grid, draw, 0, $$TriangleLeft, x1+2, y1+2, x1+8, y2-2)
			XgrFillTriangle (grid, draw, 0, $$TriangleRight, x2-8, y1+2, x2-2, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderLower1, back, loColor, hiColor, x1, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, y1+1, x1+buttonSize, y2-1)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x2-buttonSize, y1+1, x2-1, y2-1)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+1, newhi, y2-1)
			XgrFillTriangle (grid, draw, 0, $$TriangleLeft, x1+3, y1+3, x1+buttonSize-2, y2-3)
			XgrFillTriangle (grid, draw, 0, $$TriangleRight, x2-buttonSize+2, y1+3, x2-3, y2-3)
		CASE 3
			FillDottedBox (grid, dull, x1+buttonSize, y1, x2-buttonSize, y2)
			XgrFillBox (grid, back, newlo, y1, newhi, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x1+buttonSize-1, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x2-buttonSize+1, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1, newhi, y2)
			XgrFillTriangle (grid, draw, 0, $$TriangleLeft, x1+2, y1+2, x1+buttonSize-3, y2-2)
			XgrFillTriangle (grid, draw, 0, $$TriangleRight, x2-buttonSize+3, y1+2, x2-2, y2-2)
	END SELECT
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @lowest, @low, @high, @highest, 0, 4)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	SELECT CASE style
		CASE 0, 1
			buttonSize = 12
			zero = buttonSize + widen
			upper = v2 - buttonSize - widen - 1
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
		CASE 2
			buttonSize = ABS(y2-y1) - 1
			zero = buttonSize + widen + 1
			upper = v2 - buttonSize - widen - 2
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
		CASE 3
			buttonSize = ABS(y2-y1) + 1
			zero = buttonSize + widen
			upper = v2 - buttonSize - widen - 1
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
	END SELECT
'
	ComputeLimits (@lo, @hi, zero, upper, lowest, low, high, highest)
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  GetPosition  *****
'
SUB GetPosition
	XuiGetValues (grid, #GetValues, @v0, @v1, @v2, @v3, 0, 0)
END SUB
'
'
' *****  SetPosition  *****
'
SUB SetPosition
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XuiGetValues (grid, #GetValues, @zero, @olo, @ohi, @upper, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	lowest = v0		' lowest line # in document
	low = v1			' lowest line # displayed
	high = v2			' highest line # displayed
	highest = v3	' highest line # in document
'
	oldlo = olo - widen
	oldhi = ohi + widen
'
	XuiSetValues (grid, #SetValues, v0, v1, v2, v3, 0, 4)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
'
' erase current slider border
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1+2, oldhi, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1+1, oldhi, y2-1)
		CASE 3
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, oldlo, y1, oldhi, y2)
	END SELECT
'
	ComputeLimits (@lo, @hi, zero, upper, lowest, low, high, highest)
	newlo = lo - widen
	newhi = hi + widen
'
' draw new slider border
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+2, newhi, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1+1, newhi, y2-1)
		CASE 3
			IF (newlo > buttonSize) THEN
				XgrFillBox (grid, back, x1+buttonSize, y1, newlo, y2)
				FillDottedBox (grid, dull, x1+buttonSize, y1, newlo, y2)
			END IF
			IF (newhi < (x2-buttonSize)) THEN
				XgrFillBox (grid, back, newhi, y1, x2-buttonSize, y2)
				FillDottedBox (grid, dull, newhi, y1, x2-buttonSize, y2)
			END IF
			XgrFillBox (grid, back, newlo, y1, newhi, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, newlo, y1, newhi, y2)
	END SELECT
'
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
'
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
'
	IF (style > 1) THEN XuiSetMaxMinSize (grid, #SetMaxMinSize, -1, 28, 64, -1, 0, 0)
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
'
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
	v0 = style
END SUB
'
'
' *****  TimeOut  *****
'
SUB TimeOut
	XgrGetGridWindow (grid, @window)
	XgrGetMouseInfo (window, @grid, @v0, @v1, @v2, @v3)		' x, y, state, time
	IFZ v2{2,24} THEN EXIT SUB														' buttons 12 not down
	GOSUB MouseDown
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]	= &XuiGetMaxMinSize()
	func[#Redraw]						= 0
	func[#RedrawGrid]				= 0
	func[#Resize]						= 0
	func[#SetStyle]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#GetPosition]				= SUBADDRESS (GetPosition)
	sub[#MouseDown]					= SUBADDRESS (MouseDown)
	sub[#MouseDrag]					= SUBADDRESS (MouseDrag)
	sub[#MouseUp]						= SUBADDRESS (MouseUp)
	sub[#MouseWheel]				= SUBADDRESS (MouseWheel)
	sub[#Redraw]						= SUBADDRESS (Redraw)
	sub[#RedrawGrid]				= SUBADDRESS (Redraw)
	sub[#Resize]						= SUBADDRESS (Resize)
	sub[#SetPosition]				= SUBADDRESS (SetPosition)
	sub[#SetStyle]					= SUBADDRESS (SetStyle)
	sub[#TimeOut]						= SUBADDRESS (TimeOut)
'
	IF func[0] THEN PRINT "XuiScrollBarH() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiScrollBarH() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiScrollBarH, @"XuiScrollBarH", &XuiScrollBarH(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 12
'
	gridType = XuiScrollBarH
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        48)
	XuiSetGridTypeProperty (gridType, @"minHeight",       12)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRidge)
	XuiSetGridTypeProperty (gridType, @"style",            0)
	XuiSetGridTypeProperty (gridType, @"styleMax",         3)
	XuiSetGridTypeProperty (gridType, @"can",             $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiScrollBarV ()  #####
' ##############################
'
FUNCTION  XuiScrollBarV (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiScrollBarV
	STATIC	focusGrid
'
	$msTimeOut	= 10
	$minMouse		= 12
	$maxMouse		= 13
	$buttonSize	= 19
	$lastValue	= 19
'
	widen = 3
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiScrollBarV) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiScrollBarV, @v0, @v1, @v2, @v3, r0, r1, &XuiScrollBarV())
	XuiCreateValueArray (grid, #CreateValueArray, $lastValue, 0, 0, 0, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiScrollBarV")
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	msTimeOut = 60
	XuiGetValue (grid, #GetValue, @time, 0, 0, 0, 0, $msTimeOut)
	IFZ time THEN msTimeOut = 500
	XuiSetValue (grid, #SetValue, msTimeOut, 0, 0, 0, 0, $msTimeOut)
	SELECT CASE TRUE
		CASE (v1 < (zero - widen))
					XuiCallback (grid, #OneLess, 0, lo-zero, hi-zero, upper-zero, 0, 0)
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$TRUE)
					XgrSetGridTimer (grid, msTimeOut)
		CASE (v1 > (upper + widen))
					XuiCallback (grid, #OneMore, 0, lo-zero, hi-zero, upper-zero, 0, 0)
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$TRUE)
					XgrSetGridTimer (grid, msTimeOut)
		CASE (v1 < (lo - widen))
					IF v2{1,24} THEN																	' Button 1
						XuiCallback (grid, #MuchLess, 0, lo-zero, hi-zero, upper-zero, 0, 0)
						XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$TRUE)
						XgrSetGridTimer (grid, msTimeOut)
					ELSE
						XuiSetValue (grid, #SetValue, v0, 0, 0, 0, 0, 8)
						XuiSetValue (grid, #SetValue, lo, 0, 0, 0, 0, 9)
						focusGrid = grid
						GOSUB MouseDrag
					END IF
		CASE (v1 > (hi + widen))
					IF v2{1,24} THEN																	' Button 1
						XuiCallback (grid, #MuchMore, 0, lo-zero, hi-zero, upper-zero, 0, 0)
						XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$TRUE)
						XgrSetGridTimer (grid, msTimeOut)
					ELSE
						XuiSetValue (grid, #SetValue, v0, 0, 0, 0, 0, 8)
						XuiSetValue (grid, #SetValue, lo, 0, 0, 0, 0, 9)
						focusGrid = grid
						GOSUB MouseDrag
					END IF
		CASE ELSE
					XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$TRUE)
					XuiSetValue (grid, #SetValue, v0, 0, 0, 0, 0, 8)
					XuiSetValue (grid, #SetValue, v1, 0, 0, 0, 0, 9)
					XuiSetValue (grid, #SetValue, v1 - (lo - zero), 0, 0, 0, 0, 12)		' minMouse
					XuiSetValue (grid, #SetValue, v1 + (upper - hi), 0, 0, 0, 0, 13)	' maxMouse
					focusGrid = grid
	END SELECT
END SUB
'
'
' *****  MouseDrag  *****
'
SUB MouseDrag
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IFZ focusGrid THEN EXIT SUB
'
	IF (r1 = grid) THEN
		vv0 = v0 : vv1 = v1
	ELSE
		XgrConvertLocalToDisplay (r1, v0, v1, @d0, @d1)
		XgrConvertDisplayToLocal (grid, d0, d1, @vv0, @vv1)
	END IF
'
	XuiGetValues (grid, #GetValues, @minMouse, @maxMouse, 0, 0, 0, 12)
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	XuiGetValues (grid, #GetValues, @xOld, @yOld, 0, 0, 0, 8)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	IF (vv1 < minMouse) THEN vv1 = minMouse
	IF (vv1 > maxMouse) THEN vv1 = maxMouse
'
	XuiSetValue (grid, #SetValue, vv0, 0, 0, 0, 0, 8)
	XuiSetValue (grid, #SetValue, vv1, 0, 0, 0, 0, 9)
'
	IF (yOld = vv1) THEN EXIT SUB								' ignore x only motion
'
	olo = lo
	ohi = hi
	delta = vv1 - yOld
	minMove = zero - lo
	maxMove = upper - hi
	IF (delta < 0) THEN
		move = MAX (delta, minMove)
	ELSE
		move = MIN (delta, maxMove)
	END IF
'
	IFZ move THEN EXIT SUB
'
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
'
' erase current slider border
'
	oldlo = lo - widen
	oldhi = hi + widen
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1+2, oldlo, x2-2, oldhi)
		CASE 2
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1+1, oldlo, x2-1, oldhi)
		CASE 3
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1, oldlo, x2, oldhi)
	END SELECT
'
	lo = lo + move
	hi = hi + move
	IF (lo < zero) THEN
		diff = zero - lo
		lo = lo + diff
	END IF
	IF (hi > upper) THEN
		diff = upper - hi
		hi = hi + diff
	END IF
'
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
'
' draw new slider border
'
	newlo = lo - widen
	newhi = hi + widen
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+2, newlo, x2-2, newhi)
		CASE 2
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, newlo, x2-1, newhi)
		CASE 3
			IF (newlo > buttonSize) THEN
				XgrFillBox (grid, back, x1, y1+buttonSize, x2, newlo)
				FillDottedBox (grid, dull, x1, y1+buttonSize, x2, newlo)
			END IF
			IF (newhi < (y2-buttonSize)) THEN
				XgrFillBox (grid, back, x1, newhi, x2, y2-buttonSize)
				FillDottedBox (grid, dull, x1, newhi, x2, y2-buttonSize)
			END IF
			XgrFillBox (grid, back, x1, newlo, x2, newhi)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, newlo, x2, newhi)
	END SELECT
'
	XuiCallback (grid, #Change, 0, lo-zero, hi-zero, upper-zero, 0, 0)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiScrollBarV(), 0, 0, 0, $$FALSE)
	focusGrid = 0
	XuiSetValue (grid, #SetValue, 0, 0, 0, 0, 0, $msTimeOut)
	XgrSetGridTimer (grid, 0)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XgrClearGrid (grid, -1)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
	XuiGetValues (grid, #GetValues, @zero, @lo, @hi, @upper, 0, 0)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
'
	newlo = lo - widen
	newhi = hi + widen
'
	SELECT CASE style
		CASE 0
			XgrDrawBorder (grid, $$BorderRidge, back, loColor, hiColor, x1, y1, x2, y2)
			XgrFillBox (grid, back, x1, y1, x2, y1+11)
			XgrFillBox (grid, back, x1, y2-11, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x2, y1+11)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y2-11, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+2, newlo, x2-2, newhi)
		CASE 1
			XgrDrawBorder (grid, $$BorderRidge, back, loColor, hiColor, x1, y1, x2, y2)
			XgrFillBox (grid, back, x1, y1, x2, y1+11)
			XgrFillBox (grid, back, x1, y2-11, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x2, y1+11)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y2-11, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+2, newlo, x2-2, newhi)
			XgrFillTriangle (grid, draw, 0, $$TriangleUp, x1+2, y1+2, x2-2, y1+8)
			XgrFillTriangle (grid, draw, 0, $$TriangleDown, x1+2, y2-8, x2-2, y2-2)
		CASE 2
			XgrDrawBorder (grid, $$BorderLower1, back, loColor, hiColor, x1, y1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, y1+1, x2-1, y1+buttonSize)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, y2-buttonSize, x2-1, y2-1)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, newlo, x2-1, newhi)
			XgrFillTriangle (grid, draw, 0, $$TriangleUp, x1+3, y1+3, x2-3, y1+buttonSize-2)
			XgrFillTriangle (grid, draw, 0, $$TriangleDown, x1+3, y2-buttonSize+2, x2-3, y2-3)
		CASE 3
			FillDottedBox (grid, dull, x1, y1+buttonSize, x2, y2-buttonSize)
			XgrFillBox (grid, back, x1, newlo, x2, newhi)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y1, x2, y1+buttonSize-1)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, y2-buttonSize+1, x2, y2)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, newlo, x2, newhi)
			XgrFillTriangle (grid, draw, 0, $$TriangleUp, x1+2, y1+2, x2-2, y1+buttonSize-3)
			XgrFillTriangle (grid, draw, 0, $$TriangleDown, x1+2, y2-buttonSize+3, x2-2, y2-2)
	END SELECT
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetValues (grid, #GetValues, @lowest, @low, @high, @highest, 0, 4)
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
'
	SELECT CASE style
		CASE 0, 1
			buttonSize = 12
			zero = buttonSize + widen
			upper = v3 - buttonSize - widen - 1
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
		CASE 2
			buttonSize = ABS(x2-x1) - 1
			zero = buttonSize + widen + 1
			upper = v3 - buttonSize - widen - 2
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
		CASE 3
			buttonSize = ABS(x2-x1) + 1
			zero = buttonSize + widen
			upper = v3 - buttonSize - widen - 1
			XuiSetValue (grid, #SetValue, buttonSize, 0, 0, 0, 0, $buttonSize)
	END SELECT
'
	ComputeLimits (@lo, @hi, zero, upper, lowest, low, high, highest)
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  GetPosition  *****
'
SUB GetPosition
	XuiGetValues (grid, #GetValues, @v0, @v1, @v2, @v3, 0, 0)
END SUB
'
'
' *****  SetPosition  *****
'
SUB SetPosition
	XuiGetValue (grid, #GetValue, @buttonSize, 0, 0, 0, 0, $buttonSize)
	XuiGetValues (grid, #GetValues, @zero, @olo, @ohi, @upper, 0, 0)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
'
	lowest = v0		' lowest line # in document
	low = v1			' lowest line # displayed
	high = v2			' highest line # displayed
	highest = v3	' highest line # in document
'
	oldlo = olo - widen
	oldhi = ohi + widen
'
	XuiSetValues (grid, #SetValues, v0, v1, v2, v3, 0, 4)
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	XgrGetGridColors (grid, @back, @draw, @loColor, @hiColor, @dull, @accent, 0, 0)
'
' erase current slider border
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1+2, oldlo, x2-2, oldhi)
		CASE 2
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1+1, oldlo, x2-1, oldhi)
		CASE 3
			XgrDrawBorder (grid, $$BorderFlat, back, loColor, hiColor, x1, oldlo, x2, oldhi)
	END SELECT
'
	ComputeLimits (@lo, @hi, zero, upper, lowest, low, high, highest)
	newlo = lo - widen
	newhi = hi + widen
'
' draw new slider border
'
	SELECT CASE style
		CASE 0, 1
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+2, newlo, x2-2, newhi)
		CASE 2
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1+1, newlo, x2-1, newhi)
		CASE 3
			IF (newlo > buttonSize) THEN
				XgrFillBox (grid, back, x1, y1+buttonSize, x2, newlo)
				FillDottedBox (grid, dull, x1, y1+buttonSize, x2, newlo)
			END IF
			IF (newhi < (y2-buttonSize)) THEN
				XgrFillBox (grid, back, x1, newhi, x2, y2-buttonSize)
				FillDottedBox (grid, dull, x1, newhi, x2, y2-buttonSize)
			END IF
			XgrFillBox (grid, back, x1+1, newlo+1, x2-1, newhi-1)
			XgrDrawBorder (grid, $$BorderRaise1, back, loColor, hiColor, x1, newlo, x2, newhi)
	END SELECT
'
	XuiSetValues (grid, #SetValues, zero, lo, hi, upper, 0, 0)
END SUB
'
'
' *****  SetStyle  *****
'
SUB SetStyle
	vv0 = v0 : vv1 = v1 : vv2 = v2 : vv3 = v3
'
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
'
	IF (style > 1) THEN XuiSetMaxMinSize (grid, #SetMaxMinSize, 28, -1, -1, 64, 0, 0)
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
'
	v0 = vv0 : v1 = vv1 : v2 = vv2 : v3 = vv3
	v0 = style
END SUB
'
'
' *****  TimeOut  *****
'
SUB TimeOut
	XgrGetGridWindow (grid, @window)
	XgrGetMouseInfo (window, @grid, @v0, @v1, @v2, @v3)		' x, y, state, time
	IFZ v2{2,24} THEN EXIT SUB														' buttons 12 not down
	GOSUB MouseDown
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]	= &XuiGetMaxMinSize()
	func[#Redraw]						= 0
	func[#RedrawGrid]				= 0
	func[#Resize]						= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#GetPosition]				= SUBADDRESS (GetPosition)
	sub[#MouseDown]					= SUBADDRESS (MouseDown)
	sub[#MouseDrag]					= SUBADDRESS (MouseDrag)
	sub[#MouseUp]						= SUBADDRESS (MouseUp)
	sub[#MouseWheel]				= SUBADDRESS (MouseWheel)
	sub[#Redraw]						= SUBADDRESS (Redraw)
	sub[#RedrawGrid]				= SUBADDRESS (Redraw)
	sub[#Resize]						= SUBADDRESS (Resize)
	sub[#SetPosition]				= SUBADDRESS (SetPosition)
	sub[#SetStyle]					= SUBADDRESS (SetStyle)
	sub[#TimeOut]						= SUBADDRESS (TimeOut)
'
	IF func[0] THEN PRINT "ScrollBarV() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "ScrollBarV() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiScrollBarV, @"XuiScrollBarV", &XuiScrollBarV(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 12
	designHeight = 80
'
	gridType = XuiScrollBarV
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        12)
	XuiSetGridTypeProperty (gridType, @"minHeight",       48)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRidge)
'	XuiSetGridTypeProperty (gridType, @"style",            3)
	XuiSetGridTypeProperty (gridType, @"styleMax",         3)
	XuiSetGridTypeProperty (gridType, @"can",             $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiSolidColor ()  #####
' ##############################
'
FUNCTION  XuiSolidColor (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR		sub[]
	STATIC	upperMessage
	STATIC	XuiSolidColor
	STATIC  color[]
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiSolidColor) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiSolidColor, @v0, @v1, @v2, @v3, r0, r1, &XuiSolidColor())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiSolidColor")
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
	top = y1
	left = x1
	right = x2
	bottom = y2
	IF (v1 < top) THEN EXIT SUB
	IF (v0 < left) THEN EXIT SUB
	IF (v0 > right) THEN EXIT SUB
	IF (v1 > bottom) THEN EXIT SUB
	row = (v1 - top) \ 20
	col = (v0 - left) \ 10
	color = row * 4 + col
	color = color[color]
	XgrConvertColorToRGB (color, @red, @green, @blue)
	XuiCallback (grid, #Selection, color, red, green, blue, color, grid)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
'
	xdiam = 10
	ydiam = 20
	FOR x = 0 TO 3
		FOR y = 0 TO 3
			n = (y * 4) + x
			c = color[n]
			x1 = x * xdiam
			y1 = y * ydiam
			x2 = x1 + xdiam - 1
			y2 = y1 + ydiam - 1
			XgrFillBox (grid, c, x1, y1, x2, y2)
		NEXT y
	NEXT x
	FOR x = 0 TO 4
		x1 = x * xdiam - 1
		y1 = 0
		x2 = x * xdiam - 1
		y2 = 4 * ydiam - 1
		XgrDrawLine (grid, $$Black, x1, y1, x2, y2)
	NEXT x
	FOR y = 0 TO 4
		x1 = 0
		y1 = y * ydiam - 1
		x2 = 4 * xdiam - 1
		y2 = y * ydiam - 1
		XgrDrawLine (grid, $$Black, x1, y1, x2, y2)
	NEXT y
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	DIM color[15]
	color[ 0] = $$Black
	color[ 1] = $$Grey
	color[ 2] = $$BrightGrey
	color[ 3] = $$White
	color[ 4] = $$LightRed
	color[ 5] = $$LightGreen
	color[ 6] = $$LightCyan
	color[ 7] = $$LightYellow
	color[ 8] = $$Green
	color[ 9] = $$Brown
	color[10] = $$Cyan
	color[11] = $$LightMagenta
	color[12] = $$Red
	color[13] = $$Magenta
	color[14] = $$Blue
	color[15] = $$LightBlue
'
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]		= &XuiGetMaxMinSize ()
	func[#Redraw]							= 0
	func[#RedrawGrid]					= 0
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
'
	IF func[0] THEN PRINT "XuiSolidColor() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiSolidColor() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiSolidColor, @"XuiSolidColor", &XuiSolidColor(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 40
	designHeight = 80
'
	gridType = XuiSolidColor
	XuiSetGridTypeProperty (gridType, @"x",              designX)
	XuiSetGridTypeProperty (gridType, @"y",              designY)
	XuiSetGridTypeProperty (gridType, @"width",          designWidth)
	XuiSetGridTypeProperty (gridType, @"height",         designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"minHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"maxWidth",       designWidth)
	XuiSetGridTypeProperty (gridType, @"maxHeight",      designHeight)
	XuiSetGridTypeProperty (gridType, @"can",            $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",    $$RedrawNone)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ########################
' #####  XuiText ()  #####
' ########################
'
FUNCTION  XuiText (grid, message, v0, v1, v2, v3, r0, r1)
  STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiText
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiText) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiText, @v0, @v1, @v2, @v3, r0, r1, &XuiText())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiText")
END SUB
'
'
' *****  Mouse  *****
'
SUB Mouse
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	IF (v2{$$ButtonNumber} = $$HelpButtonNumber) THEN EXIT SUB
	XuiCallback (grid, message, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	DIM sub[upperMessage]
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#MouseDown]						= SUBADDRESS (Mouse)
	sub[#MouseDrag]						= SUBADDRESS (Mouse)
	sub[#MouseEnter]					= SUBADDRESS (Mouse)
	sub[#MouseExit]						= SUBADDRESS (Mouse)
	sub[#MouseMove]						= SUBADDRESS (Mouse)
	sub[#MouseUp]							= SUBADDRESS (Mouse)
'
	IF func[0] THEN PRINT "XuiText() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiText() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiText, @"XuiText", &XuiText(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 32
	designHeight = 32
'
	gridType = XuiText
	XuiSetGridTypeProperty (gridType, @"x",           designX)
	XuiSetGridTypeProperty (gridType, @"y",           designY)
	XuiSetGridTypeProperty (gridType, @"width",       designWidth)
	XuiSetGridTypeProperty (gridType, @"height",      designHeight)
	XuiSetGridTypeProperty (gridType, @"dullColor",   $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"can",         $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags", $$RedrawDefaultNoFocus)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiTextArea ()  #####
' ############################
'
FUNCTION  XuiTextArea (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	UBYTE  charsetTextChar[]
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiTextArea
	STATIC  downGrid
	UBYTE  null[]
'
	$TextArea			=  0
	$Text					=  1
	$ScrollH			=  2
	$ScrollV			=  3
'
	$TextGrid			=  0								' values[grid,] index
	$cursorShown	= 10
'
'	IF ((message = #LostTextSelection) OR (message = #SetTextSelection) OR (message = #SetTextCursor) OR (message = #RedrawText)) THEN
'		XgrMessageNumberToName (message, @message$)
'		XstLog ("XuiTextArea() : " + STRING$(grid) + " " + message$ + STR$(v0) + STR$(v1) + STR$(v2) + STR$(v3))
'	END IF
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiTextArea) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiTextArea, @v0, @v1, @v2, @v3, r0, r1, &XuiTextArea())
	XuiSendMessage ( grid, #CreateValueArray, 31, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiSendMessage ( grid, #GetColorExtra, @dull, @acc, @lowtext, @hightext, 0, 0)
'
	dx = borderWidth + indentLeft
	dy = borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	XuiArea        (@g, #Create, dx, dy, v2-dx2-13, v3-dy2-13, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Text")
	XuiSendMessage ( g, #SetColorExtra, dull, acc, lowtext, hightext, 0, 0)
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
'
	XuiSetValue    ( grid, #SetValue, g, 0, 0, 0, 0, $TextGrid)
	TextMessage    ( grid, #SetValues, 0, 0, 0, 0, 0, 0)
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - 12
	h		= 12
	x		= dx
	y		= v3 - dy - h
	XuiScrollBarH  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea(), -1, -1, $ScrollH, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollH")
'
	w		= 12
	h		= v3 - dy2 - 12
	x		= v2 - dx - w
	y		= dy
	XuiScrollBarV  (@g, #Create, x, y, w, h, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea(), -1, -1, $ScrollV, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"ScrollV")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiTextArea")
END SUB
'
'
' *****  GetSmallestSize  *****  v0 = # columns, v1 = # rows
'
SUB GetSmallestSize
	XuiGetMaxMinSize (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiGetAlign (grid, #GetAlign, @align, @justify, 0, 0, $Text, 0)
	border = borderWidth + borderWidth
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, $Text, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, $Text, @gap)
	textWidth = maxCharWidth * MAX (v0, 1)
	textHeight = maxCharHeight * MAX (v1, 1)
	scrollWidth = 12
	scrollHeight = 12
	SELECT CASE align
		CASE $$AlignUpperLeft			: indentX = indentLeft + 2						: indentY = indentTop + 2
		CASE $$AlignUpperCenter		: indentX = indentLeft + indentRight	: indentY = indentTop + 2
		CASE $$AlignUpperRight		: indentX = indentRight + 2						: indentY = indentTop + 2
		CASE $$AlignMiddleLeft		: indentX = indentLeft + 2						: indentY = indentTop + indentBottom
		CASE $$AlignMiddleCenter	: indentX = indentLeft + indentRight	: indentY = indentTop + indentBottom
		CASE $$AlignMiddleRight		: indentX = indentRight + 2						: indentY = indentTop + indentBottom
		CASE $$AlignLowerLeft			: indentX = indentLeft + 2						: indentY = indentBottom + 2
		CASE $$AlignLowerCenter		: indentX = indentLeft + indentRight	: indentY = indentBottom + 2
		CASE $$AlignLowerRight		: indentX = indentRight + 2						: indentY = indentBottom + 2
	END SELECT
	width = textWidth + scrollWidth + border + indentX
	height = textHeight + scrollHeight + border + indentY
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
	v2 = width : v3 = height
END SUB
'
'
' *****  GotKeyboardFocus  *****
'
SUB GotKeyboardFocus
'	PRINT "XuiTextArea() : GotKeyboardFocus"
	TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	XuiGotKeyboardFocus (grid, #GotKeyboardFocus, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  KeyDown  *****
'		ctrl	= MORE of the same
'		shift	= extend selection
'			CursorH:
'				OneLess:		left one char			$$KeyLeftArrow
'				SomeLess:		left one word			$$KeyLeftArrow  ^
'				OneMore:		right one char		$$KeyRightArrow
'				SomeMore:		right one word		$$KeyRightArrow  ^
'				Minimum:		beg line					$$KeyHome
'				Maximum:		end line					$$KeyEnd
'			CursorV:
'				OneLess:		up one line				$$KeyUpArrow
'				SomeLess:		up half page			$$KeyUpArrow  ^
'				OneMore:		down one line			$$KeyDownArrow
'				SomeMore:		down half page		$$KeyDownArrow
'				Minimum:		beg Text					$$KeyHome  ^
'				Maximum:		end Text					$$KeyEnd  ^
'			ScrollV:
'				SomeMore:		down half page		$$KeyPageDown
'				MuchMore:		down one page			$$KeyPageDown  ^
'				SomeLess:		up half page			$$KeyPageUp
'				MuchLess:		up one page				$$KeyPageUp  ^
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
'
	state = v2																			' v2 = state
	key = state{8,0}
	ctrl = (state AND $$CtrlBit)
	shift = (state AND $$ShiftBit)
	contents = state{$$StateContents}
	virtualKey = state{$$VirtualKey}
'
	IF (contents = 1) THEN													' ASCII
		IF charsetTextChar[key] THEN
			shiftEnter = ((virtualKey = $$KeyEnter) && (state AND $$ShiftBit))
			IFZ shiftEnter THEN
				abort = 0
				XuiCallback (grid, #TextEvent, v0, v1, state, v3, @abort, grid)
				IF (abort = -1) THEN RETURN
				TextMessage (grid, #TextInsert, 0, 0, 0, key, 0, 0)
				EXIT SUB
			END IF
		END IF
	END IF
'
	selectAction = $$SelectCancel
	IF shift THEN selectAction = $$SelectDrag
'
	XgrGetTextSelectionGrid (@tsg)
	IF ctrl THEN
		SELECT CASE virtualKey
			CASE $$KeyX	: IF (grid = tsg) THEN						' ^X = cut
											virtualKey = $$KeyDelete
											ctrl = 0
										END IF
			CASE $$KeyC	: IF (grid = tsg) THEN						' ^C = grab/copy
											virtualKey = $$KeyInsert
										END IF
			CASE $$KeyV	: virtualKey = $$KeyInsert				' ^V = paste/insert
										ctrl = 0
		END SELECT
	END IF
'
	cursorMessage = 0
	SELECT CASE virtualKey
		CASE $$KeyBackspace, $$KeyDelete
					cursorMessage = #TextDelete
					action = virtualKey
		CASE $$KeyInsert
		CASE $$KeyLeftArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeLess
					ELSE
						action = #OneLess
					END IF
		CASE $$KeyRightArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeMore
					ELSE
						action = #OneMore
					END IF
		CASE $$KeyUpArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeLess											' beginning of page
					ELSE
						action = #OneLess											' up one line
					END IF
		CASE $$KeyDownArrow
					cursorMessage = #CursorV
					IF ctrl THEN
						action = #SomeMore											' end of page
					ELSE
						action = #OneMore											' down one line
					END IF
		CASE $$KeyHome
					action = #Minimum
					IF ctrl THEN
						cursorMessage = #CursorV								' beginning of text
					ELSE
						cursorMessage = #CursorH								' beginning of line
					END IF
		CASE $$KeyEnd
					action = #Maximum
					IF ctrl THEN
						cursorMessage = #CursorV								' end of text
					ELSE
						cursorMessage = #CursorH								' end of line
					END IF
		CASE $$KeyPageDown
					cursorMessage = #ScrollV
					IF ctrl THEN
						action = #MuchMore											' down one page
					ELSE
						action = #SomeMore											' down half page
					END IF
		CASE $$KeyPageUp
					cursorMessage = #ScrollV
					IF ctrl THEN
						action = #MuchLess											' up one page
					ELSE
						action = #SomeLess											' up half page
					END IF
	END SELECT
'
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, state, v3, @abort, grid)
	IF (abort = -1) THEN RETURN
	SELECT CASE virtualKey
		CASE $$KeyEnter
					IF (state AND $$ShiftBit) THEN
						XuiCallback (grid, #Selection, state, 0, 0, 0, 0, 0)
						EXIT SUB
					END IF
		CASE $$KeyEscape
					XuiCallback (grid, #Selection, state, 0, 0, 0, 0, 0)
					EXIT SUB
	END SELECT
'
	IF cursorMessage THEN
		IF shift THEN
			XgrGetTextSelectionGrid (@tsg)
			IF (grid != tsg) THEN
				XgrSetTextSelectionGrid (grid)
				TextMessage (grid, #GetTextCursor, @cx, @cy, 0, 0, 0, 0)
				TextMessage (grid, #SetTextSelection, cx, cy, cx, cy, 0, 0)
			END IF
		END IF
		TextMessage (grid, cursorMessage, 0, 0, selectAction, action, 0, action)
	ELSE
		IF (virtualKey = $$KeyInsert) THEN
			XgrGetTextSelectionGrid (@focusGrid)
			IF ctrl THEN																		' grab into buffer 0
				IF (grid = focusGrid) THEN
					TextMessage (grid, #GetTextSelection, @begPos, @begLine, 0, 0, 0, @text$)
					IF text$ THEN
						XgrSetClipboard (0, $$ClipboardTypeText, @text$, @null[])
						TextMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
					END IF
				END IF
			ELSE																						' insert
				IF (grid = focusGrid) THEN
					TextMessage (grid, #GetTextSelection, @begPos, @begLine, @endPos, @endLine, 0, @select$)
				ELSE
					TextMessage (grid, #GetTextCursor, @begPos, @begLine, 0, 0, 0, 0)
					endLine = begLine : endPos = begPos
				END IF
				XgrGetClipboard (0, $$ClipboardTypeText, @text$, @null[])
				IF text$ THEN
					TextMessage (grid, #TextReplace, begPos, begLine, endPos, endLine, 0, @text$)
					TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
				END IF
			END IF
		END IF
	END IF
END SUB
'
'
' *****  LostKeyboardFocus  *****
'
SUB LostKeyboardFocus
'	PRINT "XuiTextArea() : LostKeyboardFocus"
	TextMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  LostTextSelection  *****
'
SUB LostTextSelection
	TextMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
END SUB
'
'
' *****  MouseDown  *****
'		v0 = x
'		v1 = y
'		v2 = state
'		shift = extend selection
'		v01 low bit clipped to avoid jiggle effects
'
SUB MouseDown
	IFZ callback THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
'
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	downGrid = grid
'
	IF (v2 AND $$ShiftBit) THEN
		TextMessage (grid, #CursorH, v0, v1, $$SelectExtend, 0, 0, #Change)
		EXIT SUB
	END IF
	TextMessage (grid, #CursorH, v0, v1, $$SelectSet, 0, 0, #Change)
'
	clicks = v2{3,4}
	SELECT CASE clicks
		CASE 2																					' select word
			TextMessage (grid, #GetTextCursor, @cursorPos, @cursorLine, 0, 0, 0, 0)
			XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$[] THEN EXIT SELECT
			text$ = text$[cursorLine]
			XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$ THEN EXIT SELECT
			foundWord = $$FALSE
			SELECT CASE text${cursorPos}
				CASE 0, ' ', '\t', '\n'
				CASE ELSE:
					foundWord = $$TRUE
					endPos = INCHR (text$, " \t\n", cursorPos + 1)
					IFZ endPos THEN
						endPos = LEN (text$)
					ELSE
						DEC endPos
					END IF
					begPos = 0
					IF cursorPos THEN
						begPos = RINCHR (text$, " \t\n", cursorPos)
					END IF
			END SELECT
			IFF foundWord THEN
				IF cursorPos THEN
					SELECT CASE text${cursorPos - 1}
						CASE 0, ' ', '\t', '\n'
						CASE ELSE:
							foundWord = $$TRUE
							endPos = cursorPos
							begPos = 0
							begPos = RINCHR (text$, " \t\n", cursorPos)
					END SELECT
				END IF
			END IF
			IF foundWord THEN
				XgrSetTextSelectionGrid (grid)
				TextMessage (grid, #SetTextSelection, begPos, cursorLine, endPos, cursorLine, 0, 0)
				TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
			END IF
		CASE 3																					' select entire line w \n
			XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$[] THEN EXIT SELECT
			uText = UBOUND(text$[])
			XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
			TextMessage (grid, #GetTextCursor, 0, @cursorLine, 0, 0, 0, 0)
			endLine = cursorLine + 1
			IF (endLine > uText) THEN endLine = uText
			XgrSetTextSelectionGrid (grid)
			TextMessage (grid, #SetTextSelection, 0, cursorLine, 0, endLine, 0, 0)
			TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
		CASE 4																				' select entire text
			XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
			IFZ text$[] THEN EXIT SELECT
			uText = UBOUND(text$[])
			endPos = LEN(text$[uText])
			XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
			XgrSetTextSelectionGrid (grid)
			TextMessage (grid, #SetTextSelection, 0, 0, endPos, uText, 0, 0)
			TextMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  MouseDrag  *****  v01 low bit clipped to avoid jiggle effects
'
SUB MouseDrag
	IFZ callback THEN EXIT SUB
	IF (grid != downGrid) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
'
	v0 = v0 AND -2 : v1 = v1 AND -2
	XgrSetTextSelectionGrid (grid)
	TextMessage (grid, #CursorH, v0, v1, $$SelectDrag, 0, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	downGrid = 0
'	XuiMonitorMouse (grid, #MonitorMouse, grid, &XuiTextArea(), 0, 0, 0, $$FALSE)
END SUB
'
'
' *****  MouseWheel  *****
'
SUB MouseWheel
	XgrGetMouseInfo (@window, @g, @xWin, @yWin, @state, @time)
	XuiGetKids (grid, #GetKids, @g1, @k1, @k2, @k3, 0, @k4 )
	IF ((g == k1) || (g == k3)) THEN
			SELECT CASE SIGN(v3)
				CASE -1	: TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeMore)
				CASE 1	:	TextMessage (grid, #ScrollV, 0, 0, 0, 0, 0, #SomeLess)
			END SELECT
		END IF
END SUB
'
'
' *****  PassToKid  *****
'
SUB PassToKid
	XuiSendToKid (grid, message, @v0, @v1, @v2, @v3, 1, @r1)
END SUB
'
'
' *****  PassToText  *****
'
SUB PassToText
	TextMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetValue (grid, #GetValue, @shown, 0, 0, 0, 0, $cursorShown)
	IF shown THEN TextMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, $$SelectNoChange, 0, 0, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #Redraw, 0, 0, 0, 0, $ScrollV, 0)
	IF shown THEN TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawGrid  *****
'
SUB RedrawGrid
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetValue (grid, #GetValue, @shown, 0, 0, 0, 0, $cursorShown)
	IF shown THEN TextMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextMessage (grid, #Redraw, 0, 0, $$SelectNoChange, 0, 0, 0)
	IF shown THEN TextMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawText  *****
'
SUB RedrawText
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	TextMessage (grid, #Redraw, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Scroll  *****
'
SUB Scroll
	SELECT CASE r0
		CASE $ScrollH		: scroll = #ScrollH
		CASE $ScrollV		: scroll = #ScrollV
	END SELECT
	TextMessage (grid, scroll, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetAlign  *****
'
SUB SetAlign
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetIndent  *****
'
SUB SetIndent
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetBorder  *****
'
SUB SetBorder
	XuiGetSize (grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0)
	GOSUB Resize
END SUB
'
'
' *****  SetKeyboardFocus  *****  v2 = state : shift = extend selection
'																	started by func[#SetKeyboardFocus]
'
SUB SetKeyboardFocus
'	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
'	XgrSetTextSelectionGrid (grid)
'	TextMessage (grid, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
'	TextMessage (grid, #SetTextSelection, cp, cl, cp, cl, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	XuiGetStyle (grid, #GetStyle, @style, @styleMax, 0, 0, 0, 0)
	XuiGetIndent (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	XuiSendToKid (grid, #GetSize, @hx, @hy, @hw, @hh, $ScrollH, 0)
	XuiSendToKid (grid, #GetSize, @vx, @vy, @vw, @vh, $ScrollV, 0)
'
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 0
'
	SELECT CASE style
		CASE 0	: scrollBarSize = 12
		CASE 1	: scrollBarSize = 12
		CASE 2	: scrollBarSize = 16
		CASE 3	: scrollBarSize = 16
	END SELECT
'
	dx	= borderWidth + indentLeft
	dy	= borderWidth + indentTop
	dx2	= dx + borderWidth + indentRight
	dy2	= dy + borderWidth + indentBottom
	x		= dx
	y		= dy
	w		= v2 - dx2 - scrollBarSize - 1
	h		= v3 - dy2 - scrollBarSize - 1
	XuiSendToKid (grid, #Resize, x, y, w, h, $Text, 0)
	TextMessage (grid, #Resize, x, y, w, h, 0, 0)					' keep cursor visible
'
	dx	= borderWidth
	dy	= borderWidth
	dx2	= dx << 1
	dy2	= dy << 1
	w		= v2 - dx2 - scrollBarSize
	h		= scrollBarSize
	x		= dx
	y		= v3 - dy - h
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollH, 0)
'
	w		= scrollBarSize
	h		= v3 - dy2 - scrollBarSize
	x		= v2 - dx - w
	y		= dy
	XuiSendToKid (grid, #Resize, x, y, w, h, $ScrollV, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
'  ***** SetStyle *****
'
' $Style0 = 0		' normal scroll bars, flat buttons
' $Style1 = 1		' normal scroll bars, flat arrowbuttons
' $Style1 = 2		' recessed scroll bars, arrow buttons
' $Style2 = 3		' windows-style scroll bars, arrow buttons
'
SUB SetStyle
	style = v0
	IF (style < 0) THEN style = 0
	IF (style > 3) THEN style = 3
	XuiSetStyle (grid, #SetStyle, style, 0, 0, 0, 0, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollH, 0)
	XuiSendToKid (grid, #SetStyle, style, 0, 0, 0, $ScrollV, 0)
  XuiGetSize ( grid, #GetSize, @v0, @v1, @v2, @v3, 0, 0 )
	GOSUB Resize
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]			= 0
	func[#GetTextArray]					= 0
	func[#GrabTextArray]				= 0
	func[#PokeTextArray]				= 0
	func[#Redraw]								= 0
	func[#RedrawGrid]						= 0
	func[#RedrawText]						= 0
	func[#Resize]								= 0
	func[#SetStyle]							= 0
	func[#SetTextArray]					= 0
'
	DIM sub[upperMessage]
	sub[#Callback]							= SUBADDRESS (Callback)
	sub[#Change]								= SUBADDRESS (Scroll)
	sub[#Create]								= SUBADDRESS (Create)
	sub[#CreateWindow]					= SUBADDRESS (CreateWindow)
	sub[#HideTextCursor]				= SUBADDRESS (PassToText)
	sub[#GetSmallestSize]				= SUBADDRESS (GetSmallestSize)
	sub[#GetTextArray]					= SUBADDRESS (PassToText)
	sub[#GetTextArrayLine]			= SUBADDRESS (PassToText)
	sub[#GetTextArrayBounds]		= SUBADDRESS (PassToText)
	sub[#GetTextCursor]					= SUBADDRESS (PassToText)
	sub[#GetTextPosition]				= SUBADDRESS (PassToText)
	sub[#GetTextSelection]			= SUBADDRESS (PassToText)
	sub[#GotKeyboardFocus]			= SUBADDRESS (GotKeyboardFocus)
	sub[#GrabTextArray]					= SUBADDRESS (PassToText)
	sub[#KeyDown]								= SUBADDRESS (KeyDown)
	sub[#LostKeyboardFocus]			= SUBADDRESS (LostKeyboardFocus)
	sub[#LostTextSelection]			= SUBADDRESS (LostTextSelection)
	sub[#MouseDown]							= SUBADDRESS (MouseDown)
	sub[#MouseDrag]							= SUBADDRESS (MouseDrag)
	sub[#MouseUp]								= SUBADDRESS (MouseUp)
	sub[#MouseWheel]						= SUBADDRESS (MouseWheel)
	sub[#MuchLess]							= SUBADDRESS (Scroll)
	sub[#MuchMore]							= SUBADDRESS (Scroll)
	sub[#OneLess]								= SUBADDRESS (Scroll)
	sub[#OneMore]								= SUBADDRESS (Scroll)
	sub[#PokeTextArray]					= SUBADDRESS (PassToText)
	sub[#Redraw]								= SUBADDRESS (Redraw)
	sub[#RedrawGrid]						= SUBADDRESS (RedrawGrid)
	sub[#RedrawText]						= SUBADDRESS (RedrawText)
	sub[#Resize]								= SUBADDRESS (Resize)
	sub[#SetAlign]							= SUBADDRESS (SetAlign)
	sub[#SetBorder]							= SUBADDRESS (SetBorder)
	sub[#SetCharacterMapArray]	= SUBADDRESS (PassToKid)
	sub[#SetCharacterMapEntry]	= SUBADDRESS (PassToKid)
	sub[#SetColor]							= SUBADDRESS (PassToText)
	sub[#SetColorExtra]					= SUBADDRESS (PassToText)
	sub[#SetFont]								= SUBADDRESS (PassToText)
	sub[#SetFontNumber]					= SUBADDRESS (PassToText)
	sub[#SetIndent]							= SUBADDRESS (SetIndent)
	sub[#SetKeyboardFocus]			= SUBADDRESS (SetKeyboardFocus)
	sub[#SetStyle]							= SUBADDRESS (SetStyle)
	sub[#SetTextArray]					= SUBADDRESS (PassToText)
	sub[#SetTextArrayLine]			= SUBADDRESS (PassToText)
	sub[#SetTextCursor]					= SUBADDRESS (PassToText)
	sub[#SetTextSelection]			= SUBADDRESS (PassToText)
	sub[#ShowTextCursor]				= SUBADDRESS (PassToText)
	sub[#SomeLess]							= SUBADDRESS (Scroll)
	sub[#SomeMore]							= SUBADDRESS (Scroll)
	sub[#TextDelete]						= SUBADDRESS (PassToText)
	sub[#TextInsert]						= SUBADDRESS (PassToText)
	sub[#TextReplace]						= SUBADDRESS (PassToText)
'
	IF func[0] THEN PRINT "XuiTextArea() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiTextArea() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiTextArea, @"XuiTextArea", &XuiTextArea(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 80
'
	gridType = XuiTextArea
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        72)
	XuiSetGridTypeProperty (gridType, @"minHeight",       72)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       0)
	XuiSetGridTypeProperty (gridType, @"indentTop",        0)
	XuiSetGridTypeProperty (gridType, @"indentRight",      0)
	XuiSetGridTypeProperty (gridType, @"indentBottom",     0)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRidge)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextArray OR $$TextSelection)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiTextArea3B ()  #####  TextArea plus 3 PushButtons
' ##############################
'
FUNCTION  XuiTextArea3B (grid, message, v0, v1, v2, v3, r0, r1)
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiTextArea3B
'
	$TextArea3B	= 0
	$Label			= 1
	$Text				= 2
	$Button0		= 3
	$Button1		= 4
	$Button2		= 5
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiTextArea3B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiTextArea3B, @v0, @v1, @v2, @v3, r0, r1, &XuiTextArea3B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiTextArea    (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea3B(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextArea")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" post ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea3B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" update ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea3B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea3B(), -1, -1, $Button2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiTextArea3B")
END SUB
'
'
' *****  Resize  *****		Resize window to specified size or larger if necessary
'
SUB Resize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 0)
	IF (labelHeight < 16) THEN labelHeight = 16
'
'	text area is at least 80 x 80  (about 4 lines)
'
	textWidth = 80
	textHeight = 80
'
'	Get button widths and heights
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button2
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 8)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
'
'	Resize grid
'
	totalWidth	= buttonWidth + buttonWidth + buttonWidth
	totalWidth	= MAX (totalWidth, textWidth) + bw + bw
	totalHeight	= labelHeight + textHeight + buttonHeight + bw + bw
	totalWidth	= MAX(totalWidth, v2)
	totalHeight	= MAX(totalHeight, v3)
	v2					= totalWidth
	v3					= totalHeight
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	totalWidth	= v2
	totalHeight	= v3
'
	labelWidth	= totalWidth - bw - bw
	textWidth		= totalWidth - bw - bw
	textHeight	= totalHeight - labelHeight - buttonHeight - bw - bw
	buttonWidth	= textWidth / 3
	w0					= buttonWidth
	w1					= buttonWidth
	w2					= textWidth - w1 - w0
'
'	*****  Resize Kids  *****
'
	x = bw : y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	x	= bw : y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, textWidth, textHeight, $Text, 0)
'
	x	= bw : y = y + textHeight : h = buttonHeight
	XuiSendToKid (grid, #Resize, x, y, w0, h, $Button0, 0) : x = x + w0
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0) : x = x + w1
	XuiSendToKid (grid, #Resize, x, y, w2, h, $Button2, 0) : x = x + w2
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]					= &XuiCallback()
	func[#GetSmallestSize]	= &XuiGetMaxMinSize()
	func[#MouseDown]				= &XuiMouseDownSetKeyboardFocus()
	func[#Resize]						= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#Resize]						= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiTextArea3B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiTextArea3B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiTextArea3B, @"XuiTextArea3B", &XuiTextArea3B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 240
	designHeight = 120
'
	gridType = XuiTextArea3B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        80)
	XuiSetGridTypeProperty (gridType, @"minHeight",       80)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextArray)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextArray",   $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiTextArea4B ()  #####  TextArea plus 4 PushButtons
' ##############################
'
FUNCTION  XuiTextArea4B (grid, message, v0, v1, v2, v3, r0, r1)
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiTextArea4B
'
	$TextArea4B	= 0
	$Label			= 1
	$Text				= 2
	$Button0		= 3
	$Button1		= 4
	$Button2		= 5
	$Button3		= 6
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiTextArea4B) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiTextArea4B, @v0, @v1, @v2, @v3, r0, r1, &XuiTextArea4B())
	XuiLabel       (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Label")
	XuiTextArea    (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea4B(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"TextArea")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" enter ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea4B(), -1, -1, $Button0, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button0")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" update ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea4B(), -1, -1, $Button1, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button1")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" retry ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea4B(), -1, -1, $Button2, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button2")
	XuiPushButton  (@g, #Create, 0, 0, 0, 0, r0, grid)
	XuiSendMessage ( g, #SetTextString, 0, 0, 0, 0, 0, @" cancel ")
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextArea4B(), -1, -1, $Button3, grid)
	XuiSendMessage ( g, #SetGridName, 0, 0, 0, 0, 0, @"Button3")
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiTextArea4B")
END SUB
'
'
' *****  Resize  *****		Resize window to specified size or larger if necessary
'
SUB Resize
	XuiGetBorder (grid, #GetBorder, 0, 0, 0, 0, 0, @bw)
	XuiSendToKid (grid, #GetSmallestSize, 0, 0, @labelWidth, @labelHeight, $Label, 16)
'
'	Help text area is at least 80 x 80  (about 4 lines)
'
	textWidth = 80
	textHeight = 80
'
'	Get button widths and heights
'
	buttonWidth = 8
	buttonHeight = 8
	FOR i = $Button0 TO $Button3
		XuiSendToKid (grid, #GetSmallestSize, 0, 0, @width, @height, i, 16)
		IF (width > buttonWidth) THEN buttonWidth = width
		IF (height > buttonHeight) THEN buttonHeight = height
	NEXT i
'
'	Resize grid
'
	totalWidth	= buttonWidth << 2
	totalWidth	= MAX (totalWidth, textWidth) + bw + bw
	totalHeight	= labelHeight + textHeight + buttonHeight + bw + bw
	totalWidth	= MAX(totalWidth, v2)
	totalHeight	= MAX(totalHeight, v3)
	v2					= totalWidth
	v3					= totalHeight
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	totalWidth	= v2
	totalHeight	= v3
'
	labelWidth	= totalWidth - bw - bw
	textWidth		= totalWidth - bw - bw
	textHeight	= totalHeight - labelHeight - buttonHeight - bw - bw
	buttonWidth	= textWidth >> 2
	w0					= buttonWidth
	w1					= buttonWidth
	w2					= buttonWidth
	w3					= textWidth - w2 - w1 - w0
'
'	*****  Resize Kids  *****
'
	x = bw : y = bw
	XuiSendToKid (grid, #Resize, x, y, labelWidth, labelHeight, $Label, 0)
'
	x	= bw : y = y + labelHeight
	XuiSendToKid (grid, #Resize, x, y, textWidth, textHeight, $Text, 0)
'
	x	= bw : y = y + textHeight : h = buttonHeight
	XuiSendToKid (grid, #Resize, x, y, w0, h, $Button0, 0) : x = x + w0
	XuiSendToKid (grid, #Resize, x, y, w1, h, $Button1, 0) : x = x + w1
	XuiSendToKid (grid, #Resize, x, y, w2, h, $Button2, 0) : x = x + w2
	XuiSendToKid (grid, #Resize, x, y, w3, h, $Button3, 0) : x = x + w3
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#Callback]					= &XuiCallback()
	func[#GetSmallestSize]	= &XuiGetMaxMinSize()
	func[#Resize]						= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#Resize]						= SUBADDRESS (Resize)
'
	IF func[0] THEN PRINT "XuiTextArea4B() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiTextArea4B() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiTextArea4B, @"XuiTextArea4B", &XuiTextArea4B(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 240
	designHeight = 120
'
	gridType = XuiTextArea4B
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        80)
	XuiSetGridTypeProperty (gridType, @"minHeight",       80)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderFrame)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextArray)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $Text)
	XuiSetGridTypeProperty (gridType, @"inputTextArray",   $Text)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiTextLine ()  #####
' ############################
'
FUNCTION  XuiTextLine (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	UBYTE  charsetTextChar[]
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiTextLine
	STATIC  downGrid
	UBYTE  null[]
'
	$TextLine			= 0
	$Text					= 1
'
	$cursorPos		= 0
	$topIndent		= 1
	$xCursor			= 2
	$xCursorShown	= 3
	$cursorShown	= 4
	$begSelectPos	= 5
	$endSelectPos	= 6
	$tabWidth			= 7
	$cursorNoShow	= 8
	$lastValue		= 8
'
	IFZ sub[] THEN GOSUB Initialize
'	XgrMessageNumberToName (message, @message$)
'	PRINT "XuiTextLine() : grid, message$ ="; grid, message$
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiTextLine) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Callback  *****
'
SUB Callback
	message = r1
	callback = message
	IF (message <= upperMessage) THEN GOSUB @sub[message]
END SUB
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid  (@grid, XuiTextLine, v0, v1, v2, v3, r0, r1, &XuiTextLine())
	XuiSendMessage ( grid, #CreateValueArray, 23, 0, 0, 0, 0, 0)
	XuiSendMessage ( grid, #GetFontMetrics, @maxW, @maxH, @ascent, @decent, 0, @gap)
	XuiSendMessage ( grid, #SetTabWidth, maxW+maxW, 0, 0, 0, 0, 0)
	XuiArea        (@g, #Create, v0+2, v1+2, v2-4, v3-4, r0, grid)
	XuiSendMessage ( g, #SetCallback, grid, &XuiTextLine(), -1, -1, $Text, grid)
	XuiSendMessage ( g, #SetColorExtra, $$BrightGrey, -1, -1, -1, 0, 0)
	XuiSendMessage ( g, #SetRedrawFlags, $$RedrawNone, 0, 0, 0, 0, 0)
	XgrSetGridClip (g, g)
	GOSUB Resize
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiTextLine")
END SUB
'
'
' *****  GotKeyboardFocus  *****
'
SUB GotKeyboardFocus
'	PRINT "XuiTextLine() : GotKeyboardFocus : grid ="; grid
	TextLineMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  KeyDown  *****  ctrl	= MORE of the same : shift = extend selection
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
'
	state = v2																			' v2 = state
	key = state{8,0}
	ctrl = state AND $$CtrlBit
	shift = state AND $$ShiftBit
	contents = state{$$StateContents}
	virtualKey = state{$$VirtualKey}
'
	IF (contents = 1) THEN													' ASCII
		IF charsetTextChar[key] THEN
			IF (key != 0x0D) THEN
				abort = 0
				XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
				IF (abort = -1) THEN RETURN
				TextLineMessage (grid, #TextInsert, 0, 0, 0, key, 0, 0)
				EXIT SUB
			END IF
		END IF
	END IF
'
	selectAction = $$SelectCancel
	IF shift THEN selectAction = $$SelectDrag
'
	XgrGetTextSelectionGrid (@tsg)
	IF ctrl THEN
		SELECT CASE virtualKey
			CASE $$KeyX	: IF (grid = tsg) THEN						' ^X = cut
											virtualKey = $$KeyDelete
											ctrl = 0
										END IF
			CASE $$KeyC	: IF (grid = tsg) THEN						' ^C = grab/copy
											virtualKey = $$KeyInsert
										END IF
			CASE $$KeyV	: virtualKey = $$KeyInsert				' ^V = paste/insert
										ctrl = 0
		END SELECT
	END IF
'
	cursorMessage = 0
	SELECT CASE virtualKey
		CASE $$KeyBackspace, $$KeyDelete
					cursorMessage = #TextDelete
					action = virtualKey
		CASE $$KeyInsert
		CASE $$KeyLeftArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeLess
					ELSE
						action = #OneLess
					END IF
		CASE $$KeyRightArrow
					cursorMessage = #CursorH
					IF ctrl THEN
						action = #SomeMore
					ELSE
						action = #OneMore
					END IF
		CASE $$KeyHome
					cursorMessage = #CursorH										' beginning of line
					action = #Minimum
		CASE $$KeyEnd
					cursorMessage = #CursorH										' end of line
					action = #Maximum
	END SELECT
'
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, state, v3, @abort, grid)
	IF (abort = -1) THEN RETURN
	SELECT CASE virtualKey
'		CASE $$KeyEscape
'					XuiCallback (grid, #Selection, state, time, 0, 0, 0, 0)
'					EXIT SUB
		CASE $$KeyEnter
					XuiCallback (grid, #Selection, state, time, 0, 0, 0, 0)
					EXIT SUB
	END SELECT
'
	IF cursorMessage THEN
		TextLineMessage (grid, cursorMessage, 0, 0, selectAction, action, 0, action)
	ELSE
		IF (virtualKey = $$KeyInsert)
			IF ctrl THEN																' grab into buffer 0
				XgrGetTextSelectionGrid (@focusGrid)
				IF (grid = focusGrid) THEN
					TextLineMessage (grid, #GetTextSelection, @begPos, 0, 0, 0, 0, @text$)
					IF text$ THEN
						XgrSetClipboard (0, $$ClipboardTypeText, @text$, @null[])
						TextLineMessage (grid, #SetTextCursor, begPos, -1, -1, -1, 0, 0)
						TextLineMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
					END IF
				END IF
			ELSE																				' insert
				XgrGetClipboard (0, $$ClipboardTypeText, @text$, @null[])
				IF text$ THEN
					TextLineMessage (grid, #GetTextSelection, @begPos, 0, @endPos, 0, 0, 0)
					TextLineMessage (grid, #TextReplace, begPos, 0, endPos, 0, 0, @text$)
					TextLineMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
				END IF
			END IF
		END IF
	END IF
END SUB
'
'
' *****  LostKeyboardFocus  *****
'
SUB LostKeyboardFocus
'	PRINT "XuiTextLine() : LostKeyboardFocus : grid ="; grid
	TextLineMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
END SUB
'
'
' *****  LostTextSelection  *****
'
SUB LostTextSelection
	TextLineMessage (grid, #Redraw, 0, 0, $$SelectCancel, 0, 0, 0)
END SUB
'
'
' *****  MouseDown  *****  v2 = state : shift = extend selection
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
'
	downGrid = grid
	IF (v2 AND $$ShiftBit) THEN
		TextLineMessage (grid, #CursorH, v0, v1, $$SelectExtend, #Change, 0, #Change)
		EXIT SUB
	END IF
	TextLineMessage (grid, #CursorH, v0, v1, $$SelectSet, #Change, 0, #Change)
	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
'
	clicks	= v2{3,4}
	SELECT CASE clicks
		CASE 2																					' select word
			XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
			IFZ text$ THEN EXIT SELECT
			TextLineMessage (grid, #GetTextCursor, @cursorPos, 0, 0, 0, 0, 0)
			foundWord = $$FALSE
			SELECT CASE text${cursorPos}
				CASE 0, ' ', '\t', '\n'
				CASE ELSE:
							foundWord = $$TRUE
							endPos = INCHR (text$, " \t\n", cursorPos + 1)
							IFZ endPos THEN endPos = LEN(text$) ELSE DEC endPos
							begPos = 0
							IF cursorPos THEN begPos = RINCHR (text$, " \t\n", cursorPos)
			END SELECT
			IFF foundWord THEN
				IF cursorPos THEN
					SELECT CASE text${cursorPos - 1}
						CASE 0, ' ', '\t', '\n'
						CASE ELSE:
									foundWord = $$TRUE
									endPos = cursorPos
									begPos = 0
									begPos = RINCHR (text$, " \t\n", cursorPos)
					END SELECT
				END IF
			END IF
			IF foundWord THEN
				XgrSetTextSelectionGrid (grid)
				TextLineMessage (grid, #SetTextSelection, begPos, 0, endPos, 0, 0, 0)
				TextLineMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
			END IF
		CASE 3,4																				' select entire line
			XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
			IFZ text$ THEN EXIT SELECT
			XgrSetTextSelectionGrid (grid)
			TextLineMessage (grid, #SetTextSelection, 0, 0, LEN(text$), 0, 0, 0)
			TextLineMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
	END SELECT
END SUB
'
'
' *****  MouseDrag  *****  v01 low 2 bits clipped to avoid jiggle effects
'
SUB MouseDrag
	IF (grid != downGrid) THEN EXIT SUB
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	XuiGetKeyboardFocus (grid, #GetKeyboardFocus, @keyboardFocusGrid, 0, 0, 0, 0, 0)
	IF (grid != keyboardFocusGrid) THEN EXIT SUB
	XgrSetTextSelectionGrid (grid)
	TextLineMessage (grid, #CursorH, v0, v1, $$SelectDrag, #Change, 0, #Change)
END SUB
'
'
' *****  MouseUp  *****
'
SUB MouseUp
	downGrid = 0
END SUB
'
'
' *****  PassToTextLine  *****
'
SUB PassToTextLine
	TextLineMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	XuiGetValue (grid, #GetValue, @shown, 0, 0, 0, 0, $cursorShown)
	IF shown THEN TextLineMessage (grid, #HideTextCursor, 0, 0, 0, 0, 0, 0)
	XuiGetKids (grid, #GetKids, 0, @text, 0, 0, 0, 0)
	XgrClearGrid (grid, -1)
	XgrClearGrid (text, -1)
	TextLineMessage (grid, #Redraw, 0, 0, $$SelectNoChange, 0, 0, 0)
	IF shown THEN TextLineMessage (grid, #ShowTextCursor, 0, 0, 0, 0, 0, 0)
	XgrDrawGridBorder (grid, -1)
END SUB
'
'
' *****  RedrawText  *****
'
SUB RedrawText
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
	TextLineMessage (grid, #Redraw, 0, 0, $$SelectNoChange, 0, 0, 0)
END SUB
'
'
' *****  Resize  *****
'
SUB Resize
	XuiGetIndent  ( grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, @borderWidth)
	dx = borderWidth + indentLeft
	dy = borderWidth + indentTop
	dx2 = dx + borderWidth + indentRight
	dy2 = dy + borderWidth + indentBottom
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	w = maxCharWidth
	h = maxCharHeight + 1
	IF (w < 16) THEN w = 16
	IF (h < 8) THEN h = 8
	w = dx + dx + w
	h = dy + dy + h
	IF (v2 < w) THEN v2 = w
	IF (v3 < h) THEN v3 = h
	dc = 0 : height = v3-dy2
	IF (height > maxCharHeight) THEN dc = (height - maxCharHeight) >> 1
	XuiPositionGrid (grid, @v0, @v1, @v2, @v3)
	TextLineMessage (grid, #Resize, dx, dy+dc, v2-dx2, v3-dy2-dc-dc, 0, 0)
	XuiResizeWindowToGrid (grid, #ResizeWindowToGrid, v0, v1, v2, v3, 0, 0)
END SUB
'
'
' *****  SetKeyboardFocus  *****  v2 = state : shift = extend selection
'																	started by func[#SetKeyboardFocus]
SUB SetKeyboardFocus
'	PRINT "XuiTextLine() : SetKeyboardFocus : grid ="; grid
'	XuiSetKeyboardFocus (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
'	XgrSetTextSelectionGrid (grid)
'	TextLineMessage (grid, #GetTextCursor, @cp, @cl, 0, 0, 0, 0)
'	TextLineMessage (grid, #SetTextSelection, cp, cl, cp, cl, 0, 0)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#GetSmallestSize]	= 0
	func[#GetTextString]		= 0
	func[#MouseDown]				= 0
	func[#Redraw]						= 0
	func[#RedrawGrid]				= 0
	func[#RedrawText]				= 0
	func[#Resize]						= 0
	func[#SetTextString]		= 0
'
	DIM sub[upperMessage]
	sub[#Callback]						= SUBADDRESS (Callback)
	sub[#Create]							= SUBADDRESS (Create)
	sub[#CreateWindow]				= SUBADDRESS (CreateWindow)
	sub[#GetSmallestSize]			= SUBADDRESS (PassToTextLine)
	sub[#GetTextArrayBounds]	= SUBADDRESS (PassToTextLine)
	sub[#GetTextCursor]				= SUBADDRESS (PassToTextLine)
	sub[#GetTextSelection]		= SUBADDRESS (PassToTextLine)
	sub[#GetTextString]				= SUBADDRESS (PassToTextLine)
	sub[#GotKeyboardFocus]		= SUBADDRESS (GotKeyboardFocus)
	sub[#HideTextCursor]			= SUBADDRESS (PassToTextLine)
	sub[#KeyDown]							= SUBADDRESS (KeyDown)
	sub[#LostKeyboardFocus]		= SUBADDRESS (LostKeyboardFocus)
	sub[#LostTextSelection]		= SUBADDRESS (LostTextSelection)
	sub[#MouseDown]						= SUBADDRESS (MouseDown)
	sub[#MouseDrag]						= SUBADDRESS (MouseDrag)
	sub[#MouseUp]							= SUBADDRESS (MouseUp)
	sub[#Redraw]							= SUBADDRESS (Redraw)
	sub[#RedrawGrid]					= SUBADDRESS (Redraw)
	sub[#RedrawText]					= SUBADDRESS (RedrawText)
	sub[#Resize]							= SUBADDRESS (Resize)
	sub[#SetColor]						= SUBADDRESS (PassToTextLine)
	sub[#SetColorExtra]				= SUBADDRESS (PassToTextLine)
	sub[#SetFont]							= SUBADDRESS (PassToTextLine)
	sub[#SetFontNumber]				= SUBADDRESS (PassToTextLine)
	sub[#SetKeyboardFocus]		= SUBADDRESS (SetKeyboardFocus)
	sub[#SetTextCursor]				= SUBADDRESS (PassToTextLine)
	sub[#SetTextSelection]		= SUBADDRESS (PassToTextLine)
	sub[#SetTextString]				= SUBADDRESS (PassToTextLine)
	sub[#ShowTextCursor]			= SUBADDRESS (PassToTextLine)
	sub[#TextDelete]					= SUBADDRESS (PassToTextLine)
	sub[#TextInsert]					= SUBADDRESS (PassToTextLine)
	sub[#TextReplace]					= SUBADDRESS (PassToTextLine)
'
	IF func[0] THEN PRINT "XuiTextLine() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiTextLine() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiTextLine, @"XuiTextLine", &XuiTextLine(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 24
'
	gridType = XuiTextLine
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",        16)
	XuiSetGridTypeProperty (gridType, @"minHeight",       16)
	XuiSetGridTypeProperty (gridType, @"indentLeft",       1)
	XuiSetGridTypeProperty (gridType, @"indentTop",        0)
	XuiSetGridTypeProperty (gridType, @"indentRight",      1)
	XuiSetGridTypeProperty (gridType, @"indentBottom",     0)
	XuiSetGridTypeProperty (gridType, @"dullColor",       $$BrightGrey)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRidge)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback OR $$InputTextString OR $$TextSelection)
	XuiSetGridTypeProperty (gridType, @"focusKid",         $TextLine)
	XuiSetGridTypeProperty (gridType, @"inputTextString",  $TextLine)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawClearBorder)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ################################
' #####  XuiToggleButton ()  #####
' ################################
'
FUNCTION  XuiToggleButton (grid, message, v0, v1, v2, v3, r0, (r1, r1[], r1$))
	STATIC	designX,  designY,  designWidth,  designHeight
	STATIC	SUBADDR  sub[]
	STATIC	upperMessage
	STATIC	XuiToggleButton
'
	IFZ sub[] THEN GOSUB Initialize
	IF XuiProcessMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1, XuiToggleButton) THEN RETURN
	GOSUB @sub[message]
	RETURN
'
'
' *****  Create  *****  v0123 = xywh : r0 = window : r1 = parent
'
SUB Create
	IF (v0 <= 0) THEN v0 = 0
	IF (v1 <= 0) THEN v1 = 0
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiCreateGrid (@grid, XuiToggleButton, @v0, @v1, @v2, @v3, r0, r1, &XuiToggleButton())
END SUB
'
'
' *****  CreateWindow  *****  r0 = windowType : r1$ = display$
'
SUB CreateWindow
	IF (v0  = 0) THEN v0 = designX
	IF (v1  = 0) THEN v1 = designY
	IF (v2 <= 0) THEN v2 = designWidth
	IF (v3 <= 0) THEN v3 = designHeight
	XuiWindow (@window, #WindowCreate, v0, v1, v2, v3, r0, @r1$)
	v0 = 0 : v1 = 0 : r0 = window : ATTACH r1$ TO display$
	GOSUB Create
	r1 = 0 : ATTACH display$ TO r1$
	XuiWindow (window, #WindowRegister, grid, -1, v2, v3, @r0, @"XuiToggleButton")
END SUB
'
'
' *****  KeyDown  *****  #Selection on $$KeyEnter
'
SUB KeyDown
	XuiGetState (grid, #GetState, @state, @keyboard, 0, 0, 0, 0)
	IFZ (state AND keyboard) THEN EXIT SUB
	abort = 0
	XuiCallback (grid, #TextEvent, v0, v1, v2, v3, @abort, grid)
	IF (abort != -1) THEN
		IF (v2{8,24} = $$KeyEnter) THEN GOSUB Toggle
	END IF
END SUB
'
'
' *****  MouseDown  *****
'
SUB MouseDown
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND mouse) THEN EXIT SUB
	IF (v2 AND $$HelpButtonBit) THEN EXIT SUB
	GOSUB Toggle
END SUB
'
'
' *****  RedrawGrid  ****
'
SUB RedrawGrid
	XuiCallback (grid, #Redrawn, v0, v1, v2, v3, 0, grid)
END SUB
'
'
' *****  SetValue  *****
'
SUB SetValue
	IF r1 THEN EXIT SUB
	GOSUB SetValues
END SUB
'
'
' *****  SetValues  *****
'
SUB SetValues
	XuiGetValue (grid, #GetValue, @value0, 0, 0, 0, 0, 0)
	IF (v0 != value0) THEN GOSUB Toggle
END SUB
'
'
' *****  Toggle  *****
'
SUB Toggle
	XuiGetValue (grid, #GetValue, @state, 0, 0, 0, 0, 0)
	state = NOT state
	XuiSetValue (grid, #SetValue, state, 0, 0, 0, 0, 0)
	XuiGetBorder (grid, #GetBorder, @border, @borderUp, @borderDown, 0, 0, 0)
	IF state THEN border = borderDown ELSE border = borderUp
	XuiSetBorder (grid, #SetBorder, border, -1, -1, -1, 0, 0)
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, 0, 0)
	XuiCallback (grid, #Selection, state, 0, v2, v3, 0, grid)
END SUB
'
'
' *****  Initialize  ****
'
SUB Initialize
	XuiGetDefaultMessageFuncArray (@func[])
	XgrMessageNameToNumber (@"LastMessage", @upperMessage)
'
	func[#SetValue]					= 0
	func[#SetValues]				= 0
'
	DIM sub[upperMessage]
	sub[#Create]						= SUBADDRESS (Create)
	sub[#CreateWindow]			= SUBADDRESS (CreateWindow)
	sub[#KeyDown]						= SUBADDRESS (KeyDown)
	sub[#MouseDown]					= SUBADDRESS (MouseDown)
	sub[#RedrawGrid]				= SUBADDRESS (RedrawGrid)
	sub[#SetValue]					= SUBADDRESS (SetValue)
	sub[#SetValues]					= SUBADDRESS (SetValues)
'
	IF func[0] THEN PRINT "XuiToggleButton() : Initialize : error ::: (undefined message)"
	IF sub[0] THEN PRINT "XuiToggleButton() : Initialize : error ::: (undefined message)"
	XuiRegisterGridType (@XuiToggleButton, @"XuiToggleButton", &XuiToggleButton(), @func[], @sub[])
'
	designX = 0
	designY = 0
	designWidth = 80
	designHeight = 20
'
	gridType = XuiToggleButton
	XuiSetGridTypeProperty (gridType, @"x",               designX)
	XuiSetGridTypeProperty (gridType, @"y",               designY)
	XuiSetGridTypeProperty (gridType, @"width",           designWidth)
	XuiSetGridTypeProperty (gridType, @"height",          designHeight)
	XuiSetGridTypeProperty (gridType, @"minWidth",         4)
	XuiSetGridTypeProperty (gridType, @"minHeight",        4)
	XuiSetGridTypeProperty (gridType, @"align",           $$AlignMiddleCenter)
	XuiSetGridTypeProperty (gridType, @"border",          $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderUp",        $$BorderRaise2)
	XuiSetGridTypeProperty (gridType, @"borderDown",      $$BorderLower2)
	XuiSetGridTypeProperty (gridType, @"texture",         $$TextureLower1)
	XuiSetGridTypeProperty (gridType, @"can",             $$Focus OR $$Respond OR $$Callback)
	XuiSetGridTypeProperty (gridType, @"redrawFlags",     $$RedrawDefault)
	IFZ message THEN RETURN
END SUB
END FUNCTION
'
'
' ############################
' #####  XuiCallback ()  #####
' ############################
'
FUNCTION  XuiCallback (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	CALLBACK	callback[]
	STATIC	ug, um, uv0,  uv1,  uv2,  uv3,  ur0,  ur1
	STATIC	xg, xm, xv0,  xv1,  xv2,  xv3,  xr0,  xr1
	FUNCADDR  f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (grid < 0) THEN PRINT "XuiCallback() : error : (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "XuiCallback() : error : (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiCallback() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "XuiCallback() : error : (message > upperMessage)" : RETURN
'
	SELECT CASE message
		CASE #Callback
					f = callback[grid].func
					g = callback[grid].grid
					rr0 = callback[grid].r0
					IF (rr0 != -1) THEN
						IF ##WHOMASK THEN ur0 = r0 ELSE xr0 = r0
						r0 = rr0
					END IF
					@f (g, message, v0, v1, v2, v3, @r0, r1)
					RETURN
		CASE #GetCallbackArgs
					IF ##WHOMASK THEN
						grid = ug : message = um : v0 = uv0 : v1 = uv1 : v2 = uv2 : v3 = uv3 : r0 = ur0 : r1 = ur1
					ELSE
						grid = xg : message = xm : v0 = xv0 : v1 = xv1 : v2 = xv2 : v3 = xv3 : r0 = xr0 : r1 = xr1
					END IF
					RETURN
		CASE ELSE
					IF ##WHOMASK THEN
						ug = grid : um = message : uv0 = v0 : uv1 = v1 : uv2 = v2 : uv3 = v3 : ur0 = r0 : ur1 = r1
					ELSE
						xg = grid : xm = message : xv0 = v0 : xv1 = v1 : xv2 = v2 : xv3 = v3 : xr0 = r0 : xr1 = r1
					END IF
					f = callback[grid].func	: IFZ f THEN RETURN
					g = callback[grid].grid
					vv2 = callback[grid].v2
					vv3 = callback[grid].v3
					rr0 = callback[grid].r0
					rr1 = callback[grid].r1
					IF (vv2 != -1) THEN v2 = vv2
					IF (vv3 != -1) THEN v3 = vv3
					IF (rr0 != -1) THEN r0 = rr0
					IF (rr1 != -1) THEN r1 = rr1
					@f (g, #Callback, v0, v1, v2, v3, @r0, message)
	END SELECT
END FUNCTION
'
'
' ###############################
' #####  XuiCloseWindow ()  #####
' ###############################
'
FUNCTION  XuiCloseWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiCloseWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiCloseWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #CloseWindow) THEN PRINT "XuiCloseWindow() : error : (message != #CloseWindow)" : RETURN
'
	abort = 0
	XuiCallback (grid, message, v0, v1, v2, v3, @abort, r1)
'	PRINT "XuiCloseWindow() : sent callback : "; grid, message
END FUNCTION
'
'
' ####################################
' #####  XuiCreateValueArray ()  #####
' ####################################
'
FUNCTION  XuiCreateValueArray (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	values[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiCreateValueArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiCreateValueArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #CreateValueArray) THEN PRINT "XuiCreateValueArray() : error : (message != #CreateValueArray)" : RETURN
	IF (v0 > 65535) THEN PRINT "XuiCreateValueArray() : error : (v0 > 65535)" : RETURN
'
	DIM temp[]
	IF (v0 >= 0) THEN DIM temp[v0]
	SWAP temp[], values[grid,]
	DIM temp[]
END FUNCTION
'
'
' ###########################
' #####  XuiDestroy ()  #####
' ###########################
'
FUNCTION  XuiDestroy (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	window[]
	SHARED	kids[]
	SHARED	help$[]
	SHARED	hint$[]
	SHARED	image$[]
	SHARED	array[]
	SHARED	values[]
	SHARED	tabArray[]
	SHARED	gridName$[]
	SHARED	gridFunc$[]
	SHARED	gridType$[]
	SHARED	textArray$[]
	SHARED	textString$[]
	SHARED	gridMessageFunc[]
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	SHARED	CALLBACK	callback[]
	SHARED	CALLBACK	monitor[]
	STATIC	CALLBACK	zero
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, 0, 0, 0, 0, kid, 0)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiDestroy() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiDestroy() : error : (grid > upperGrid)" : RETURN
	IF (message != #Destroy) THEN PRINT "XuiDestroy() : error : (message != #Destroy)" : RETURN
'
' remove all message monitors
'
	func = windowInfo[window].func
	@func (window, #WindowMonitorKeyboard, grid, -1, 0, 0, 0, 0)
	@func (window, #WindowMonitorContext, grid, -1, 0, 0, 0, 0)
	@func (window, #WindowMonitorMouse, grid, -1, 0, 0, 0, 0)
	@func (window, #WindowMonitorHelp, grid, -1, 0, 0, 0, 0)
'
	image = grid[grid].image
	parent = grid[grid].parent
	window = grid[grid].window
	gridFunc = grid[grid].gridFunc
	gridWindow = grid[grid].gridWindow
	IF kids[grid, ] THEN
		FOR i = 1 TO UBOUND(kids[grid, ])
			kg = kids[grid, i]
			IF kg THEN XuiSendMessage (kg, #Destroy, 0, 0, 0, 0, 0, 0)
			kids[grid,i] = 0
		NEXT i
		kids[grid,0] = 0
	END IF
'
	XgrDestroyGrid (grid)
	XuiCallback (grid, #Destroyed, 0, 0, 0, 0, 0, 0)
'
	IF image THEN
		XgrDestroyGrid (image)
		XuiCallback (image, #Destroyed, 0, 0, 0, 0, 0, 0)
	END IF
'
	IF parent THEN FreeGridFromParent (grid, parent)
'
' remove grid from list of grids in window
'
	IFZ parent THEN
		lastGrid = UBOUND(window[window, ])
		FOR i = 0 TO lastGrid
			IF (grid = window[window,i]) THEN window[window,i] = 0 : EXIT FOR
		NEXT i
		IF (i > lastGrid) THEN
			PRINT "XuiDestroy() : error ::: (parentless grid not found in window[window, ])"
		END IF
	ELSE
		lastGrid = UBOUND(window[window, ])
		FOR i = 0 TO lastGrid
			IF (grid = window[window,i]) THEN PRINT "XuiDestroy() : error ::: (grid = window[window,i]... grid with parent)"
		NEXT i
	END IF
'
' clear out grid properties
'
	grid[grid].grid = 0
	grid[grid].image = 0
	grid[grid].window = 0
	grid[grid].parent = 0
	grid[grid].gridType = 0
	grid[grid].gridFunc = 0
	grid[grid].whomask = 0
'
	help$[grid] = ""
	hint$[grid] = ""
	image$[grid] = ""
	gridName$[grid] = ""
	gridType$[grid] = ""
	gridFunc$[grid] = ""
	textString$[grid] = ""
'
	callback[grid] = zero
	ATTACH kids[grid, ] TO temp[] : DIM temp[]
	ATTACH array[grid, ] TO temp[] : DIM temp[]
	ATTACH values[grid, ] TO temp[] : DIM temp[]
	ATTACH tabArray[grid, ] TO temp[] : DIM temp[]
	ATTACH textArray$[grid, ] TO text$[] : DIM text$[]
	ATTACH gridMessageFunc[grid, ] TO temp[] : DIM temp[]
'
	IF monitor[] THEN
		upper = UBOUND (monitor[])
		FOR i = 0 TO upper
			IF (monitor[i].grid = grid) THEN
				monitor[i].grid = 0
				monitor[i].func = 0
				monitor[i].v0 = 0
				monitor[i].v1 = 0
				monitor[i].r0 = 0
			END IF
		NEXT i
	END IF
'
	IF gridWindow THEN
		windowGrid = windowInfo[window].grid
		func = windowInfo[gridWindow].func
		@func (gridWindow, #WindowDestroy, 0, 0, 0, 0, 0, 0)
		IFZ func THEN PRINT "XuiDestroy() : error : (windowInfo[gridWindow].func = 0)" : RETURN
		IF (grid != windowGrid) THEN PRINT "XuiDestroy() : error : (grid != windowInfo[gridWindow].grid)" : RETURN
		IF (window != gridWindow) THEN PRINT "XuiDestroy() : error : (grid[grid].window != windowInfo[window].grid)" : RETURN
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiDestroyWindow ()  #####
' #################################
'
FUNCTION  XuiDestroyWindow (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, 0, 0, 0, 0, kid, 0)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiDestroyWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiDestroyWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #DestroyWindow) THEN PRINT "XuiDestroyWindow() : error : (message != #DestroyWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiDestroyWindow() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowDestroy, 0, 0, 0, 0, 0, 0)
	IFZ func THEN PRINT "XuiDestroyWindow() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ###########################
' #####  XuiDisable ()  #####
' ###########################
'
FUNCTION  XuiDisable (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	keyboardFocusGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, 0, 0, 0, 0, kid, 0)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiDisable() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiDisable() : error : (grid > upperGrid)" : RETURN
	IF (message != #Disable) THEN PRINT "XuiDisable() : error : (message != #Disable)" : RETURN
'
	grid[grid].state = $$FALSE
	XgrSetGridState (grid, $$XuiDisable)
	IF kids[grid, ] THEN XuiSendToKids (grid, #Disable, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' #############################
' #####  XuiDisplayed ()  #####
' #############################
'
FUNCTION  XuiDisplayed (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiDisplayed() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiDisplayed() : error : (grid > upperGrid)" : RETURN
	IF (message != #Displayed) THEN PRINT "XuiDisplayed() : error : (message != #Displayed)" : RETURN
'
	abort = 0
	XuiCallback (grid, message, v0, v1, v2, v3, @abort, r1)
'	PRINT "XuiDisplayed() : sent callback : "; grid, message
END FUNCTION
'
'
' #################################
' #####  XuiDisplayWindow ()  #####
' #################################
'
FUNCTION  XuiDisplayWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiDisplayWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiDisplayWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #DisplayWindow) THEN PRINT "XuiDisplayWindow() : error : (message != #DisplayWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiDisplayWindow() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowDisplay, v0, v1, v2, v3, 0, 0)
	IFZ func THEN PRINT "XuiDisplayWindow() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ##########################
' #####  XuiEnable ()  #####
' ##########################
'
FUNCTION  XuiEnable (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, 0, 0, 0, 0, kid, 0)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiEnable() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiEnable() : error : (grid > upperGrid)" : RETURN
	IF (message != #Enable) THEN PRINT "XuiEnable() : error : (message != #Enable)" : RETURN
'
	grid[grid].state = $$TRUE
	XgrSetGridState (grid, $$XuiEnable)
	IF kids[grid, ] THEN XuiSendToKids (grid, #Enable, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ############################
' #####  XuiGetAlign ()  #####
' ############################
'
FUNCTION  XuiGetAlign (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetAlign() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetAlign() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetAlign) THEN PRINT "XuiGetAlign() : error : (message != #GetAlign)" : RETURN
'
	v0 = grid[grid].align
	v1 = grid[grid].justify
	v2 = grid[grid].indentLeft
	v3 = grid[grid].indentTop
'
	r1 = 0
	XgrGetGridBorder (grid, @border, 0, 0, 0)
	XgrBorderNumberToWidth (border, @r1)
END FUNCTION
'
'
' #############################
' #####  XuiGetBorder ()  #####
' #############################
'
FUNCTION  XuiGetBorder (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetBorder() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetBorder() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetBorder) THEN PRINT "XuiGetBorder() : error : (message != #GetBorder)" : RETURN
'
	XgrGetGridBorder (grid, @v0, @v1, @v2, @v3)
	XgrBorderNumberToWidth (v0, @r1)
	IF (r1 < 0) THEN r1 = 0
END FUNCTION
'
'
' ###################################
' #####  XuiGetBorderOffset ()  #####
' ###################################
'
FUNCTION  XuiGetBorderOffset (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetBorderOffset() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetBorderOffset() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetBorderOffset) THEN PRINT "XuiGetBorderOffset() : error : (message != #GetBorderOffset)" : RETURN
'
	XgrGetGridBorderOffset (grid, @v0, @v1, @v2, @v3)
	XgrGetGridBorder (grid, @border, 0, 0, 0)
	XgrBorderNumberToWidth (border, @r1)
	IF (r1 < 0) THEN r1 = 0
END FUNCTION
'
'
' ###############################
' #####  XuiGetCallback ()  #####
' ###############################
'
FUNCTION  XuiGetCallback (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	upperGrid
	SHARED	CALLBACK	callback[]
'
	IF (r0 > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetCallback() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetCallback() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetCallback) THEN PRINT "XuiGetCallback() : error : (message != #GetCallback)" : RETURN
'
	v0 = callback[grid].grid
	v1 = callback[grid].func
	v2 = callback[grid].v2
	v3 = callback[grid].v3
	r0 = callback[grid].r0
	r1 = callback[grid].r1
END FUNCTION
'
'
' ##########################
' #####  XuiGetCan ()  #####
' ##########################
'
FUNCTION  XuiGetCan (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetCan() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetCan() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetCan) THEN PRINT "XuiGetCan() : error : (message != #GetCan)" : RETURN
'
	v0 = grid[grid].can
	v1 = grid[grid].focusKid
	v2 = grid[grid].inputTextArray
	v3 = grid[grid].inputTextString
	r1 = grid[grid].redrawFlags
END FUNCTION
'
'
' ###############################
' #####  XuiGetClipGrid ()  #####
' ###############################
'
FUNCTION  XuiGetClipGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetClipGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetClipGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetClipGrid) THEN PRINT "XuiGetClipGrid() : error : (message != #GetClipGrid)" : RETURN
'
	v0 = grid[grid].clip
'	XgrGetGridClip (grid, @v0)
END FUNCTION
'
'
' ############################
' #####  XuiGetColor ()  #####
' ############################
'
FUNCTION  XuiGetColor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetColor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetColor() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetColor) THEN PRINT "XuiGetColor() : error : (message != #GetColor)" : RETURN
'
	v0 = grid[grid].backgroundColor
	v1 = grid[grid].drawingColor
	v2 = grid[grid].lowlightColor
	v3 = grid[grid].highlightColor
END FUNCTION
'
'
' #################################
' #####  XuiGetColorExtra ()  #####
' #################################
'
FUNCTION  XuiGetColorExtra (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetColorExtra() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetColorExtra() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetColorExtra) THEN PRINT "XuiGetColorExtra() : error : (message != #GetColorExtra)" : RETURN
'
	v0 = grid[grid].dullColor
	v1 = grid[grid].accentColor
	v2 = grid[grid].lowtextColor
	v3 = grid[grid].hightextColor
END FUNCTION
'
'
' #############################
' #####  XuiGetCursor ()  #####
' #############################
'
FUNCTION  XuiGetCursor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetCursor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetCursor() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetCursor) THEN PRINT "XuiGetCursor() : error : (message != #GetCursor)" : RETURN
'
	v0 = grid[grid].cursor
END FUNCTION
'
'
' ##############################
' #####  XuiGetDisplay ()  #####
' ##############################
'
FUNCTION  XuiGetDisplay (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetDisplay() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetDisplay() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetDisplay) THEN PRINT "XuiGetDisplay() : error : (message != #GetDisplay)" : RETURN
'
	window = grid[grid].window
	XuiSendMessage (window, WindowGetDisplay, 0, 0, 0, 0, 0, @r1$)
END FUNCTION
'
'
' ####################################
' #####  XuiGetEnclosedGrids ()  #####
' ####################################
'
FUNCTION  XuiGetEnclosedGrids (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetEnclosedGrids() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetEnclosedGrids() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetEnclosedGrids) THEN PRINT "XuiGetEnclosedGrids() : error : (message != #GetEnclosedGrids)" : RETURN
'
	window = grid[grid].window
	upperWindow = UBOUND(windowInfo[])
	IF (window <= 0) THEN PRINT "XuiGetEnclosedGrids() : error : (window <= 0)" : RETURN
	IF (window > upperWindow) THEN PRINT "XuiGetEnclosedGrids() : error : (window > upperWindow)" : RETURN
'
	entry = 0
	upper = 255
	DIM r1[upper]
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	FOR i = 0 TO upperGrid
		g = grid[i].grid
		IFZ g THEN DO NEXT
		IF (g = grid) THEN DO NEXT
		win = grid[g].window
		IF (win != window) THEN DO NEXT
		XgrGetGridBoxWindow (g, @xx1, @yy1, @xx2, @yy2)
		IF (x1 > xx1) THEN DO NEXT
		IF (y1 > yy1) THEN DO NEXT
		IF (x2 < xx2) THEN DO NEXT
		IF (y2 < yy2) THEN DO NEXT
		XuiGetEnclosingGrid (g, #GetEnclosingGrid, @ggg, 0, 0, 0, 0, 0)
		IF (ggg != grid) THEN DO NEXT
		IF (entry > upper) THEN
			upper = upper + 256
			REDIM r1[upper]
		END IF
		r1[entry] = g
		INC entry
	NEXT
	IFZ entry THEN DIM r1[] : RETURN
	REDIM r1[entry-1]
END FUNCTION
'
'
' ####################################
' #####  XuiGetEnclosingGrid ()  #####
' ####################################
'
FUNCTION  XuiGetEnclosingGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetEnclosingGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetEnclosingGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetEnclosingGrid) THEN PRINT "XuiGetEnclosingGrid() : error : (message != #GetEnclosingGrid)" : RETURN
'
	window = grid[grid].window
	upperWindow = UBOUND(windowInfo[])
	IF (window <= 0) THEN PRINT "XuiGetEnclosingGrid() : error : (window <= 0)" : RETURN
	IF (window > upperWindow) THEN PRINT "XuiGetEnclosingGrid() : error : (window > upperWindow)" : RETURN
'
	v0 = 0
	closeX = $$MIN
	closeY = $$MIN
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)
	FOR i = 1 TO upperGrid
		g = grid[i].grid
		IFZ g THEN DO NEXT
		IF (g = grid) THEN DO NEXT
		win = grid[g].window
		IF (win != window) THEN DO NEXT
		XgrGetGridBoxWindow (g, @xx1, @yy1, @xx2, @yy2)
		IF (x1 < xx1) THEN DO NEXT
		IF (y1 < yy1) THEN DO NEXT
		IF (x2 > xx2) THEN DO NEXT
		IF (y2 > yy2) THEN DO NEXT
		IF (xx1 > closeX) THEN
			closeX = xx1
			closeY = yy1
			v0 = g
		END IF
	NEXT
END FUNCTION
'
'
' #################################
' #####  XuiGetFocusColor ()  #####
' #################################
'
FUNCTION  XuiGetFocusColor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetFocusColor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetFocusColor() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetFocusColor) THEN PRINT "XuiGetFocusColor() : error : (message != #GetFocusColor)" : RETURN
'
	v0 = grid[grid].focusBackground
	v1 = grid[grid].focusDrawing
	v2 = grid[grid].focusLowlight
	v3 = grid[grid].focusHighlight
END FUNCTION
'
'
' ######################################
' #####  XuiGetFocusColorExtra ()  #####
' ######################################
'
FUNCTION  XuiGetFocusColorExtra (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetFocusColorExtra() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetFocusColorExtra() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetFocusColorExtra) THEN PRINT "XuiGetFocusColorExtra() : error : (message != #GetFocusColorExtra)" : RETURN
'
	v0 = grid[grid].focusDull
	v1 = grid[grid].focusAccent
	v2 = grid[grid].focusLowtext
	v3 = grid[grid].focusHightext
END FUNCTION
'
'
' ###########################
' #####  XuiGetFont ()  #####
' ###########################
'
FUNCTION  XuiGetFont (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetFont() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetFont() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetFont) THEN PRINT "XuiGetFont() : error : (message != #GetFont)" : RETURN
'
	font = grid[grid].font
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r1$ = ""
	XgrGetFontInfo (font, @r1$, @v0, @v1, @v2, @v3)
END FUNCTION
'
'
' ##################################
' #####  XuiGetFontMetrics ()  #####
' ##################################
'
FUNCTION  XuiGetFontMetrics (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetFontMetrics() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetFontMetrics() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetFontMetrics) THEN PRINT "XuiGetFontMetrics() : error : (message != #GetFontMetrics)" : RETURN
'
	font = grid[grid].font
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r1 = 0
	XgrGetFontMetrics (font, @v0, @v1, @v2, @v3, @r1, @xxx)
END FUNCTION
'
'
' #################################
' #####  XuiGetFontNumber ()  #####
' #################################
'
FUNCTION  XuiGetFontNumber (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetFontNumber() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetFontNumber() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetFontNumber) THEN PRINT "XuiGetFontNumber() : error : (message != #GetFontNumber)" : RETURN
'
	v0 = grid[grid].font
END FUNCTION
'
'
' ###################################
' #####  XuiGetGridFunction ()  #####
' ###################################
'
FUNCTION  XuiGetGridFunction (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridFunction() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridFunction() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridFunction) THEN PRINT "XuiGetGridFunction() : error : (message != #GetGridFunction)" : RETURN
'
	v0 = grid[grid].gridFunc
END FUNCTION
'
'
' #######################################
' #####  XuiGetGridFunctionName ()  #####
' #######################################
'
FUNCTION  XuiGetGridFunctionName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridFunc$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridFunctionName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridFunctionName() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridFunctionName) THEN PRINT "XuiGetGridFunctionName() : error : (message != #GetGridFunctionName)" : RETURN
'
	v0 = grid[grid].gridFunc
	r1$ = gridFunc$[grid]
END FUNCTION
'
'
' ###############################
' #####  XuiGetGridName ()  #####
' ###############################
'
FUNCTION  XuiGetGridName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridName$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridName() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridName) THEN PRINT "XuiGetGridName() : error : (message != #GetGridName)" : RETURN
'
	v0 = grid
	r1$ = gridName$[grid]
END FUNCTION
'
'
' #################################
' #####  XuiGetGridNumber ()  #####
' #################################
'
FUNCTION  XuiGetGridNumber (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridNumber() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridNumber() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridNumber) THEN PRINT "XuiGetGridNumber() : error : (message != #GetGridNumber)" : RETURN
'
	v0 = grid
	v1 = 0
	v2 = 0
	v3 = 0
	r1 = grid[grid].parent
	IF kids[grid, ] THEN
		u = UBOUND (kids[grid, ])
		IF (u >= 1) THEN v1 = kids[grid, 1]
		IF (u >= 2) THEN v2 = kids[grid, 2]
		IF (u >= 3) THEN v3 = kids[grid, 3]
	END IF
END FUNCTION
'
'
' #####################################
' #####  XuiGetGridProperties ()  #####
' #####################################
'
FUNCTION  XuiGetGridProperties (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED  GRID  grid[]
	SHARED	gridName$[]
	SHARED	upperGrid
	SHARED  prop$[]
	SHARED	kids[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1)
		RETURN
	END IF
'
	DIM r1$[]
	IF (grid <= 0) THEN PRINT "XuiGetGridProperties() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridProperties() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridProperties) THEN PRINT "XuiGetGridProperties() : error : (message != #GetGridProperties)" : RETURN
'
	IFZ prop$[] THEN RETURN
	upper = UBOUND (prop$[])
	gridName$ = gridName$[grid]
	XstGetProgramName (@program$)
	XgrGetGridType (grid, @gridType)
	XgrGridTypeNumberToName (@gridType, @gridType$)
'
	entry = 0
	DIM r1$[upper]
'
	FOR i = 0 TO upper
		index = 0
		done = $$FALSE
		text$ = TRIM$ (prop$[i])
		IF text$ THEN
			IF (text${0} != ''') THEN
				IFZ done THEN pg$ = XstNextField$ (@text$, @index, @done)
				IFZ done THEN gt$ = XstNextField$ (@text$, @index, @done)
				IFZ done THEN iii = INSTR (text$, "XuiSendMessage")
				IF (iii < index) THEN DO NEXT
				IF done THEN DO NEXT
				IFZ pg$ THEN DO NEXT
				IFZ gt$ THEN DO NEXT
				IF ((pg${0} = '*') OR (pg$ = program$)) THEN
					IF ((gt${0} = '*') OR (gt$ = gridType$)) THEN
						line$ = MID$ (text$, iii)
						ParseFuncLine (@line$, @a$[])
						gn$ = a$[1]
						IF ((gn$ = "*") OR (gn$ = gridName$)) THEN
							r1$[entry] = line$
							INC entry
						END IF
					END IF
				END IF
			END IF
		END IF
	NEXT i
'
	IFZ entry THEN
		DIM r1$[]
	ELSE
		DEC entry
		REDIM r1$[entry]
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiGetGridType ()  #####
' ###############################
'
FUNCTION  XuiGetGridType (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridType() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridType() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridType) THEN PRINT "XuiGetGridType() : error : (message != #GetGridType)" : RETURN
'
	v0 = grid[grid].gridType
END FUNCTION
'
'
' ###################################
' #####  XuiGetGridTypeName ()  #####
' ###################################
'
FUNCTION  XuiGetGridTypeName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridType$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGridTypeName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGridTypeName() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGridTypeName) THEN PRINT "XuiGetGridTypeName() : error : (message != #GetGridTypeName)" : RETURN
'
	v0 = grid[grid].gridType
	r1$ = gridType$[grid]
END FUNCTION
'
'
' ############################
' #####  XuiGetGroup ()  #####
' ############################
'
FUNCTION  XuiGetGroup (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetGroup() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetGroup() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetGroup) THEN PRINT "XuiGetGroup() : error : (message != #GetGroup)" : RETURN
'
	v0 = grid[grid].group
END FUNCTION
'
'
' ###########################
' #####  XuiGetHelp ()  #####
' ###########################
'
FUNCTION  XuiGetHelp (grid, message, v0, v1, v2, v3, r0, r1$)
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
	SHARED	gridName$[]
	SHARED	GRID	grid[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, STRING)
'
	IF (r0 > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, @r0, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetHelp() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetHelp() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetHelp) THEN PRINT "XuiGetHelp() : error : (message != #GetHelp)" : RETURN
'
	r0	= 0
	XuiCallback (grid, #Help, v0, v1, v2, v3, @r0, 0)	' help callback
	IF (r0 = -1) THEN r1$ = "" : RETURN								' help was canceled?
	r1$	= help$[grid]
	IFZ r1$ THEN r1$ = ":" + gridName$[grid]
END FUNCTION
'
'
' ###############################
' #####  XuiGetHelpFile ()  #####
' ###############################
'
FUNCTION  XuiGetHelpFile (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	helpfile$
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetHelpFile() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetHelpFile() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetHelpFile) THEN PRINT "XuiGetHelpFile() : error : (message != #GetHelpFile)" : RETURN
'
	r1$	= helpfile$
END FUNCTION
'
'
' #################################
' #####  XuiGetHelpString ()  #####
' #################################
'
FUNCTION  XuiGetHelpString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetHelpString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetHelpString() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetHelpString) THEN PRINT "XuiGetHelpString() : error : (message != #GetHelpString)" : RETURN
'
	r1$	= help$[grid]
END FUNCTION
'
'
' ##################################
' #####  XuiGetHelpStrings ()  #####
' ##################################
'
FUNCTION  XuiGetHelpStrings (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetHelpStrings() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetHelpStrings() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetHelpStrings) THEN PRINT "XuiGetHelpStrings() : error : (message != #GetHelpStrings)" : RETURN
'
	IFZ kids[grid, ] THEN
		DIM r1$[0]
		r1$[0] = help$[grid]
	ELSE
		upper = UBOUND(kids[grid, ])
		DIM r1$[upper]
		FOR i = 0 TO upper
			XuiSendMessage (grid, #GetHelpString, 0, 0, 0, 0, i, @help$)
			ATTACH help$ TO r1$[i]
		NEXT i
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiGetHintString ()  #####
' #################################
'
FUNCTION  XuiGetHintString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	hint$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetHintString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetHintString() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetHintString) THEN PRINT "XuiGetHintString() : error : (message != #GetHintString)" : RETURN
'
	r1$	= hint$[grid]
END FUNCTION
'
'
' ############################
' #####  XuiGetImage ()  #####
' ############################
'
FUNCTION  XuiGetImage (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	image$[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetImage() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetImage() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetImage) THEN PRINT "XuiGetImage() : error : (message != #GetImage)" : RETURN
'
	r1$ = ""
	v0	= grid[grid].image
	v1	= grid[grid].imageAlign
	v2	= grid[grid].imageIndentX
	v3	= grid[grid].imageIndentY
	r1$	= image$[grid]
END FUNCTION
'
'
' ##################################
' #####  XuiGetImageCoords ()  #####
' ##################################
'
FUNCTION  XuiGetImageCoords (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetImageCoords() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetImageCoords() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetImageCoords) THEN PRINT "XuiGetImageCoords() : error : (message != #GetImageCoords)" : RETURN
'
	v0 = grid[grid].imageStartX
	v1 = grid[grid].imageStartY
	v2 = grid[grid].imageWidth
	v3 = grid[grid].imageHeight
END FUNCTION
'
'
' #############################
' #####  XuiGetIndent ()  #####
' #############################
'
FUNCTION  XuiGetIndent (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetIndent() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetIndent() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetIndent) THEN PRINT "XuiGetIndent() : error : (message != #GetIndent)" : RETURN
'
	v0 = grid[grid].indentLeft
	v1 = grid[grid].indentTop
	v2 = grid[grid].indentRight
	v3 = grid[grid].indentBottom
'
	r1 = 0
	XgrGetGridBorder (grid, @border, 0, 0, 0)
	XgrBorderNumberToWidth (border, @r1)
END FUNCTION
'
'
' ###########################
' #####  XuiGetInfo ()  #####
' ###########################
'
FUNCTION  XuiGetInfo (grid, message, v0, v1, v2, v3, kid, GRID r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetInfo() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetInfo() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetInfo) THEN PRINT "XuiGetInfo() : error : (message != #GetInfo" : RETURN
'
	r1 = grid[grid]									' r1 = gridinfo for grid
END FUNCTION
'
'
' ##############################
' #####  XuiGetJustify ()  #####
' ##############################
'
FUNCTION  XuiGetJustify (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetJustify() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetJustify() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetJustify) THEN PRINT "XuiGetJustify() : error : (message != #GetJustify)" : RETURN
'
	v0 = grid[grid].justify
	v1 = grid[grid].align
	v2 = grid[grid].indentLeft
	v3 = grid[grid].indentTop
'
	r1 = 0
	XgrGetGridBorder (grid, @border, 0, 0, 0)
	XgrBorderNumberToWidth (border, @r1)
END FUNCTION
'
'
' ####################################
' #####  XuiGetKeyboardFocus ()  #####
' ####################################
'
FUNCTION  XuiGetKeyboardFocus (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	keyboardFocusGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetKeyboardFocus() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetKeyboardFocus() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetKeyboardFocus) THEN PRINT "XuiGetKeyboardFocus() : error : (message != #GetKeyboardFocus)" : RETURN
'
	v0 = keyboardFocusGrid
END FUNCTION
'
'
' ########################################
' #####  XuiGetKeyboardFocusGrid ()  #####
' ########################################
'
FUNCTION  XuiGetKeyboardFocusGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetKeyboardFocusGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetKeyboardFocusGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetKeyboardFocusGrid) THEN PRINT "XuiGetKeyboardFocusGrid() : error : (message != #GetKeyboardFocusGrid)" : RETURN
'
	window = grid[grid].window
	XuiSendMessage (window, #WindowGetKeyboardFocusGrid, @v0, @v1, @v2, @v3, 0, 0)
END FUNCTION
'
'
' ###############################
' #####  XuiGetKidArray ()  #####
' ###############################
'
FUNCTION  XuiGetKidArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetKidArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetKidArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetKidArray) THEN PRINT "XuiGetKidArray() : error : (message != #GetKidArray)" : RETURN
'
	v0 = grid
	v1 = grid[grid].parent
	IFZ kids[grid, ] THEN
		DIM r1[0]
		r1[0] = grid
		v3 = 0
	ELSE
		upper = UBOUND (kids[grid, ])
		lastKid = 0
		DIM r1[upper]
		FOR i = 0 TO upper
			r1[i] = kids[grid,i]
			IF r1[i] THEN lastKid = i
		NEXT i
		v3 = lastKid
		REDIM r1[lastKid]
	END IF
END FUNCTION
'
'
' ################################
' #####  XuiGetKidNumber ()  #####
' ################################
'
FUNCTION  XuiGetKidNumber (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetKidNumber() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetKidNumber() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetKidNumber) THEN PRINT "XuiGetKidNumber() : error : (message != #GetKidNumber)" : RETURN
'
	v0 = -1
	parent = grid[grid].parent
	IF parent THEN
		IF kids[parent,] THEN
			FOR i = 1 TO UBOUND (kids[parent, ])
				IF (grid = kids[parent,i]) THEN v0 = i : EXIT FOR
			NEXT i
		END IF
	END IF
END FUNCTION
'
'
' ###########################
' #####  XuiGetKids ()  #####
' ###########################
'
FUNCTION  XuiGetKids (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetKids() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetKids() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetKids) THEN PRINT "XuiGetKids() : error : (message != #GetKids)" : RETURN
'
	v0 = grid : v1 = 0 : v2 = 0 : v3 = 0
	IFZ kids[grid,] THEN RETURN
	IF (grid != kids[grid,0]) THEN PRINT "XuiGetKids() : error : (grid != kids[grid,0]) : RETURN"
'
	upper = UBOUND (kids[grid,])
	IF (upper >= 1) THEN v1 = kids[grid,1]
	IF (upper >= 2) THEN v2 = kids[grid,2]
	IF (upper >= 3) THEN v3 = kids[grid,3]
	IF (upper >= 4) THEN r1 = kids[grid,4]
END FUNCTION
'
'
' ########################################
' #####  XuiGetCharacterMapArray ()  #####
' ########################################
'
FUNCTION  XuiGetCharacterMapArray (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetCharacterMapArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetCharacterMapArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetCharacterMapArray) THEN PRINT "XuiGetCharacterMapArray() : error : (message != #GetCharacterMapArray)" : RETURN
'
	DIM r1[]
	XgrGetGridCharacterMapArray (grid, @r1[])
END FUNCTION
'
'
' ########################################
' #####  XuiGetCharacterMapEntry ()  #####
' ########################################
'
FUNCTION  XuiGetCharacterMapEntry (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetCharacterMapEntry() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetCharacterMapEntry() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetCharacterMapEntry) THEN PRINT "XuiGetCharacterMapEntry() : error : (message != #GetCharacterMapEntry)" : RETURN
'
	DIM r1[]
	XgrGetGridCharacterMapArray (grid, @r1[])
'
	IFZ r1[] THEN v1 = v0 : RETURN					' character == character : "no mapping"
'
	upper = UBOUND (r1[])
	IF (upper < v0) THEN v1 = v0 : RETURN		' invalid character number in v0 : "no mapping"
	v1 = r1[v0]
END FUNCTION
'
'
' #################################  IMPORTANT NOTE:  The order of v0,v1,v2,v3
' #####  XuiGetMaxMinSize ()  #####  is chosen so XuiGetMaxMinSize() can stand in for
' #################################  #GetSmallestSize...  Don't change 'em !!!
'
FUNCTION  XuiGetMaxMinSize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetMaxMinSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMaxMinSize() : error : (grid > upperGrid)" : RETURN
	IF ((message != #GetMaxMinSize) AND (message != #GetSmallestSize)) THEN PRINT "XuiGetMaxMinSize() : error : (message != #GetMaxMinSize or #GetSmallestSize)" : RETURN
'
	v0 = grid[grid].maxWidth
	v1 = grid[grid].maxHeight
	v2 = grid[grid].minWidth
	v3 = grid[grid].minHeight
END FUNCTION
'
'
' #####################################
' #####  XuiGetMenuEntryArray ()  #####
' #####################################
'
FUNCTION  XuiGetMenuEntryArray (grid, message, v0, v1, v2, v3, kid, (r1, MENUENTRY r1[]))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED  MENUENTRY  menuentry[]
	MENUENTRY  me[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetMenuEntryArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMenuEntryArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetMenuEntryArray) THEN PRINT "XuiGetMenuEntryArray() : error : (message != #GetMenuEntryArray)" : RETURN
'
	IF menuentry[grid,] THEN
		upper = UBOUND (menuentry[grid,])
		DIM me[upper]
		FOR i = 0 TO upper
			me[i] = menuentry[grid,i]
		NEXT i
	END IF
	SWAP me[], r1[]
	DIM me[]
END FUNCTION
'
'
' ##################################
' #####  XuiGetMessageFunc ()  #####
' ##################################
'
FUNCTION  XuiGetMessageFunc (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	v1 = 0
	IF (grid <= 0) THEN PRINT "XuiGetMessageFunc() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageFunc() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetMessageFunc) THEN PRINT "XuiGetMessageFunc() : error : (message != #GetMessageFunc)" : RETURN
	IF (v0 < 0) THEN PRINT "XuiGetMessageFunc() : error : (v0 < 0 : Bad message number)" : RETURN
'
	gridType = grid[grid].gridType
	IF gridMessageFunc[grid, ] THEN
		upper = UBOUND (gridMessageFunc[grid, ])
		IF (v0 <= upper) THEN v1 = gridMessageFunc[grid,v0]
	ELSE
		upper = UBOUND (gridTypeMessageFunc[gridType, ])
		IF (v0 <= upper) THEN v1 = gridTypeMessageFunc[gridType,v0]
	END IF
'
' if message function is XuiPassOn() then get message function from kid #1
'
	g = grid
	DO WHILE (v1 = &XuiPassOn())
		XuiSendMessage (g, #GetGridNumber, @gg, @kid1, 0, 0, 0, 0)
		IF (g != gg) THEN PRINT "XuiGetMessageFunc() : error ::: (grid != GetGridNumber grid)"
		XuiSendMessage (kid1, #GetMessageFunc, v0, @v1, 0, 0, 0, 0)
		g = kid1
	LOOP
END FUNCTION
'
'
' #######################################
' #####  XuiGetMessageFuncArray ()  #####
' #######################################
'
FUNCTION  XuiGetMessageFuncArray (grid, message, v0, v1, v2, v3, r0, r1[])
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (grid <= 0) THEN PRINT "XuiGetMessageFuncArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageFuncArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetMessageFuncArray) THEN PRINT "XuiGetMessageFuncArray() : error : (message != #GetMessageFuncArray)" : RETURN
'
	DIM r1[]
	upper = 0
	gridType = grid[grid].gridType
	upper = UBOUND (gridMessageFunc[grid, ])
	IF (upper < 0) THEN upper = UBOUND (gridTypeMessageFunc[gridType, ])
'
	IF (upper >= 0) THEN
		DIM r1[upper]
		FOR i = 0 TO upper
			XuiSendMessage (grid, #GetMessageFunc, i, @func, 0, 0, 0, 0)
			r1[i] = func
		NEXT i
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiGetMessageSub ()  #####
' #################################
'
FUNCTION  XuiGetMessageSub (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	gridTypeMessageSub[]
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	messageSub[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	v1 = 0
	IF (grid <= 0) THEN PRINT "XuiGetMessageSub() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageSub() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetMessageSub) THEN PRINT "XuiGetMessageSub() : error : (message != #GetMessageSub)" : RETURN
	IF (v0 < 0) THEN PRINT "XuiGetMessageSub() : error : (Bad message number : v0 < 0)" : RETURN
'
	gridType = grid[grid].gridType
	upper = UBOUND (messageSub[gridType, ])
	IF (v0 < upper) THEN v1 = messageSub[gridType,v0]
'
' if no message sub and message function is XuiPassOn() then get message sub from kid #1
'
	g = grid
	DO UNTIL v1
		XuiSendMessage (g, #GetMessageFunc, v0, @func, 0, 0, 0, 0)
		IF (func != &XuiPassOn()) THEN EXIT DO
		XuiSendMessage (g, #GetGridNumber, @gg, @kid1, 0, 0, 0, 0)
		IF (g != gg) THEN PRINT "XuiGetMessageSub() : error ::: (grid != GetGridNumber grid)"
		XuiSendMessage (kid1, #GetMessageSub, v0, @v1, 0, 0, 0, 0)
		g = kid1
	LOOP
END FUNCTION
'
'
' ######################################
' #####  XuiGetMessageSubArray ()  #####
' ######################################
'
FUNCTION  XuiGetMessageSubArray (grid, message, v0, v1, v2, v3, r0, r1[])
	SHARED	messageSub[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (grid <= 0) THEN PRINT "XuiGetMessageSubArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageSubArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetMessageSubArray) THEN PRINT "XuiGetMessageSubArray() : error : (message != #GetMessageSubArray)" : RETURN
'
	DIM r1[]
	gridType = grid[grid].gridType
	upper = UBOUND (messageSub[gridType, ])
	IF upper THEN
		DIM r1[upper]
		FOR i = 1 TO upper
			XuiSendMessage (grid, #GetMessageSub, i, @subroutine, 0, 0, 0, 0)
			r1[i] = subroutine
		NEXT i
	END IF
END FUNCTION
'
'
' ################################
' #####  XuiGetModalInfo ()  #####  grid must be a windowGrid
' ################################
'
FUNCTION  XuiGetModalInfo (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	helpWindow
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	SHARED	modalUser,  modalSystem
	SHARED	modalGridUser,  modalWindowUser,  modalResponseUser
	SHARED	modalGridSystem,  modalWindowSystem,  modalResponseSystem
	SHARED	uv0,  uv1,  uv2,  uv3,  ur0,  ur1
	SHARED	sv0,  sv1,  sv2,  sv3,  sr0,  sr1
'
	IF (grid < 0) THEN PRINT "XuiGetModalInfo() : error : (grid < 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetModalInfo() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetModalInfo) THEN PRINT "XuiGetModalInfo() : error : (message != #GetModalInfo)" : RETURN
	window = grid[grid].window
	IFZ window THEN PRINT "XuiGetModalInfo() : error : (grid[grid].window = 0)" : RETURN
	gridWindow = grid[grid].gridWindow
	IF (window != gridWindow) THEN PRINT "XuiGetModalInfo() : error : (grid[grid].window != grid[grid].gridWindow)" : RETURN
	XgrGetGridWindow (grid, @win)
	IF (win != window) THEN PRINT "XuiGetModalInfo() : error : (grid[grid].gridWindow != XgrGetGridWindow())" : RETURN
	windowGrid = windowInfo[window].grid
	IF (grid != windowGrid) THEN PRINT "XuiGetModalInfo() : error : (grid != windowInfo[window].grid)" : RETURN
'
	who = XxxGuessWho()
	IF who THEN
		IF modalUser THEN PRINT "XuiGetModalInfo() : error : (user already modal)" : RETURN
		user = $$TRUE
		modalUser = $$TRUE
		modalGridUser = grid
		modalWindowUser = window
		modalResponseUser = $$FALSE
	ELSE
		IF modalSystem THEN PRINT "XuiGetModalInfo() : error : (system already modal)" : RETURN
		user = $$FALSE
		modalSystem = $$TRUE
		modalGridSystem = grid
		modalWindowSystem = window
		modalResponseSystem = $$FALSE
	END IF
'
	IF user THEN
		XuiGetCallback ( grid, #GetCallback, @utg, @utf, @utv2, @utv3, @utr0, @utr1)
		XuiSetCallback ( grid, #SetCallback, grid, &GetModalResponseUser(), -1, -1, -1, -1)
	ELSE
		XuiGetCallback ( grid, #GetCallback, @stg, @stf, @stv2, @stv3, @str0, @str1)
		XuiSetCallback ( grid, #SetCallback, grid, &GetModalResponseSystem(), -1, -1, -1, -1)
	END IF
'
	XuiSendMessage (window, #WindowDisplay, 0, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #SetModalWindow, window, grid, 0, 0, 0, 0)
'
	IF user THEN
		DO
'			XgrPeekMessage (@g, @m, @a, @b, @c, @d, @e, @f)
'			XgrMessageNumberToName (m, @m$)
'			PRINT g;; m$; a; b; c; d; e; f
			XgrProcessMessages (1)			' process messages until #Selection
			IF ##SOFTBREAK THEN EXIT DO
		LOOP UNTIL modalResponseUser
		v0 = uv0 : v1 = uv1 : v2 = uv2 : v3 = uv3 : r0 = ur0 : r1 = ur1
		XuiSetCallback ( grid, #SetCallback, utg, utf, utv2, utv3, utr0, utr1)
		modalResponseUser = $$FALSE
		modalWindowUser = $$FALSE
		modalGridUser = $$FALSE
		modalUser = $$FALSE
	ELSE
		DO
			XgrProcessMessages (1)			' process messages until #Selection
		LOOP UNTIL modalResponseSystem
		v0 = sv0 : v1 = sv1 : v2 = sv2 : v3 = sv3 : r0 = sr0 : r1 = sr1
		XuiSetCallback ( grid, #SetCallback, stg, stf, stv2, stv3, str0, str1)
		modalResponseSystem = $$FALSE
		modalWindowSystem = $$FALSE
		modalGridSystem = $$FALSE
		modalSystem = $$FALSE
	END IF
'
' make window non-modal, hide it, process Deselected/Selection messages
'
	IFZ (##SOFTBREAK AND user) THEN
		XuiSendMessage (grid, #SetModalWindow, 0, 0, 0, 0, 0, 0)
		XuiSendMessage (window, #WindowHide, 0, 0, 0, 0, 0, 0)
		XgrProcessMessages (-1)
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiGetModalWindow ()  #####  grid must be a windowGrid
' ##################################
'
FUNCTION  XuiGetModalWindow (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	WINDOW	windowInfo[]
	SHARED	GRID	grid[]
	SHARED	upperMessage
	SHARED	upperGrid
'
	IF (grid <= 0) THEN PRINT "XuiGetMessageSubArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageSubArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetModalWindow) THEN PRINT "XuiGetModalWindow() : error : (message != #GetModalWindow)" : RETURN
'
	XgrGetModalWindow (@v0)
	upperWindow = UBOUND (windowInfo[])
	IF ((v0 > 0) AND (v0 < upperWindow)) THEN v1 = windowInfo[v0].grid
END FUNCTION
'
'
' #############################
' #####  XuiGetParent ()  #####
' #############################
'
FUNCTION  XuiGetParent (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetParent() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetParent() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetParent) THEN PRINT "XuiGetParent() : error : (message != #GetParent)" : RETURN
'
	v1 = grid
	v0 = grid[grid].parent
	IFZ v1 THEN XgrGetGridParent (grid, @v1)
	IF kids[grid, ] THEN
		u = UBOUND (kids[grid, ])
		IF (u >= 1) THEN v2 = kids[grid, 1]
		IF (u >= 2) THEN v3 = kids[grid, 2]
		IF (u >= 3) THEN r1 = kids[grid, 3]
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiGetRedrawFlags ()  #####
' ##################################
'
FUNCTION  XuiGetRedrawFlags (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetRedrawFlags() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetRedrawFlags() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetRedrawFlags) THEN PRINT "XuiGetRedrawFlags() : error : (message != #GetRedrawFlags)" : RETURN
'
	v0 = grid[grid].redrawFlags
END FUNCTION
'
'
' ###########################
' #####  XuiGetSize ()  #####
' ###########################
'
FUNCTION  XuiGetSize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetSize() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetSize) THEN PRINT "XuiGetSize() : error : (message != #GetSize)" : RETURN
'
	XgrGetGridPositionAndSize (grid, @v0, @v1, @v2, @v3)
END FUNCTION
'
'
' ###################################
' #####  XuiGetSmallestSize ()  #####
' ###################################
'
FUNCTION  XuiGetSmallestSize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetSmallestSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetSmallestSize() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetSmallestSize) THEN PRINT "XuiGetSmallestSize() : error : (message != #GetSmallestSize)" : RETURN
'
	XuiSendMessage (grid, #GetMaxMinSize, @maxX, @maxY, @minX, @minY, 0, 0)
	XuiSendMessage (grid, #GetAlign, @align, @justify, 0, 0, 0, @borderWidth)
	XuiSendMessage (grid, #GetIndent, @indentLeft, @indentTop, @indentRight, @indentBottom, 0, 0)
	XuiSendMessage (grid, #GetRedrawFlags, @redraw, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #GetTexture, @texture, 0, 0, 0, 0, 0)
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	border = borderWidth + borderWidth
'
	IF (redraw AND $$RedrawTexture) THEN
		SELECT CASE texture
			CASE $$TextureNone		:	extra = 0
			CASE $$TextureLower1	:	extra = 1
			CASE $$TextureLower2	:	extra = 2
			CASE $$TextureLower4	:	extra = 4
			CASE $$TextureShadow	:	extra = 4
			CASE $$TextureRaise1	:	extra = 1
			CASE $$TextureRaise2	:	extra = 2
			CASE $$TextureRaise4	:	extra = 4
		END SELECT
	END IF
'
' text string
'
	IF (redraw AND $$RedrawTextString) THEN
		XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
		IFZ text$ THEN THEN text$ = "W"
		newline = INSTR (text$, "\n")
		IF newline THEN
			XstStringToStringArray (@text$, @text$[])
			XuiSendMessage (grid, #GetTextSpacing, @xgap, @ygap, 0, 0, 0, 0)
			lines = UBOUND (text$[]) + 1
			xgap = 0
			XgrGetTextArrayImageSize (font, @text$[], @w, @h, @width, @height, extra+xgap, extra+ygap)
		ELSE
			XgrGetTextImageSize (font, @text$, 0, 0, @width, @height, @gap, @space)
			IF extra THEN width = width + extra : height = height + extra
			IF gap THEN height = height - gap + 1
		END IF
		width = width + border + indentLeft + indentRight + 1
		height = height + border + indentTop + indentBottom + 1
	END IF
'
' text array
'
	IF (redraw AND $$RedrawTextArray) THEN
		XuiSendMessage (grid, #GetTextArray, 0, 0, 0, 0, 0, @text$[])
		XuiSendMessage (grid, #GetTextSpacing, @xgap, @ygap, 0, 0, 0, 0)
		IFZ text$[] THEN DIM text$[0] : text$[0] = "W"
		lines = UBOUND (text$[]) + 1
		xgap = 0
		XgrGetTextArrayImageSize (font, @text$[], @w, @h, @ww, @hh, extra+xgap, extra+ygap)
		ww = ww + border + indentLeft + indentRight + 1
		hh = hh + border + indentTop + indentBottom + 1
		IF (ww > width) THEN width = ww
		IF (ww > height) THEN height = hh
	END IF
'
' absolute minimums
'
	IF (width <= 4) THEN width = 4
	IF (width <= r1) THEN width = r1
	IF (height <= 4) THEN height = 4
	IF (height <= r1) THEN height = r1
	IF (width > maxX) THEN width = maxX
	IF (width < minX) THEN width = minX
	IF (height > maxY) THEN height = maxY
	IF (height < minY) THEN height = minY
'
' return values
'
	v0 = width
	v1 = height
	v2 = width
	v3 = height
END FUNCTION
'
'
' ############################
' #####  XuiGetState ()  #####
' ############################
'
FUNCTION  XuiGetState (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetState() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetState() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetState) THEN PRINT "XuiGetState() : error : (message != #GetState)" : RETURN
'
	XgrGetGridState (grid, @state)
	v0 = grid[grid].state
	v1 = grid[grid].keyboard
	v2 = grid[grid].mouse
	v3 = grid[grid].redraw
	r1 = state
END FUNCTION
'
'
' ############################
' #####  XuiGetStyle ()  #####
' ############################
'
FUNCTION  XuiGetStyle (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetStyle() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetStyle() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetStyle) THEN PRINT "XuiGetStyle() : error : (message != #GetStyle)" : RETURN
'
	v0 = grid[grid].style
	v1 = grid[grid].styleMax
END FUNCTION
'
'
' ###############################
' #####  XuiGetTabArray ()  #####
' ###############################
'
FUNCTION  XuiGetTabArray (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  tabArray[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTabArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTabArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTabArray) THEN PRINT "XuiGetTabArray() : error : (message != #GetTabArray)" : RETURN
'
	DIM r1[]
	v0 = grid[grid].tabWidth
'
	IF tabArray[grid,] THEN
		upper = UBOUND (tabArray[grid,])
		DIM r1[upper]
		FOR i = 0 TO upper
			r1[i] = tabArray[grid,i]
		NEXT i
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiGetTabWidth ()  #####
' ###############################
'
FUNCTION  XuiGetTabWidth (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	GRID  grid[]
	SHARED  tabArray[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTabWidth() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTabWidth() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTabWidth) THEN PRINT "XuiGetTabWidth() : error : (message != #GetTabWidth)" : RETURN
'
	r1 = 0
	v0 = grid[grid].tabWidth
	IF tabArray[grid,] THEN r1 = UBOUND (tabArray[grid,])
END FUNCTION
'
'
' ################################
' #####  XuiGetTextArray ()  #####
' ################################
'
FUNCTION  XuiGetTextArray (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTextArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextArray() : error : (grid > upperGrid)" : RETURN
	SELECT CASE message
		CASE #GetTextArray, #GetTextStrings, #GrabTextArray
		CASE ELSE:	PRINT "XuiGetTextArray() : error : (message != #GetTextArray or #GetTextStrings or #GrabTextStrings)" : RETURN
	END SELECT
'
	upper = UBOUND(textArray$[grid, ])
	IF (upper < 0) THEN DIM r1$[] : RETURN
	DIM r1$[upper]
	FOR i = 0 TO upper
		r1$[i] = textArray$[grid,i]
	NEXT i
END FUNCTION
'
'
' ####################################
' #####  XuiGetTextArrayLine ()  #####
' ####################################
'
FUNCTION  XuiGetTextArrayLine (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetTextArrayLine() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextArrayLine() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextArrayLine) THEN PRINT "XuiGetTextArrayLine() : error : (message != #GetTextArrayLine)" : RETURN
'
	upper = UBOUND(textArray$[grid, ])
	IF ((v0 < 0) OR (v0 > upper)) THEN v1 = -1 : v2 = -1 : v3 = -1 : r1$ = "" : RETURN
	r1$ = textArray$[grid,v0]
	v3 = upper
	v1 = v0
	v2 = 0
END FUNCTION
'
'
' #####################################
' #####  XuiGetTextArrayLines ()  #####
' #####################################
'
FUNCTION  XuiGetTextArrayLines (grid, message, v0, v1, v2, v3, kid, (r1, r1$[]))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetTextArrayLines() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextArrayLines() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextArrayLines) THEN PRINT "XuiGetTextArrayLines() : error : (message != #GetTextArrayLines)" : RETURN
'
	upper = UBOUND(textArray$[grid, ])
	IF ((v0 < 0) OR (v0 > upper) OR (v1 <= 0)) THEN v1 = -1 : v2 = -1 : v3 = upper : DIM r1$[] : RETURN
	last = v0 + v1 - 1
	IF (last > upper) THEN
		last = upper
		v1 = last - v0 + 1
	END IF
	i = 0
	top = v1 - 1
	DIM r1$[top]
	FOR j = v0 TO last
		r1$[i] = textArray$[grid,j]
		INC i
	NEXT j
	v3 = upper
END FUNCTION
'
'
' ###################################
' #####  XuiGetTextFilename ()  #####
' ###################################
'
FUNCTION  XuiGetTextFilename (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	sysTextFilename$
	SHARED	userTextFilename$
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTextFilename() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextFilename() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextFilename) THEN PRINT "XuiGetTextFilename() : error : (message != #GetTextFilename)" : RETURN
'
	IF ##WHOMASK THEN
		r1$ = userTextFilename$
	ELSE
		r1$ = sysTextFilename$
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiGetTextSpacing ()  #####
' ##################################
'
FUNCTION  XuiGetTextSpacing (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTextSpacing() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextSpacing() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextSpacing) THEN PRINT "XuiGetTextSpacing() : error : (message != #GetTextSpacing)" : RETURN
'
	v0 = grid[grid].xgap
	v1 = grid[grid].ygap
END FUNCTION
'
'
' #################################
' #####  XuiGetTextString ()  #####
' #################################
'
FUNCTION  XuiGetTextString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTextString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextString() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextString) THEN PRINT "XuiGetTextString() : error : (message != #GetTextString)" : RETURN
'
	r1$ = textString$[grid]
	v3 = UBOUND (r1$)
END FUNCTION
'
'
' ##################################
' #####  XuiGetTextStrings ()  #####
' ##################################
'
FUNCTION  XuiGetTextStrings (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetTextStrings() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTextStrings() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTextStrings) THEN PRINT "XuiGetTextStrings() : error : (message != #GetTextStrings)" : RETURN
'
	IFZ kids[grid, ] THEN
		v3 = 0
		DIM r1$[v3]
		r1$[0] = textString$[grid]
	ELSE
		v3 = UBOUND(kids[grid, ])
		DIM r1$[v3]
		FOR i = 0 TO v3
			XuiSendMessage (grid, #GetTextString, 0, 0, 0, 0, i, @text$)
			ATTACH text$ TO r1$[i]
		NEXT i
	END IF
END FUNCTION
'
'
' ##############################
' #####  XuiGetTexture ()  #####
' ##############################
'
FUNCTION  XuiGetTexture (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetTexture() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTexture() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTexture) THEN PRINT "XuiGetTexture() : error : (message != #GetTexture)" : RETURN
'
	v0 = grid[grid].texture
END FUNCTION
'
'
' ############################
' #####  XuiGetTimer ()  #####
' ############################
'
FUNCTION  XuiGetTimer (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetTimer() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetTimer() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetTimer) THEN PRINT "XuiGetTimer() : error : (message != #GetTimer)" : RETURN
'
	v0 = grid[grid].timer
END FUNCTION
'
'
' ############################
' #####  XuiGetValue ()  #####  r1 = offset to 1st value to return
' ############################
'
FUNCTION  XuiGetValue (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetValue() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetValue() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetValue) THEN PRINT "XuiGetValue() : error : (message != #GetValue)" : RETURN
'
	i = r1
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
'
	IF values[grid, ] THEN
		upper = UBOUND (values[grid, ])
		IF (upper >= (i+0)) THEN v0 = values[grid, i+0]
		IF (upper >= (i+1)) THEN v1 = values[grid, i+1]
		IF (upper >= (i+2)) THEN v2 = values[grid, i+2]
		IF (upper >= (i+3)) THEN v3 = values[grid, i+3]
	END IF
END FUNCTION
'
'
' #############################
' #####  XuiGetValues ()  #####
' #############################
'
FUNCTION  XuiGetValues (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGetValues() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetValues() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetValues) THEN PRINT "XuiGetValues() : error : (message != #GetValues)" : RETURN
'
	i = r1
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r1 = 0
'
	IF values[grid, ] THEN
		upper = UBOUND (values[grid, ])
		IF (upper >= (i+0)) THEN v0 = values[grid, i+0]
		IF (upper >= (i+1)) THEN v1 = values[grid, i+1]
		IF (upper >= (i+2)) THEN v2 = values[grid, i+2]
		IF (upper >= (i+3)) THEN v3 = values[grid, i+3]
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiGetValueArray ()  #####
' #################################
'
FUNCTION  XuiGetValueArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	values[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetValueArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetValueArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetValueArray) THEN PRINT "XuiGetValueArray() : error : (message != #GetValueArray)" : RETURN
'
	IFZ values[grid,] THEN
		DIM r1[]
		v3 = -1
		RETURN
	END IF
'
	atype = TYPE (values[grid, ])
	ok = (atype = $$SLONG) OR (atype = $$ULONG) OR (atype = $$XLONG)
	IFZ ok THEN
		PRINT "XuiGetValueArray() : error : (value[grid,] is not an SLONG/ULONG/XLONG array)"; atype
		GOSUB ReportFrames
		RETURN
	END IF
'
	v3 = UBOUND (values[grid, ])
	IF (v3 < 0) THEN DIM r1[] : RETURN
	DIM r1[v3]
	FOR i = 0 TO v3
		r1[i] = values[grid,i]
	NEXT i
	RETURN
'
' *****  ReportFrames  *****   Debug Information
'
SUB ReportFrames
	XxxGetEbpEsp (@ebp, @esp)
	PRINT "  ebp = "; HEX$(  ebp,8); "    esp = "; HEX$(  esp,8)
	xebp = XLONGAT (ebp) : xesp = XLONGAT (ebp,4)
	PRINT " xebp = "; HEX$( xebp,8); "   xesp = "; HEX$( xesp,8)
	xxebp = XLONGAT (xebp) : xxesp = XLONGAT (xebp,4)
	PRINT "xxebp = "; HEX$(xxebp,8); "  xxesp = "; HEX$(xxesp,8)
END SUB
END FUNCTION
'
'
' #############################
' #####  XuiGetWindow ()  #####
' #############################
'
FUNCTION  XuiGetWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindow) THEN PRINT "XuiGetWindow() : error : (message != #GetWindow)" : RETURN
'
	v0 = 0
	window = grid[grid].window
	IF (window <= 0) THEN
		PRINT "GetWindow() : error ::: (grid[grid].window <= 0)"
		XgrGetGridWindow (grid, @window)
		IF (window <= 0) THEN PRINT "XuiGetWindow() : error : (XgrGetGridWindow(grid,@window) = 0)" : RETURN
	END IF
	v0 = window
	v1 = windowInfo[window].windowType OR windowInfo[window].parent
	v2 = windowInfo[window].func
	v3 = windowInfo[window].grid
	r1 = windowInfo[window].keyboardFocusGrid
END FUNCTION
'
'
' #####################################
' #####  XuiGetWindowFunction ()  #####
' #####################################
'
FUNCTION  XuiGetWindowFunction (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindowFunction() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindowFunction() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindowFunction) THEN PRINT "XuiGetWindowFunction() : error : (message != #GetWindowFunction)" : RETURN
'
	window = grid[grid].window
	v0 = windowInfo[window].func
END FUNCTION
'
'
' #################################
' #####  XuiGetWindowGrid ()  #####
' #################################
'
FUNCTION  XuiGetWindowGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindowGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindowGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindowGrid) THEN PRINT "XuiGetWindowGrid() : error : (message != #GetWindowGrid)" : RETURN
'
	v0 = 0
	window = grid[grid].window
	IF (window <= 0) THEN
		PRINT "GetWindow() : error ::: (grid[grid].window <= 0)"
		XgrGetGridWindow (grid, @window)
		IF (window <= 0) THEN PRINT "XuiGetWindow() : error : (XgrGetGridWindow(grid,@window) = 0)" : RETURN
	END IF
	v0 = windowInfo[window].grid
END FUNCTION
'
'
' #################################
' #####  XuiGetWindowIcon ()  #####
' #################################
'
FUNCTION  XuiGetWindowIcon (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindowIcon() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindowIcon() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindowIcon) THEN PRINT "XuiGetWindowIcon() : error : (message != #GetWindowIcon)" : RETURN
'
	r1$ = ""
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiGetWindowIcon() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowGetIcon, @v0, @v1, @v2, @v3, 0, 0)
	IF (v0 < 0) THEN v0 = 0
	XgrIconNumberToName (v0, @r1$)
END FUNCTION
'
'
' #################################
' #####  XuiGetWindowSize ()  #####
' #################################
'
FUNCTION  XuiGetWindowSize (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindowSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindowSize() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindowSize) THEN PRINT "XuiGetWindowSize() : error : (message != #GetWindowSize)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiGetWindowSize() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowGetSize, @v0, @v1, @v2, @v3, 0, @r1)
END FUNCTION
'
'
' ##################################
' #####  XuiGetWindowTitle ()  #####
' ##################################
'
FUNCTION  XuiGetWindowTitle (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGetWindowTitle() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetWindowTitle() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetWindowTitle) THEN PRINT "XuiGetWindowTitle() : error : (message != #GetWindowTitle)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN r1$ = "" : PRINT "XuiGetWindowTitle() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowGetTitle, 0, 0, 0, 0, 0, @r1$)
END FUNCTION
'
'
' #################################
' #####  XuiGotKeyboardFocus  #####
' #################################
'
FUNCTION  XuiGotKeyboardFocus (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGotKeyboardFocus() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGotKeyboardFocus() : error : (grid > upperGrid)" : RETURN
	IF (message != #GotKeyboardFocus) THEN PRINT "XuiGotKeyboardFocus() : error : (message != #GotKeyboardFocus)" : RETURN
'
	grid[grid].focus = $$TRUE
	IF (grid[grid].redrawFlags AND $$RedrawFocus) THEN XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' #############################
' #####  XuiGrabArray ()  #####
' #############################
'
FUNCTION  XuiGrabArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	array[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGrabArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGrabArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GrabArray) THEN PRINT "XuiGrabArray() : error : (message != #GrabArray)" : RETURN
'
	IF r1[] THEN DIM r1[]
	ATTACH array[grid, ] TO r1[]
	v3 = UBOUND (r1[])
END FUNCTION
'
'
' #################################
' #####  XuiGrabTextArray ()  #####
' #################################
'
FUNCTION  XuiGrabTextArray (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGrabTextArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGrabTextArray() : error : (grid > upperGrid)" : RETURN
	SELECT CASE message
		CASE #GetTextArray, #GetTextStrings, #GrabTextArray
		CASE ELSE:	PRINT "XuiGrabTextArray() : error : (message != #GrabTextArray or #GetTextArray or #GetTextStrings)" : RETURN
	END SELECT
'
	IF r1$[] THEN DIM r1$[]
	ATTACH textArray$[grid, ] TO r1$[]
	v3 = UBOUND (r1$[])
END FUNCTION
'
'
' ##################################
' #####  XuiGrabTextString ()  #####
' ##################################
'
FUNCTION  XuiGrabTextString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiGrabTextString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGrabTextString() : error : (grid > upperGrid)" : RETURN
	IF (message != #GrabTextString) THEN PRINT "XuiGrabTextString() : error : (message != #GrabTextString)" : RETURN
'
	r1$ = ""
	ATTACH textString$[grid] TO r1$
	v3 = UBOUND (r1$)
END FUNCTION
'
'
' ##################################
' #####  XuiGrabValueArray ()  #####
' ##################################
'
FUNCTION  XuiGrabValueArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiGrabValueArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGrabValueArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #GrabValueArray) THEN PRINT "XuiGrabValueArray() : error : (message != GrabValueArray)" : RETURN
'
	IF r1[] THEN DIM r1[]
	ATTACH values[grid, ] TO r1[]
	v3 = UBOUND (r1[])
END FUNCTION
'
'
' ##########################
' #####  XuiHidden ()  #####
' ##########################
'
FUNCTION  XuiHidden (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiHidden() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiHidden() : error : (grid > upperGrid)" : RETURN
	IF (message != #Hidden) THEN PRINT "XuiHidden() : error : (message != #Hidden)" : RETURN
'
	abort = 0
	XuiCallback (grid, message, v0, v1, v2, v3, @abort, r1)
'	PRINT "XuiHidden() : sent callback : "; grid, message
END FUNCTION
'
'
' ##############################
' #####  XuiHideWindow ()  #####
' ##############################
'
FUNCTION  XuiHideWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiHideWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiHideWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #HideWindow) THEN PRINT "XuiHideWindow() : error : (message != #HideWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiHideWindow() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowHide, v0, v1, v2, v3, 0, 0)
	IFZ func THEN PRINT "XuiHideWindow() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ##############################
' #####  XuiInitialize ()  #####
' ##############################
'
FUNCTION  XuiInitialize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiInitialize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiInitialize() : error : (grid > upperGrid)" : RETURN
	IF (message != #Initialize) THEN PRINT "XuiInitialize() : error : (message != #Initialize)" : RETURN
'
	XuiCallback (grid, #Initialize, @v0, @v1, @v2, @v3, 0, @r1)
END FUNCTION
'
'
' #########################################
' #####  XuiKeyboardFocusBackward ()  #####
' #########################################
'
FUNCTION  XuiKeyboardFocusBackward (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiKeyboardFocusBackward() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiKeyboardFocusBackward() : error : (grid > upperGrid)" : RETURN
	IF (message != #KeyboardFocusBackward) THEN PRINT "XuiKeyboardFocusBackward() : error : (message != #KeyboardFocusBackward)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiKeyboardFocusBackward() : error : (grid[grid].window <= 0)" : RETURN
'
	XuiSendMessage (window, #WindowGetKeyboardFocusGrid, @fg, 0, 0, 0, 0, 0)
	IF (fg <= 0) THEN fg = grid
'
	DO
		kid = 0
		parent = grid[fg].parent
		IF (parent <= 0) THEN parent = fg			' no parent - look thru kids
		IFZ kids[parent, ] THEN RETURN				' no kids - can't move focus
		upper = UBOUND (kids[parent, ])
'
		found = $$FALSE
		FOR i = 0 TO upper
			g = kids[parent,i]
			IF (g = fg) THEN kid = i : found = $$TRUE : EXIT FOR
		NEXT i
		IFZ found THEN PRINT "XuiKeyboardFocusBackward() : error : (kid not in parents kids[])" : RETURN
'
		i = kid
		DO
			DEC i
			IF (i < 1) THEN i = upper						' from first kid to last kid
			IF (i = kid) THEN EXIT DO						' back around to same kid
			k = kids[parent,i]									' k = kid grid number
			IF k THEN
				focus = grid[k].can AND $$Focus		' can kid focus ???
				IF focus THEN
					XuiSendMessage (k, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
					v0 = k
					RETURN
				END IF
			END IF
		LOOP UNTIL (i = kid)
'
		fg = parent
	LOOP
END FUNCTION
'
'
' ########################################
' #####  XuiKeyboardFocusForward ()  #####
' ########################################
'
FUNCTION  XuiKeyboardFocusForward (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiKeyboardFocusForward() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiKeyboardFocusForward() : error : (grid > upperGrid)" : RETURN
	IF (message != #KeyboardFocusForward) THEN PRINT "XuiKeyboardFocusForward() : error : (message != #KeyboardFocusForward)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiKeyboardFocusForward() : error : (grid[grid].window <= 0)" : RETURN
'
	XuiSendMessage (window, #WindowGetKeyboardFocusGrid, @fg, 0, 0, 0, 0, 0)
	IF (fg <= 0) THEN fg = grid
'
	DO
		kid = 0
		parent = grid[fg].parent
		IF (parent <= 0) THEN parent = fg			' no parent - look thru kids
		IFZ kids[parent, ] THEN RETURN				' no kids - can't move focus
		upper = UBOUND (kids[parent, ])
'
		found = $$FALSE
		FOR i = 0 TO upper
			g = kids[parent,i]
			IF (g = fg) THEN kid = i : found = $$TRUE : EXIT FOR
		NEXT i
		IFZ found THEN PRINT "XuiKeyboardFocusForward() : error : (kid not in parents kids[])" : RETURN
'
		i = kid
		DO
			INC i
			IF (i > upper) THEN i = 1						' from last kid to first kid
			IF (i = kid) THEN EXIT DO						' back around to same kid
			k = kids[parent,i]									' k = kid grid number
			IF k THEN
				focus = grid[k].can AND $$Focus		' can kid focus ???
				IF focus THEN
					XuiSendMessage (k, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
					v0 = k
					RETURN
				END IF
			END IF
		LOOP UNTIL (i = kid)
'
		fg = parent
	LOOP
END FUNCTION
'
'
' ##################################
' #####  XuiLostKeyboardFocus  #####
' ##################################
'
FUNCTION  XuiLostKeyboardFocus (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiLostKeyboardFocus() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiLostKeyboardFocus() : error : (grid > upperGrid)" : RETURN
	IF (message != #LostKeyboardFocus) THEN PRINT "XuiLostKeyboardFocus() : error : (message != #LostKeyboardFocus)" : RETURN
'
	grid[grid].focus	= $$FALSE
	IF (grid[grid].redrawFlags AND $$RedrawFocus) THEN XuiSendMessage (grid, #Redraw, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' #############################
' #####  XuiMaximized ()  #####
' #############################
'
FUNCTION  XuiMaximized (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMaximized() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMaximized() : error : (grid > upperGrid)" : RETURN
	IF (message != #Maximized) THEN PRINT "XuiMaximized() : error : (message != #Maximized)" : RETURN
'
	abort = 0
	XuiCallback (grid, message, v0, v1, v2, v3, @abort, r1)
'	PRINT "XuiMaximized() : sent callback : "; grid, message
END FUNCTION
'
'
' ##################################
' #####  XuiMaximizeWindow ()  #####
' ##################################
'
FUNCTION  XuiMaximizeWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMaximizeWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMaximizeWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #MaximizeWindow) THEN PRINT "XuiMaximizeWindow() : error : (message != #MaximizeWindow)" : RETURN
'
	window = grid[grid].window
	func = windowInfo[window].func
	@func (window, #WindowMaximize, 0, 0, 0, 0, 0, 0 )
END FUNCTION
'
'
' #############################
' #####  XuiMinimized ()  #####
' #############################
'
FUNCTION  XuiMinimized (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMinimized() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMinimized() : error : (grid > upperGrid)" : RETURN
	IF (message != #Minimized) THEN PRINT "XuiMinimized() : error : (message != #Minimized)" : RETURN
'
	abort = 0
	XuiCallback (grid, message, v0, v1, v2, v3, @abort, r1)
'	PRINT "XuiMinimized() : sent callback : "; grid, message
END FUNCTION
'
'
' ##################################
' #####  XuiMinimizeWindow ()  #####
' ##################################
'
FUNCTION  XuiMinimizeWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMinimizeWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMinimizeWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #MinimizeWindow) THEN PRINT "XuiMinimizeWindow() : error : (message != #MinimizeWindow)" : RETURN
'
	window = grid[grid].window
	func = windowInfo[window].func
	@func (window, #WindowMinimize, 0, 0, 0, 0, 0, 0 )
END FUNCTION
'
'
' ##################################
' #####  XuiMonitorContext ()  #####
' ##################################
'
FUNCTION  XuiMonitorContext (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMonitorContext() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMonitorContext() : error : (grid > upperGrid)" : RETURN
	IF (message != #MonitorContext) THEN PRINT "XuiMonitorContext() : error : (message != #MonitorContext)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiMonitorContext() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowMonitorContext, v0, v1, v2, v3, 0, r1)
	IFZ func THEN PRINT "XuiMonitorContext() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ###############################
' #####  XuiMonitorHelp ()  #####
' ###############################
'
FUNCTION  XuiMonitorHelp (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMonitorHelp() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMonitorHelp() : error : (grid > upperGrid)" : RETURN
	IF (message != #MonitorHelp) THEN PRINT "XuiMonitorHelp() : error : (message != #MonitorHelp)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN
		PRINT "XuiMonitorHelp() : error : (grid[grid].window <= 0)" : RETURN
	END IF
	func = windowInfo[window].func
	@func (window, #WindowMonitorHelp, v0, v1, v2, v3, 0, r1)
	IFZ func THEN PRINT "XuiMonitorHelp() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ###################################
' #####  XuiMonitorKeyboard ()  #####
' ###################################
'
FUNCTION  XuiMonitorKeyboard (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMonitorKeyboard() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMonitorKeyboard() : error : (grid > upperGrid)" : RETURN
	IF (message != #MonitorKeyboard) THEN PRINT "XuiMonitorKeyboard() : error : (message != #MonitorKeyboard)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiMonitorKeyboard() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowMonitorKeyboard, v0, v1, v2, v3, 0, r1)
	IFZ func THEN PRINT "XuiMonitorKeyboard() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ################################
' #####  XuiMonitorMouse ()  #####
' ################################
'
FUNCTION  XuiMonitorMouse (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMonitorMouse() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMonitorMouse() : error : (grid > upperGrid)" : RETURN
	IF (message != #MonitorMouse) THEN PRINT "XuiMonitorMouse() : error : (message != #MonitorMouse)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiMonitorMouse() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowMonitorMouse, v0, v1, v2, v3, 0, r1)
	IFZ func THEN PRINT "XuiMonitorMouse() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' #############################################
' #####  XuiMouseDownSetKeyboardFocus ()  #####
' #############################################
'
FUNCTION  XuiMouseDownSetKeyboardFocus (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	selectedWindow
	SHARED	keyboardFocusGrid
	SHARED	WINDOW	windowInfo[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMouseDownSetKeyboardFocus() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMouseDownSetKeyboardFocus() : error : (grid > upperGrid)" : RETURN
	IF (message != #MouseDown) THEN PRINT "XuiMouseDownSetKeyboardFocus() : error : (message != #MouseDown)" : RETURN
'
	XuiSendMessage (grid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
END FUNCTION
'
'
' ##############################
' #####  XuiMouseEnter ()  #####
' ##############################
'
FUNCTION  XuiMouseEnter (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	oldCursor
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiMouseEnter() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiMouseEnter() : error : (grid > upperGrid)" : RETURN
	IF (message != #MouseEnter) THEN PRINT "XuiMouseEnter() : error : (message != #MouseEnter)" : RETURN
	IFZ grid[grid].grid THEN RETURN
'
	cursor = grid[grid].cursor
	IF (cursor >= 0) THEN XgrSetCursor (cursor, @oldCursor)
END FUNCTION
'
'
' #############################
' #####  XuiPokeArray ()  #####
' #############################
'
FUNCTION  XuiPokeArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	array[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiPokeArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPokeArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #PokeArray) THEN PRINT "XuiPokeArray() : error : (message != #PokeTextArray)" : RETURN
'
	SWAP r1[], array[grid, ]
	DIM r1[]
END FUNCTION
'
'
' #################################
' #####  XuiPokeTextArray ()  #####
' #################################
'
FUNCTION  XuiPokeTextArray (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiPokeTextArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPokeTextArray() : error : (grid > upperGrid)" : RETURN
	IF ((message != #PokeTextArray) AND (message != #SetTextArray)) THEN PRINT "XuiPokeTextArray() : error : (message != #PokeTextArray or #SetTextArray)" : RETURN
'
	ATTACH textArray$[grid, ] TO temp$[]
	ATTACH r1$[] TO textArray$[grid, ]
	DIM temp$[]
END FUNCTION
'
'
' ##################################
' #####  XuiPokeTextString ()  #####
' ##################################
'
FUNCTION  XuiPokeTextString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiPokeTextString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPokeTextString() : error : (grid > upperGrid)" : RETURN
	IF (message != #PokeTextString) THEN PRINT "XuiPokeTextString() : error : (message != #PokeTextString)" : RETURN
'
	ATTACH textString$[grid] TO temp$
	ATTACH r1$ TO textString$[grid]
END FUNCTION
'
'
' ##################################
' #####  XuiPokeValueArray ()  #####
' ##################################
'
FUNCTION  XuiPokeValueArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiPokeValueArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiPokeValueArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #PokeValueArray) THEN PRINT "XuiPokeValueArray() : error : (message != #PokeValueArray)" : RETURN
'
	ATTACH values[grid, ] TO temp[]
	ATTACH r1[] TO values[grid, ]
	DIM temp[]
END FUNCTION
'
'
' ##########################  IF v2 = 0 (width) or v3 = 0 (height) then
' #####  XuiRedraw ()  #####  unconditionally perform the redraw, as when
' ##########################  the whole window needs to be redrawn.
'
FUNCTION  XuiRedraw (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiRedraw() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiRedraw() : error : (grid > upperGrid)" : RETURN
	IF (message != #Redraw) THEN PRINT "XuiRedraw() : error : (message != #Redraw)" : RETURN
'
	IFZ grid[grid].state THEN RETURN
	IFZ grid[grid].redraw THEN RETURN
	XuiSendMessage (grid, #RedrawGrid, 0, 0, 0, 0, 0, r1)
	XuiSendToKids (grid, message, 0, 0, 0, 0, 0, -1)
END FUNCTION
'
'
' ##############################
' #####  XuiRedrawGrid ()  #####
' ##############################
'
FUNCTION  XuiRedrawGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
	SHARED	textString$[]
	SHARED  sysTextFilename$
	SHARED  userTextFilename$
	SHARED	keyboardFocusGrid
	SHARED	image$[]
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiRedrawGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiRedrawGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #RedrawGrid) THEN PRINT "XuiRedrawGrid() : error : (message != #RedrawGrid)" : RETURN
'
	IFZ grid[grid].state THEN RETURN
	IFZ grid[grid].redraw THEN RETURN
	IFZ grid[grid].redrawFlags THEN RETURN
'
	XgrGetGridBoxLocal (grid, @gridLeft, @gridTop, @gridRight, @gridBottom)
	IF ((v2 > 0) AND (v3 > 0)) THEN
		redrawLeft = v0
		redrawTop = v1
		redrawRight = v0 + v2 - 1
		redrawBottom = v1 + v3 - 1
'		IF (redrawTop > gridBottom) THEN RETURN
'		IF (redrawLeft > gridRight) THEN RETURN
'		IF (redrawRight < gridLeft) THEN RETURN
'		IF (redrawBottom < gridTop) THEN RETURN
	END IF
'
	xgap		= grid[grid].xgap					' shrink/expand character spacing
	ygap		= grid[grid].ygap					' shrink/expand line spacing
	xgap		= 0												' xgap not yet supported
	window	= grid[grid].window
	parent	= grid[grid].parent
	indentX	= grid[grid].indentLeft
	indentY	= grid[grid].indentTop
	indentL	= grid[grid].indentLeft
	indentT	= grid[grid].indentTop
	indentR	= grid[grid].indentRight
	indentB	= grid[grid].indentBottom
	redraw	= grid[grid].redrawFlags
	clip		= redraw AND $$RedrawClip
	focus		= redraw AND $$RedrawFocus
	clear		= redraw AND $$RedrawClear
	buffer	= redraw AND $$RedrawBuffer
	image		= redraw AND $$RedrawImage
	border	= redraw AND $$RedrawBorder
	texture	= redraw AND $$RedrawTexture
	array		= redraw AND $$RedrawTextArray
	text		= redraw AND $$RedrawTextString
	accent	= redraw AND $$RedrawTextAccent
	dull		= redraw AND $$RedrawTextDull
	graph		= windowInfo[window].graph
	graph		= (graph = grid)
	clipper	= $$FALSE
'
	IF (focus AND (grid = keyboardFocusGrid)) THEN
		bc = grid[grid].focusBackground
		dc = grid[grid].focusDrawing
		lc = grid[grid].focusLowlight
		hc = grid[grid].focusHighlight
		zc = grid[grid].focusDull
		ac = grid[grid].focusAccent
		lt = grid[grid].focusLowtext
		ht = grid[grid].focusHightext
		XgrGetGridColors (grid, @zbc, @zdc, @zlc, @zhc, @zzc, @zac, @zlt, @zht)
		XgrSetGridColors (grid, bc, dc, lc, hc, zc, ac, lt, ht)
		focusColors = $$TRUE
	ELSE
		bc = grid[grid].backgroundColor
		dc = grid[grid].drawingColor
		lc = grid[grid].lowlightColor
		hc = grid[grid].highlightColor
		zc = grid[grid].dullColor
		ac = grid[grid].accentColor
		lt = grid[grid].lowtextColor
		ht = grid[grid].hightextColor
		focusColors = $$FALSE
	END IF
'
	IF buffer THEN XgrGetGridBuffer (grid, @buffer, @bx, @by)
	IF texture THEN texture = grid[grid].texture
	IF border THEN border = grid[grid].border
	IF image THEN image = grid[grid].image
	IF clear THEN GOSUB ClearBackground
	IF buffer THEN XgrRefreshGrid (grid)
	IF graph THEN GOSUB DrawGraphDots
	XgrBorderNumberToWidth (border, @bw)
'
	IF clip THEN
		XgrGetGridClip (grid, @check)
		IFZ check THEN
			XgrSetGridClip (grid, grid)
			clipper = $$TRUE
		END IF
	END IF
'
	IF image THEN
		XgrGetGridClip (grid, @check)
		IFZ check THEN
			clipper	= $$TRUE
			alignX	= $$AlignLeft						' ??? huh ???
			XgrSetGridClip (grid, grid)
		END IF
	END IF
'
	IF image THEN
		inX = grid[grid].imageIndentX
		inY = grid[grid].imageIndentY
		imX = grid[grid].imageStartX
		imY = grid[grid].imageStartY
		imW = grid[grid].imageWidth
		imH = grid[grid].imageHeight
'		XgrMoveTo (grid, inX, inY)
'		XgrCopyImage (grid, image)
		XgrDrawImage (grid, image, imX, imY, imX+imW-1, imY+imH-1, inX, inY)
	END IF
'
	IF (text OR array) THEN
		align = grid[grid].align
		SELECT CASE align
			CASE $$AlignUpperLeft			: alignX = $$AlignLeft 		: alignY = $$AlignUpper
			CASE $$AlignUpperCenter		: alignX = $$AlignCenter	: alignY = $$AlignUpper
			CASE $$AlignUpperRight		: alignX = $$AlignRight		: alignY = $$AlignUpper
			CASE $$AlignMiddleLeft		: alignX = $$AlignLeft		: alignY = $$AlignMiddle
			CASE $$AlignMiddleCenter	: alignX = $$AlignCenter	: alignY = $$AlignMiddle
			CASE $$AlignMiddleRight		: alignX = $$AlignRight		: alignY = $$AlignMiddle
			CASE $$AlignLowerLeft			: alignX = $$AlignLeft		: alignY = $$AlignLower
			CASE $$AlignLowerCenter		: alignX = $$AlignCenter	: alignY = $$AlignLower
			CASE $$AlignLowerRight		: alignX = $$AlignRight		: alignY = $$AlignLower
			CASE ELSE									: alignX = $$AlignCenter	: alignY = $$AlignMiddle
		END SELECT
		justify	= grid[grid].justify
		inL = indentL + bw
		inT = indentT + bw
		inR = indentR + bw
		inB = indentB + bw
		XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
		XgrGetFontInfo (font, @font$, @size, @weight, @italic, @angle)
		XgrGetGridBoxLocal (grid, @x1, @y1, @x2, @y2)
		gridWidth = x2 - x1 + 1
		gridHeight = y2 - y1 + 1
	END IF
'
	IF text THEN
		text$ = textString$[grid]
		IF text$ THEN
			IF (text${0} = 0xFF) THEN
				IF (text${1} = 0xFF) THEN GOSUB FilenameText
			END IF
			multi = INSTR (text$, "\n")
			IF (multi OR angle) THEN
				XstStringToStringArray (@text$, @text$[])
				GOSUB DrawStringArray
				DIM text$[]
			ELSE
				GOSUB DrawString
			END IF
		END IF
	END IF
'
	IF array THEN
		IF textArray$[grid,] THEN
			ATTACH textArray$[grid,] TO text$[]
			GOSUB DrawStringArray
			ATTACH text$[] TO textArray$[grid,]
		END IF
	END IF
'
	IF clipper THEN XgrSetGridClip (grid, 0)
	XgrDrawGridBorder (grid, -1)
	IF focusColors THEN XgrSetGridColors (grid, zbc, zdc, zlc, zhc, zzc, zac, zlt, zht)
	RETURN
'
'
' *****  FilenameText  *****
'
SUB FilenameText
	file$ = ""
	entry$ = ""
	colon = INSTR (text$, ":")
	SELECT CASE colon
		CASE 0		: file$ = MID$ (text$, 3)
		CASE 1		: entry$ = MID$ (text$, colon+1)
		CASE ELSE	:	rcolon = RINSTR (text$, ":")
								IF (colon = rcolon) THEN
									char = text${colon-1}
									IF ((char = '/') OR (char = '\\')) THEN colon = 0
								ELSE
									colon = rcolon
								END IF
								file$ = MID$ (text$, 3, colon-3)
								entry$ = MID$ (text$, colon+1)
	END SELECT
'
	file$ = TRIM$ (file$)
	entry$ = TRIM$ (entry$)
'
	IFZ file$ THEN
		IF ##WHOMASK THEN
			file$ = userTextFilename$
		ELSE
			file$ = sysTextFilename$
		END IF
	END IF
'
	IFZ file$ THEN
		file$ = PROGRAM$ (0)
		IF file$ THEN file$ = file$ + ".txt"
	END IF
'
	IFZ file$ THEN
		XstGetCommandLineArguments (@count, @argv$[])
		IF argv$[] THEN file$ = argv$[0]
		dot = INSTR (file$, ".")
		IF dot THEN file$ = LEFT$ (file$, dot) + "txt"
	END IF
'
	XstLoadString (@file$, @text$)
'
	IFZ entry$ THEN
		IF colon THEN text$ = ""
	ELSE
		marker$ = "\n[" + entry$ + "]"
		entry = INSTR (text$, marker$)
		IFZ entry THEN
			text$ = ""
		ELSE
			start = INSTR (text$, "\n", entry+3)
			IF start THEN
				start = start + 1
				beyond = INSTR (text$, "\n[", start)
				IFZ beyond THEN beyond = LEN (text$) + 1
				text$ = TRIM$(MID$(text$, start, beyond-start))
			END IF
		END IF
	END IF
END SUB
'
'
' *****  ClearBackground  *****
'
'
SUB ClearBackground
'	bc = grid[grid].backgroundColor
	IF ((v2 <= 0) OR (v3 <= 0)) THEN		' need to clear it all
'		IF border THEN
'			XgrFillBox (grid, bc, gridLeft+bw, gridTop+bw, gridRight-bw, gridBottom-bw)
'		ELSE
			XgrFillBox (grid, bc, gridLeft, gridTop, gridRight, gridBottom)
'		END IF
	ELSE
'		IF bw THEN
'			gridTop = gridTop + bw
'			gridLeft = gridLeft + bw
'			gridRight = gridRight - bw
'			gridBottom = gridBottom - bw
'		END IF
		IF (redrawLeft > gridLeft) THEN gridLeft = redrawLeft
		IF (redrawTop > gridTop) THEN gridTop = redrawTop
		IF (redrawRight < gridRight) THEN gridRight = redrawRight
		IF (redrawBottom < gridBottom) THEN gridBottom = redrawBottom
		XgrFillBox (grid, bc, gridLeft, gridTop, gridRight, gridBottom)
	END IF
END SUB
'
'
' *****  DrawGraphDots  *****
'
SUB DrawGraphDots
	XgrGetGridBox (grid, @x1, @y1, @x2, @y2)			' graph corners in local coords
	maxX = x2 - x1																'
	maxY = y2 - y1																'
	n = 8																					' dot every 8th pixel
	xc = (maxX - bw - bw) >> 3 + 1								' x dot count
	yc = (maxY - bw - bw) >> 3 + 1								' y dot count
	upper = (xc * yc) << 1 + 2										' upper bound of points array
	DIM dot[upper]																' create room for dot coords
	e = 0																					' array index
	FOR j = x1 + bw TO y2 - bw STEP n							' every nth vertical pixel
		FOR i = x1 + bw TO x2 - bw STEP n						' every nth horizontal pixel
			dot[e] = i : INC e												' x coord of dot
			dot[e] = j : INC e												' y coord of dot
		NEXT i
	NEXT j
	z = e >> 1
	XgrDrawPoints (grid, -1, 0, z, @dot[])				' draw dots
	DIM dot[]
END SUB
'
'
' *****  DrawString  *****
'
SUB DrawString
	XgrGetTextImageSize (font, @text$, @dx, @dy, @width, @height, @gap, @space)
'	height = height + space - gap + 1
'
	IF clip THEN
		IFZ clipper THEN
			IF ((width > (gridWidth - inL - inR)) OR (height > (gridHeight - inT - inB))) THEN
				XgrGetGridClip (grid, @check)
				IFZ check THEN
					clipper	= $$TRUE
					alignX	= $$AlignLeft
					IF (inL > 2) THEN inL = 2
					XgrSetGridClip (grid, grid)
				END IF
			END IF
		END IF
	END IF
'
	GOSUB GetTextureColors
	GOSUB GetIndentX
	GOSUB GetIndentY
	drawX = inX + 1
	drawY = inY + 1
	GOSUB DrawText
END SUB
'
'
' *****  DrawStringArray  *****
'
SUB DrawStringArray
	holdTexture = texture
	GOSUB GetTextureColors
	IFZ text$[] THEN EXIT SUB
	XgrGetTextArrayImageSize (font, @text$[], @w, @h, @width, @height, extra+xgap, extra+ygap)
	XgrGetFontInfo (font, @font$, @size, @weight, @italic, @angle)
	XgrGetTextImageSize (font, @"W", 0, 0, @ww, @hh, @gg, @ss)
'
	IF ((width > gridWidth) OR (height > gridHeight)) THEN
		XgrGetGridClip (grid, @check)
		IFZ check THEN
			XgrSetGridClip (grid, grid)
			clipper = $$TRUE
		END IF
	END IF
'
	SELECT CASE alignX
		CASE $$AlignLeft		:	xx = bw + indentL + (width >> 1)
		CASE $$AlignCenter	: xx = gridWidth >> 1
		CASE $$AlignRight		: xx = gridWidth - bw - indentR - (width >> 1)
		CASE ELSE						: xx = gridWidth >> 1
	END SELECT
'
	SELECT CASE alignY
		CASE $$AlignUpper		: yy = bw + indentT + (height >> 1)
		CASE $$AlignMiddle	: yy = (gridHeight >> 1) - (gg >> 1)
		CASE $$AlignLower		: yy = gridHeight - bw - indentB - (height >> 1)
		CASE ELSE						: yy = (gridHeight >> 1) - (gg >> 1)
	END SELECT
'
	upper = UBOUND (text$[])
	IFZ angle THEN GOSUB DrawTextArray ELSE GOSUB DrawTextArrayAtAngle
END SUB
'
'
' *****  DrawTextArray  *****
'
SUB DrawTextArray
	hx = w >> 1
	hy = -(h >> 1)
	FOR i = 0 TO upper
		IFZ text$[i] THEN
			hy = hy + hh + ygap
		ELSE
			text$ = text$[i]
			XgrGetTextImageSize (font, @text$, @tw, @th, @ww, @hh, 0, 0)
			ww = ww + extra : hh = hh + extra + ygap
			SELECT CASE justify
				CASE $$JustifyLeft		: drawX = xx - hx
				CASE $$JustifyCenter	: drawX = xx - (ww >> 1)
				CASE $$JustifyRight		: drawX = xx + hx - ww
				CASE $$JustifyBoth		: drawX = xx - hx
				CASE ELSE							: drawX = xx - (ww >> 1)
			END SELECT
			drawY = yy + hy
			GOSUB DrawText
			hy = hy + hh
		END IF
	NEXT i
END SUB
'
'
' *****  DrawTextArrayAtAngle  *****
'
SUB DrawTextArrayAtAngle
	w# = w >> 1											' w# = 1/2 width of text box
	h# = h >> 1											' h# = 1/2 height of text box
	r# = SQRT (w#*w# + h#*h#)				' r# = radius of text box
	a# = angle * .1# * $$DEGTORAD		' a# = tilt angle in radians
'
	hy = (h >> 1)										' start at top of text block
	FOR i = 0 TO upper
		IFZ text$[i] THEN
			hy = hy - hh
		ELSE
			text$ = text$[i]
			XgrGetTextImageSize (font, @text$, @tw, @th, @ww, @hh, 0, 0)
			ww = ww + extra : hh = hh + extra
			SELECT CASE justify
				CASE $$JustifyLeft		: hx# = -(w	>> 1)				' at left edge
																hy# = hy							' current line y
				CASE $$JustifyCenter	: hx# = -(ww >> 1)			' center string
																hy# = hy							' current line y
				CASE $$JustifyRight		: hx# = (w >> 1) - ww		' at right edge
																hy# = hy							' current line y
				CASE $$JustifyBoth		: hx# = -(w >> 1)				' at left edge
																hy# = hy							' current line y
				CASE ELSE							: hx# = -(ww >> 1)			' center string
																hy# = hy							' current line y
			END SELECT
			GOSUB Rotate
			GOSUB DrawText
			hy = hy - hh
		END IF
	NEXT i
END SUB
'
'
' *****  Rotate  *****
'
SUB Rotate
	rr# = SQRT ( hx# * hx# + hy# * hy# )
	aa# = ACOS ( hx# / rr# )
	IF (hy# < 0) THEN aa# = -aa#
	na# = a# + aa#
	IF (na# < 0) THEN na# = na# + $$TWOPI
	IF (na# > $$TWOPI) THEN na# = na# - $$TWOPI
	drawX = xx + (rr# * COS(na#))
	drawY = yy - (rr# * SIN(na#))
END SUB
'
'
' *****  GetTextureColors  *****
'
SUB GetTextureColors
	IF (focus AND (grid = keyboardFocusGrid)) THEN
		SELECT CASE texture
			CASE $$TextureNone:			color = ac : other = dc : extra = 0
			CASE $$TextureLower1:		color = lt : other = ac : extra = 1
			CASE $$TextureLower2:		color = lt : other = ac : extra = 2
			CASE $$TextureLower4:		color = lt : other = ac : extra = 4
			CASE $$TextureShadow:		color = ac : other = lt : extra = 4
			CASE $$TextureRaise1:		color = ac : other = lt : extra = 1
			CASE $$TextureRaise2:		color = ac : other = lt : extra = 2
			CASE $$TextureRaise4:		color = ac : other = lt : extra = 4
		END SELECT
	ELSE
		SELECT CASE texture
			CASE $$TextureNone:			color = dc : other = dc : extra = 0
			CASE $$TextureLower1:		color = lt : other = ht : extra = 1
			CASE $$TextureLower2:		color = lt : other = ht : extra = 2
			CASE $$TextureLower4:		color = lt : other = ht : extra = 4
			CASE $$TextureShadow:		color = ht : other = lt : extra = 4
			CASE $$TextureRaise1:		color = ht : other = lt : extra = 1
			CASE $$TextureRaise2:		color = ht : other = lt : extra = 2
			CASE $$TextureRaise4:		color = ht : other = lt : extra = 4
		END SELECT
	END IF
END SUB
'
'
' *****  GetIndentX  *****
'
SUB GetIndentX
	SELECT CASE alignX
		CASE $$AlignLeft		:	inX = indentL + bw
		CASE $$AlignCenter	:	inX = ((gridWidth - width) >> 1)
		CASE $$AlignRight		:	inX = ((gridWidth - width) - bw - indentR - extra)
	END SELECT
END SUB
'
'
' *****  GetIndentY  *****
'
SUB GetIndentY
	SELECT CASE alignY
		CASE $$AlignUpper		:	inY = indentT + bw - gap
		CASE $$AlignMiddle	:	inY = ((gridHeight - height - gap) >> 1)
		CASE $$AlignLower		:	inY = ((gridHeight - height) - bw - indentB - extra - 1)
	END SELECT
END SUB
'
'
' *****  DrawText  *****
'
SUB DrawText
	IF texture THEN
		SELECT CASE texture
			CASE $$TextureShadow	: XgrMoveTo (grid, drawX+4, drawY+4)
															XgrDrawText (grid, other, @text$)
			CASE ELSE							:	FOR j = 1 TO extra
																XgrMoveTo (grid, drawX+j, drawY+j)
																XgrDrawText (grid, other, @text$)
															NEXT j
		END SELECT
	END IF
'	XgrMoveTo (grid, drawX, drawY)
'	XgrDrawBox (grid, $$White, drawX-1, drawY-1, drawX+width+1, drawY+height+2)
	XgrMoveTo (grid, drawX, drawY)
	XgrDrawText (grid, color, @text$)
END SUB
END FUNCTION
'
'
' ##############################
' #####  XuiRedrawText ()  #####
' ##############################
'
FUNCTION  XuiRedrawText (grid, message, v0, v1, v2, v3, kid, r1)
'
	XuiRedrawGrid (grid, #RedrawGrid, 0, 0, 0, 0, kid, r1)
END FUNCTION
'
'
' ################################
' #####  XuiRedrawWindow ()  #####
' ################################
'
FUNCTION  XuiRedrawWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiRedrawWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiRedrawWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #RedrawWindow) THEN PRINT "XuiRedrawWindow() : error : (message != #RedrawWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiRedrawWindow() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowRedraw, v0, v1, v2, v3, 0, 0)
END FUNCTION
'
'
' ##########################
' #####  XuiResize ()  #####
' ##########################
'
FUNCTION  XuiResize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiResize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiResize() : error : (grid > upperGrid)" : RETURN
	IF (message != #Resize) THEN PRINT "XuiResize() : error : (message != #Resize)" : RETURN
'
	parent = grid[grid].parent
	window = grid[grid].window
	gridWindow = grid[grid].gridWindow
'
	IFZ gridWindow THEN
		XuiPositionGrid (grid, v0, v1, @v2, @v3)
	ELSE
		IF parent THEN PRINT "XuiResize() : error ::: ((grid[grid].gridWindow != 0) AND (grid[grid].parent != 0))"
		IF (window != gridWindow) THEN PRINT "XuiResize() : error : (grid[grid].window != grid[grid].gridWindow)" : RETURN
		IF (grid != windowInfo[window].grid) THEN PRINT "XuiResize() : error : (grid != windowInfo[window].grid)" : RETURN
		XgrGetWindowPositionAndSize (window, @xDisp, @yDisp, @width, @height)
		XuiPositionGrid (grid, 0, 0, @v2, @v3)
		IF ((v2 != width) OR (v3 != height)) THEN
			XuiSendMessage (grid, #ResizeWindowToGrid, -1, -1, -1, -1, 0, 0)
		END IF
	END IF
END FUNCTION
'
'
' #############################
' #####  XuiResizeNot ()  #####
' #############################
'
FUNCTION  XuiResizeNot (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiResizeNot() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiResizeNot() : error : (grid > upperGrid)" : RETURN
	IF ((message != #Resize) AND (message != #ResizeNot)) THEN PRINT "XuiResizeNot() : error : (message != #Resize or #ResizeNot)" : RETURN
'
	gridWindow = grid[grid].gridWindow
	window = grid[grid].window
	parent = grid[grid].parent
	IFZ gridWindow THEN
		XgrGetGridBoxWindow (grid, @xx1, @yy1, @xx2, @yy2)
		IF ((v0 != xx1) OR (v1 != yy1)) THEN
			dx = v0 - xx1 : dy = v1 - yy1
			ww = xx2 - xx1 : hh = yy2 - yy1
			XuiPositionGrid (grid, v0, v1, ww, hh)
			XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
			IF k[] THEN
				FOR kid = 1 TO UBOUND(k[])
					k = k[kid]
					IF k THEN
						XuiSendMessage (k, #GetSize, @kx1, @ky1, @kw, @kh, 0, 0)
						kx1 = kx1 + dx : ky1 = ky1 + dy
						XuiSendMessage (k, #Resize, kx1, ky1, kw, kh, 0, 0)
					END IF
				NEXT kid
			END IF
		END IF
	ELSE
		IF (window != gridWindow) THEN PRINT "XuiResizeNot() : error : (grid[grid].window != grid[grid].gridWindow)" : RETURN
		IF (grid != windowInfo[window].grid) THEN PRINT "XuiResizeNot() : error : (grid != windowInfo[window].grid)" : RETURN
		XgrGetWindowPositionAndSize (gridWindow, @xDisp, @yDisp, @width, @height)
		XgrGetGridPositionAndSize (grid, @v0, @v1, @v2, @v3)
		IF ((v2 != width) OR (v3 != height)) THEN
			func = windowInfo[gridWindow].func
			@func (gridWindow, #WindowResize, v0, v1, v2, v3, 0, 0)
			IFZ func THEN PRINT "XuiResizeNot() : error : (windowGrid with no windowFunc)" : RETURN
		END IF
	END IF
END FUNCTION
'
'
' ################################
' #####  XuiResizeWindow ()  #####
' ################################
'
FUNCTION  XuiResizeWindow (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiResizeWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiResizeWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #ResizeWindow) THEN PRINT "XuiResizeWindow() : error : (message != #ResizeWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiResizeWindow() : error : (grid[grid].window <= 0)" : RETURN
	XgrGetWindowPositionAndSize (window, @xDisp, @yDisp, @width, @height)
	IF (v0 <  0) THEN v0 = xDisp
	IF (v1 <  0) THEN v1 = yDisp
	IF (v2 <= 0) THEN v2 = width
	IF (v3 <= 0) THEN v3 = height
	IF ((v0 != xDisp) OR (v1 != yDisp) OR (v2 != width) OR (v3 != height)) THEN
		func = windowInfo[window].func
		@func (window, #WindowResize, v0, v1, v2, v3, 0, 0)
		IFZ func THEN PRINT "XuiResizeWindow() : error : (window with no windowFunc)" : RETURN
	END IF
END FUNCTION
'
'
' ######################################
' #####  XuiResizeWindowToGrid ()  #####
' ######################################
'
FUNCTION  XuiResizeWindowToGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiResizeWindowToGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiResizeWindowToGrid() : error : (grid > upperGrid)" : RETURN
	IF ((message != #Resize) AND (message != #ResizeWindowToGrid)) THEN PRINT "XuiResizeWindowToGrid() : error : (message != #Resize or #ResizeWindowToGrid)" : RETURN
'
	gridWindow = grid[grid].gridWindow
	IFZ gridWindow THEN RETURN
	window = grid[grid].window
	IF (window != gridWindow) THEN PRINT "XuiResizeWindowToGrid() : error : (grid[grid].window != grid[grid].gridWindow)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowResizeToGrid, v0, v1, v2, v3, 0, 0)
	IFZ func THEN PRINT "XuiResizeWindowToGrid() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ################################
' #####  XuiSelectWindow ()  #####
' ################################
'
FUNCTION  XuiSelectWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSelectWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSelectWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #SelectWindow) THEN PRINT "XuiSelectWindow() : error : (message != #SelectWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiSelectWindow() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowSelect, v0, v1, v2, v3, 0, 0)
	IFZ func THEN PRINT "XuiSelectWindow() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ############################
' #####  XuiSetAlign ()  #####
' ############################
'
FUNCTION  XuiSetAlign (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetAlign() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetAlign() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetAlign) THEN PRINT "XuiSetAlign() : error : (message != #SetAlign)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].align = v0
	IF (v1 != -1) THEN grid[grid].justify = v1
	IF (v2 != -1) THEN grid[grid].indentLeft = v2
	IF (v3 != -1) THEN grid[grid].indentTop = v3
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' #############################
' #####  XuiSetBorder ()  #####
' #############################
'
FUNCTION  XuiSetBorder (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetBorder() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetBorder() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetBorder) THEN PRINT "XuiSetBorder() : error : (message != #SetBorder)" : RETURN
'
	XgrSetGridBorder (grid, v0, v1, v2, v3)
	XgrGetGridBorder (grid, @v0, @v1, @v2, @v3)
'
	grid[grid].border = v0
	grid[grid].borderUp = v1
	grid[grid].borderDown = v2
	grid[grid].borderFlags = v3
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, 0)
	END IF
END FUNCTION
'
'
' ###################################
' #####  XuiSetBorderOffset ()  #####
' ###################################
'
FUNCTION  XuiSetBorderOffset (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetBorderOffset() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetBorderOffset() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetBorderOffset) THEN PRINT "XuiSetBorderOffset() : error : (message != #SetBorderOffset)" : RETURN
'
	XgrSetGridBorderOffset (grid, v0, v1, v2, v3)
	XgrGetGridBorderOffset (grid, @v0, @v1, @v2, @v3)
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, 0)
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiSetCallback ()  #####
' ###############################
'
FUNCTION  XuiSetCallback (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	upperGrid
	SHARED	CALLBACK	callback[]
	MEMORYMAP  mm
	ULONG  addr
	ULONG  ##BSS0, ##BSS, ##BSSX, ##BSSZ
	ULONG  ##DATA0, ##DATA, ##DATAX, ##DATAZ
	ULONG  ##DYNO0, ##DYNO, ##DYNOX, ##DYNOZ
	ULONG  ##STACK0, ##STACK, ##STACKX, ##STACKZ
'
	gridToCall = v0
	funcToCall = v1
	IF (grid <= 0) THEN PRINT "XuiSetCallback() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetCallback() : error : (grid > upperGrid)" : RETURN
	IF (gridToCall < 0) THEN PRINT "XuiSetCallback() : error : (gridToCall < 0)" : RETURN
	IF (gridToCall > upperGrid) THEN PRINT "XuiSetCallback() : error : (gridToCall > upperGrid)" : RETURN
	IF (message != #SetCallback) THEN PRINT "XuiSetCallback() : error : (message != #SetCallback)" : RETURN
'
' A common error is to forget trailing "()" on function name, which
' sets the callback address to some bad AUTO variable in data memory.
' To prevent this, we make sure the address is not in data memory.
'
	badaddr = $$FALSE
	IF funcToCall THEN
		addr = funcToCall
		IF ((addr >= ##STACK0) AND (addr < ##STACKZ)) THEN badaddr = $$TRUE
		IF ((addr >= ##DATA0) AND (addr < ##DATAZ)) THEN badaddr = $$TRUE
		IF ((addr >= ##DYNO0) AND (addr < ##DYNOZ)) THEN badaddr = $$TRUE
		IF ((addr >= ##BSS0) AND (addr < ##BSSZ)) THEN badaddr = $$TRUE
	END IF
'
	IF badaddr THEN
		PRINT "XuiSetCallback() : error : invalid function address ::: "; HEX$(funcToCall,8)
		funcToCall = 0
	END IF
'
	IF funcToCall THEN
		IF (gridToCall <= 0) THEN PRINT "XuiSetCallback() : error : (gridToCall <= 0) ::: "; grid; gridToCall;; HEX$(funcToCall,8)
	END IF
'
' XuiQueueCallbacks() and XuiGetNextCallback() don't work with r0 = -1
'
	rr0 = r0
	IF (r0 = -1) THEN
		IF (func = &XuiQueueCallbacks()) THEN r0 = 0
	END IF
'
	callback[grid].grid = gridToCall
	callback[grid].func = funcToCall
	callback[grid].v2 = v2
	callback[grid].v3 = v3
	callback[grid].r0 = r0
	callback[grid].r1 = r1
	r0 = rr0
END FUNCTION
'
'
' ##########################
' #####  XuiSetCan ()  #####
' ##########################
'
FUNCTION  XuiSetCan (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	borderWidth[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetCan() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetCan() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetCan) THEN PRINT "XuiSetCan() : error : (message != #SetCan)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].can = v0
	IF (v1 != -1) THEN grid[grid].focusKid = v1
	IF (v2 != -1) THEN grid[grid].inputTextArray = v2
	IF (v3 != -1) THEN grid[grid].inputTextString = v3
END FUNCTION
'
'
' ###############################
' #####  XuiSetClipGrid ()  #####
' ###############################
'
FUNCTION  XuiSetClipGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetClipGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetClipGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetClipGrid) THEN PRINT "XuiSetClipGrid() : error : (message != #SetClipGrid)" : RETURN
'
	grid[grid].clip = v0
	XgrSetGridClip (grid, v0)
END FUNCTION
'
'
' ############################
' #####  XuiSetColor ()  #####
' ############################
'
FUNCTION  XuiSetColor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetColor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetColor() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetColor) THEN PRINT "XuiSetColor() : error : (message != #SetColor)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].backgroundColor		= v0
	IF (v1 != -1) THEN grid[grid].drawingColor			= v1
	IF (v2 != -1) THEN grid[grid].lowlightColor			= v2
	IF (v3 != -1) THEN grid[grid].highlightColor		= v3
'
	IFZ r1 THEN
		grid[grid].focusBackground = grid[grid].backgroundColor
		grid[grid].focusDrawing = grid[grid].drawingColor
		grid[grid].focusLowlight = grid[grid].lowlightColor
		grid[grid].focusHighlight = grid[grid].accentColor
		grid[grid].focusDull = grid[grid].dullColor
		grid[grid].focusAccent = grid[grid].accentColor
		grid[grid].focusLowtext = grid[grid].lowtextColor
		grid[grid].focusHightext = grid[grid].accentColor
	END IF
'
	XgrSetGridColors (grid, v0, v1, v2, v3, -1, -1, -1, -1)
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiSetColorAll ()  #####
' ###############################
'
FUNCTION  XuiSetColorAll (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetColorAll() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetColorAll() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetColor) THEN PRINT "XuiSetColorAll() : error : (message != #SetColor)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].backgroundColor		= v0
	IF (v1 != -1) THEN grid[grid].drawingColor			= v1
	IF (v2 != -1) THEN grid[grid].lowlightColor			= v2
	IF (v3 != -1) THEN grid[grid].highlightColor		= v3
'
	IFZ r1 THEN
		grid[grid].focusBackground = grid[grid].backgroundColor
		grid[grid].focusDrawing = grid[grid].drawingColor
		grid[grid].focusLowlight = grid[grid].lowlightColor
		grid[grid].focusHighlight = grid[grid].accentColor
		grid[grid].focusDull = grid[grid].dullColor
		grid[grid].focusAccent = grid[grid].accentColor
		grid[grid].focusLowtext = grid[grid].lowtextColor
		grid[grid].focusHightext = grid[grid].accentColor
	END IF
'
	XgrSetGridColors (grid, v0, v1, v2, v3, -1, -1, -1, -1)
'
	IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
END FUNCTION
'
'
' #################################
' #####  XuiSetColorExtra ()  #####
' #################################
'
FUNCTION  XuiSetColorExtra (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetColorExtra() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetColorExtra() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetColorExtra) THEN PRINT "XuiSetColorExtra() : error : (message != #SetColorExtra)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].dullColor = v0
	IF (v1 != -1) THEN grid[grid].accentColor = v1
	IF (v2 != -1) THEN grid[grid].lowtextColor = v2
	IF (v3 != -1) THEN grid[grid].hightextColor = v3
'
	IFZ r1 THEN
		grid[grid].focusBackground = grid[grid].backgroundColor
		grid[grid].focusDrawing = grid[grid].drawingColor
		grid[grid].focusLowlight = grid[grid].lowlightColor
		grid[grid].focusHighlight = grid[grid].accentColor
		grid[grid].focusDull = grid[grid].dullColor
		grid[grid].focusAccent = grid[grid].accentColor
		grid[grid].focusLowtext = grid[grid].lowtextColor
		grid[grid].focusHightext = grid[grid].accentColor
	END IF
'
	XgrSetGridColors (grid, -1, -1, -1, -1, v0, v1, v2, v3)
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ####################################
' #####  XuiSetColorExtraAll ()  #####
' ####################################
'
FUNCTION  XuiSetColorExtraAll (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetColorExtraAll() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetColorExtraAll() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetColorExtra) THEN PRINT "XuiSetColorExtraAll() : error : (message != #SetColorExtra)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].dullColor = v0
	IF (v1 != -1) THEN grid[grid].accentColor = v1
	IF (v2 != -1) THEN grid[grid].lowtextColor = v2
	IF (v3 != -1) THEN grid[grid].hightextColor = v3
'
	IFZ r1 THEN
		grid[grid].focusBackground = grid[grid].backgroundColor
		grid[grid].focusDrawing = grid[grid].drawingColor
		grid[grid].focusLowlight = grid[grid].lowlightColor
		grid[grid].focusHighlight = grid[grid].accentColor
		grid[grid].focusDull = grid[grid].dullColor
		grid[grid].focusAccent = grid[grid].accentColor
		grid[grid].focusLowtext = grid[grid].lowtextColor
		grid[grid].focusHightext = grid[grid].accentColor
	END IF
'
	XgrSetGridColors (grid, -1, -1, -1, -1, v0, v1, v2, v3)
'
	IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
END FUNCTION
'
'
' #############################
' #####  XuiSetCursor ()  #####
' #############################
'
FUNCTION  XuiSetCursor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetCursor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetCursor() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetCursor) THEN PRINT "XuiSetCursor() : error : (message != #SetCursor)" : RETURN
'
	grid[grid].cursor = v0
END FUNCTION
'
'
' #################################
' #####  XuiSetFocusColor ()  #####
' #################################
'
FUNCTION  XuiSetFocusColor (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetFocusColor() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetFocusColor() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetFocusColor) THEN PRINT "XuiSetFocusColor() : error : (message != #SetFocusColor)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].focusBackground = v0
	IF (v1 != -1) THEN grid[grid].focusDrawing = v1
	IF (v2 != -1) THEN grid[grid].focusLowlight = v2
	IF (v3 != -1) THEN grid[grid].focusHighlight = v3
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ######################################
' #####  XuiSetFocusColorExtra ()  #####
' ######################################
'
FUNCTION  XuiSetFocusColorExtra (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetFocusColorExtra() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetFocusColorExtra() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetFocusColorExtra) THEN PRINT "XuiSetFocusColorExtra() : error : (message != #SetFocusColorExtra)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].focusDull = v0
	IF (v1 != -1) THEN grid[grid].focusAccent = v1
	IF (v2 != -1) THEN grid[grid].focusLowtext = v2
	IF (v3 != -1) THEN grid[grid].focusHightext = v3
'
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ###########################
' #####  XuiSetFont ()  #####
' ###########################
'
FUNCTION  XuiSetFont (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	defaultFontSize
	SHARED	defaultFontWeight
	SHARED	defaultFontItalic
	SHARED	defaultFontAngle
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetFont() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetFont() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetFont) THEN PRINT "XuiSetFont() : error : (message != #SetFont)" : RETURN
'
	IFZ r1$ THEN
		XgrSetGridFont (grid, 0)								' default system font
		RETURN
	END IF
'
	IF (v0 <  0) THEN v0 = defaultFontSize
	IF (v1 <  0) THEN v1 = defaultFontWeight
	IF (v2 = -1) THEN v2 = defaultFontItalic
	IF (v3 = -1) THEN v3 = defaultFontAngle
'
	XgrCreateFont (@font, @r1$, v0, v1, v2, v3)
	IFZ r1$ THEN v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r1$ = ""
	XgrGetFontInfo (font, @font$, @v0, @v1, @v2, @v3)
	XgrSetGridFont (grid, font)
	grid[grid].font = font
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, #SetFontNumber, font, 0, 0, 0, -1, 0)
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiSetFontNumber ()  #####
' #################################
'
FUNCTION  XuiSetFontNumber (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetFontNumber() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetFontNumber() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetFontNumber) THEN PRINT "XuiSetFontNumber() : error : (message != #SetFontNumber)" : RETURN
'
	err = XgrSetGridFont (grid, v0)						' Must be sure valid font #
	IF err THEN RETURN
'
	grid[grid].font = v0
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, -1, r1)
	END IF
END FUNCTION
'
'
' ###################################
' #####  XuiSetGridFunction ()  #####
' ###################################
'
FUNCTION  XuiSetGridFunction (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridFunction() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridFunction() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridFunction) THEN PRINT "XuiSetGridFunction() : error : (message != #SetGridFunction)" : RETURN
'
	grid[grid].gridFunc = v0
	XgrSetGridFunction (grid, v0)
END FUNCTION
'
'
' #######################################
' #####  XuiSetGridFunctionName ()  #####
' #######################################
'
FUNCTION  XuiSetGridFunctionName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridFunc$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridFunctionName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridFunctionName() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridFunctionName) THEN PRINT "XuiSetGridFunctionName() : error : (message != #SetGridFunctionName)" : RETURN
'
	gridFunc$[grid] = TRIM$(r1$)
END FUNCTION
'
'
' ###############################
' #####  XuiSetGridName ()  #####
' ###############################
'
FUNCTION  XuiSetGridName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridName$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridName() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridName) THEN PRINT "XuiSetGridName() : error : (message != #SetGridName)" : RETURN
'
	gridName$[grid] = TRIM$(r1$)
END FUNCTION
'
'
' #####################################
' #####  XuiSetGridProperties ()  #####
' #####################################
'
FUNCTION  XuiSetGridProperties (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED  GRID  grid[]
	SHARED  gridName$[]
	SHARED  upperGrid
	SHARED  prop$[]
	SHARED  kids[]
	FUNCADDR  f (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, ANY)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridProperties() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridProperties() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridProperties) THEN PRINT "XuiSetGridProperties() : error : (message != #SetGridProperties)" : RETURN
'
' customize kids first
'
	IF ((kid = -1) OR (v0 = -1)) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, @r1)
	END IF
'
	XuiGetGridProperties (grid, #GetGridProperties, 0, 0, 0, 0, 0, @p$[])
'
	IFZ p$[] THEN RETURN
	upper = UBOUND (p$[])
	gridName$ = gridName$[grid]
	XstGetProgramName (@program$)
	XgrGetGridType (grid, @gridType)
	XgrGridTypeNumberToName (@gridType, @gridType$)
'
	FOR i = 0 TO upper
		index = 0
		done = $$FALSE
		line$ = p$[i]
		ParseFuncLine (@line$, @a$[])
		IFZ a$[] THEN DO NEXT
		theFunc$ = a$[0]
		theGrid$ = a$[1]
		theMessage$ = a$[2]
		IFZ theFunc$ THEN DO NEXT
		IFZ theGrid$ THEN DO NEXT
		IFZ theMessage$ THEN DO NEXT
		IFZ (INSTR(theFunc$,"XuiSendMessage")) THEN DO NEXT
		IF ((theGrid${0} != '*') AND (theGrid$ != gridName$)) THEN DO NEXT
		IF (theMessage${0} = '#') THEN theMessage$ = MID$(theMessage$, 2)
		XgrMessageNameToNumber (@theMessage$, @theMessage)
		IF (theMessage <= 0) THEN DO NEXT
		v0 = XLONG(a$[3])
		v1 = XLONG(a$[4])
		v2 = XLONG(a$[5])
		v3 = XLONG(a$[6])
		r0 = XLONG(a$[7])
		r1 = XLONG(a$[8])
		theGrid = grid
		aa$ = ""
		r1$ = ""
		GOSUB SendMessage
	NEXT i
	XuiSendMessage (grid, #GetSize, @xx, @yy, @ww, @hh, 0, 0)
	XuiSendMessage (grid, #Resize, xx, yy, ww, hh, 0, 0)
	RETURN ($$FALSE)
'
'
' *****  SendMessage  *****
'
SUB SendMessage
	IFZ theGrid THEN EXIT SUB
	SELECT CASE theMessage
		CASE #SetBorder						:	XgrBorderNameToNumber (a$[3], @vv0)
																XgrBorderNameToNumber (a$[4], @vv1)
																XgrBorderNameToNumber (a$[5], @vv2)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
																IF (v3 >= 0) THEN v3 = vv3
		CASE #SetCallback					:	@f ( theGrid, #SetCallback, theGrid, &Design(), -1, -1, kidNumber, theGrid)
																EXIT SUB
		CASE #SetColor, #SetColorExtra, #SetFocusColor, #SetFocusColorExtra
																XgrColorNameToNumber (a$[3], @vv0)
																XgrColorNameToNumber (a$[4], @vv1)
																XgrColorNameToNumber (a$[5], @vv2)
																XgrColorNameToNumber (a$[6], @vv3)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
																IF (v3 >= 0) THEN v3 = vv3
		CASE #SetAlign						:	XuiAlignNameToNumber (a$[3], @vv0)
																XuiJustifyNameToNumber (a$[4], @vv1)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
		CASE #SetGridName					:	r1$ = a$[8]
		CASE #SetGridTypeName			:	r1$ = a$[8]
		CASE #SetGridFunctionName	:	r1$ = a$[8]
		CASE #SetHelpString				:	r1$ = a$[8]
		CASE #SetHintString				:	r1$ = a$[8]
		CASE #SetFont							:	r1$ = a$[8]
		CASE #SetImage						:	rx$ = a$[8]
																r1$ = XstBackStringToBinString$ (@rx$)
		CASE #SetMessageFunc			: PRINT "ToolkitCode() : WindowFromFunction : XuiSetMessageFunc() ignored"
																EXIT SUB
		CASE #SetTextString				:	r1$ = a$[8]
																r1$ = XstBackStringToBinString$ (@r1$)
		CASE #SetTextArray				:	aa$ = a$[8]
		CASE #SetTexture					:	XuiTextureNameToNumber (a$[3], @vv0)
																IF (v0 >= 0) THEN v0 = vv0
																IF (v1 >= 0) THEN v1 = vv1
																IF (v2 >= 0) THEN v2 = vv2
		CASE #Create							:	eee = i : EXIT SUB
		CASE #CreateWindow				:	eee = i : EXIT SUB
	END SELECT
'
	SELECT CASE TRUE
		CASE r1$	:	start = INSTR (r1$, "\"")
								IFZ start THEN eee = i : EXIT SUB
								final = RINSTR (r1$, "\"")
								IF (final <= start) THEN eee = i : EXIT SUB
								length = final - start - 1
								IFZ length THEN r1$ = "" ELSE r1$ = MID$(r1$, start+1, length)
								XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, @r1$)
		CASE aa$	:	aa$ = TRIM$ (aa$)
								IF aa$ THEN
									IF (aa${0} = '@') THEN aa$ = MID$(aa$,2)
									IF aa$ THEN
										IF (aa${0} = '"') THEN
											aa$ = MID$(aa$,2)
											IF aa$ THEN
												u = UBOUND (aa$)
												IF (aa${u} = '"') THEN
													aa$ = LEFT$(aa$,u)
												END IF
											END IF
										END IF
									END IF
								END IF
								XstStringToStringArray (@aa$, @tt$[])
								XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, @tt$[])
		CASE ELSE	:	XuiSendMessage (theGrid, theMessage, v0, v1, v2, v3, r0, r1)
	END SELECT
END SUB
END FUNCTION
'
'
' ###############################
' #####  XuiSetGridType ()  #####
' ###############################
'
FUNCTION  XuiSetGridType (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridType() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridType() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridType) THEN PRINT "XuiSetGridType() : error : (message != #SetGridType)" : RETURN
'
	grid[grid].gridType = v0
	XgrSetGridType (grid, v0)
END FUNCTION
'
'
' ###################################
' #####  XuiSetGridTypeName ()  #####
' ###################################
'
FUNCTION  XuiSetGridTypeName (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	gridType$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGridTypeName() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGridTypeName() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGridTypeName) THEN PRINT "XuiSetGridTypeName() : error : (message != #SetGridTypeName)" : RETURN
'
	gridType$[grid] = TRIM$(r1$)
END FUNCTION
'
'
' ############################
' #####  XuiSetGroup ()  #####
' ############################
'
FUNCTION  XuiSetGroup (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetGroup() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetGroup() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetGroup) THEN PRINT "XuiSetGroup() : error : (message != #SetGroup)" : RETURN
'
	grid[grid].group = v0
END FUNCTION
'
'
' ###########################
' #####  XuiSetHelp ()  #####
' ###########################
'
FUNCTION  XuiSetHelp (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetHelp() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetHelp() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetHelp) THEN PRINT "XuiSetHelp() : error : (message != #SetHelp)" : RETURN
'
	XuiHelp (grid, #SetHelp, 0, 0, 0, 0, 0, @r1$)
END FUNCTION
'
'
' ###############################
' #####  XuiSetHelpFile ()  #####
' ###############################
'
FUNCTION  XuiSetHelpFile (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetHelpFile() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetHelpFile() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetHelpFile) THEN PRINT "XuiSetHelpFile() : error : (message != #SetHelpFile)" : RETURN
'
	XuiHelp (grid, #SetHelpFile, 0, 0, 0, 0, 0, @r1$)
END FUNCTION
'
'
' #################################
' #####  XuiSetHelpString ()  #####
' #################################
'
FUNCTION  XuiSetHelpString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetHelpString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetHelpString() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetHelpString) THEN PRINT "XuiSetHelpString() : error : (message != #SetHelpString)" : RETURN
'
	help$[grid] = r1$
	IF ((kid = -1) OR (v0 = -1)) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, @r1$)
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiSetHelpStrings ()  #####
' ##################################
'
FUNCTION  XuiSetHelpStrings (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	help$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetHelpStrings() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetHelpStrings() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetHelpStrings) THEN PRINT "XuiSetHelpStrings() : error : (message != #SetHelpStrings)" : RETURN
'
	IFZ kids[grid, ] THEN
		XuiSendMessage (grid, #SetHelpString, v0, 0, 0, 0, 0, r1$[0])
	ELSE
		final = UBOUND (r1$[])
		upper = UBOUND (kids[grid,])
		upper = MIN (final, upper)
		FOR i = 0 TO upper
			XuiSendMessage (grid, #SetHelpString, v0, 0, 0, 0, i, r1$[i])
		NEXT i
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiSetHintString ()  #####
' #################################
'
FUNCTION  XuiSetHintString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	hint$[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetHintString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetHintString() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetHintString) THEN PRINT "XuiSetHintString() : error : (message != #SetHintString)" : RETURN
'
	hint$[grid] = r1$
	IF ((kid = -1) OR (v0 = -1)) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, @r1$)
	END IF
END FUNCTION
'
'
' ############################
' #####  XuiSetImage ()  #####
' ############################
'
FUNCTION  XuiSetImage (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	Image
	SHARED	upperGrid
	SHARED	image$[]
	SHARED	GRID	grid[]
	UBYTE  image[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetImage() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetImage() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetImage) THEN PRINT "XuiSetImage() : error : (message != #SetImage)" : RETURN
'
	width = 0
	height = 0
	image = grid[grid].image
	window = grid[grid].window
'
	IF (r1 AND (r1 != -1)) THEN
		XgrLoadImage (r1$, @image[])
		IFZ image[] THEN
			dot = INSTR (r1$, ".")
			IFZ dot THEN XgrLoadImage (r1$ + ".bmp", @image[])
			IF image[] THEN r1$ = r1$ + ".bmp"
		END IF
		IFZ image[] THEN
			IF image THEN XuiSendMessage (image, #Destroy, 0, 0, 0, 0, 0, 0)
			image$[grid] = ""
			image = 0
		ELSE
			XgrGetImageArrayInfo (@image[], @v1, @width, @height)
			IF image THEN
				XuiImage (@image, #Destroy, 0, 0, 0, 0, 0, 0)
				image = $$FALSE
			END IF
			IFZ image THEN
				XuiImage (@image, #Create, 0, 0, width, height, window, 0)
			ELSE
				XgrSetGridBox (image, 0, 0, width-1, height-1)		' ????
			END IF
			XgrSetImage (image, @image[])
			image$[grid] = r1$
		END IF
	ELSE
		IF v0 >= 0 THEN image = v0
	END IF
'
	v0 = image
	grid[grid].image = image
'
	IF (image > 0) THEN
		IF (v1 != -1) THEN grid[grid].imageAlign = v1
		IF (v2 != -1) THEN grid[grid].imageIndentX = v2
		IF (v3 != -1) THEN grid[grid].imageIndentY = v3
		grid[grid].imageStartX	= 0
		grid[grid].imageStartY	= 0
		grid[grid].imageWidth		= width
		grid[grid].imageHeight	= height
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiSetImageCoords ()  #####
' ##################################
'
FUNCTION  XuiSetImageCoords (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetImageCoords() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetImageCoords() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetImageCoords) THEN PRINT "XuiSetImageCoords() : error : (message != #SetImageCoords)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].imageStartX = v0
	IF (v1 != -1) THEN grid[grid].imageStartY = v1
	IF (v2 != -1) THEN grid[grid].imageWidth  = v2
	IF (v3 != -1) THEN grid[grid].imageHeight = v3
END FUNCTION
'
'
' #############################
' #####  XuiSetIndent ()  #####
' #############################
'
FUNCTION  XuiSetIndent (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetIndent() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetIndent() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetIndent) THEN PRINT "XuiSetIndent() : error : (message != #SetIndent)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].indentLeft = v0
	IF (v1 != -1) THEN grid[grid].indentTop = v1
	IF (v2 != -1) THEN grid[grid].indentRight = v2
	IF (v3 != -1) THEN grid[grid].indentBottom = v3
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ###########################
' #####  XuiSetInfo ()  #####
' ###########################
'
FUNCTION  XuiSetInfo (grid, message, v0, v1, v2, v3, kid, GRID r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetInfo() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetInfo() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetInfo) THEN PRINT "XuiSetInfo() : error : (message != #SetInfo)" : RETURN
'
	grid[grid] = r1
END FUNCTION
'
'
' ##############################
' #####  XuiSetJustify ()  #####
' ##############################
'
FUNCTION  XuiSetJustify (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetJustify() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetJustify() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetJustify) THEN PRINT "XuiSetJustify() : error : (message != #SetJustify)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].justify = v0
	IF (kid = -1) THEN
		IF kids[grid, ] THEN XuiSendToKids (grid, message, v0, v1, v2, v3, 0, r1)
	END IF
END FUNCTION
'
'
' ####################################
' #####  XuiSetKeyboardFocus ()  #####
' ####################################
'
FUNCTION  XuiSetKeyboardFocus (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	selectedWindow
	SHARED	keyboardFocusGrid
	SHARED	WINDOW	windowInfo[]
	SHARED	GRID	grid[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetKeyboardFocus() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetKeyboardFocus() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetKeyboardFocus) THEN PRINT "XuiSetKeyboardFocus() : error : (message != #SetKeyboardFocus)" : RETURN
'
	gg = grid
	IF ((v0 != 0) AND (v0 != gg)) THEN
		IF (v0 < 0) THEN PRINT "XuiSetKeyboardFocus() : error : (v0 < 0)" : RETURN
		IF (v0 > upperGrid) THEN PRINT "XuiSetKeyboardFocus() : error : (v0 > upperGrid)" : RETURN
		gg = v0
	END IF
	IF (gg != keyboardFocusGrid) THEN
		window = grid[gg].window
		XuiSetKeyboardFocusGrid (gg, #SetKeyboardFocusGrid, gg, 0, 0, 0, 0, 0)
		IF (window != selectedWindow) THEN
			XgrGetModalWindow (@mw)
			IF ((mw = 0) OR (mw = window)) THEN
				func = windowInfo[window].func
				@func (window, #WindowSelect, 0, 0, 0, 0, 0, 0)
				IFZ func THEN PRINT "XuiSetKeyboardFocus() : error : (no window function for focus grid)"
			END IF
		END IF
	END IF
END FUNCTION
'
'
' ########################################
' #####  XuiSetKeyboardFocusGrid ()  #####
' ########################################
'
FUNCTION  XuiSetKeyboardFocusGrid (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	selectedWindow
	SHARED	keyboardFocusGrid
	SHARED	WINDOW	windowInfo[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetKeyboardFocusGrid) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (message != #SetKeyboardFocusGrid)" : RETURN
'
	gg = grid
	IF ((v0 != 0) AND (v0 != gg)) THEN
		IF (v0 < 0) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (v0 < 0)" : RETURN
		IF (v0 > upperGrid) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (v0 > upperGrid)" : RETURN
		gg = v0
	END IF
'
	window = grid[gg].window
	IF (gg = keyboardFocusGrid) THEN RETURN
	IF (window <= 0) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (grid[gg].window <= 0)" : RETURN
'
	DO WHILE (grid[gg].can AND $$Focus)
		focusKid = grid[gg].focusKid
		IF focusKid THEN
			IF (focusKid > UBOUND(kids[gg,])) THEN
				PRINT "XuiSetKeyboardFocusGrid() : error : (focusKid > UBOUND(kids[gg,])" : RETURN
			END IF
			gg = kids[gg,focusKid]
			IF (gg <= 0) THEN PRINT "XuiSetKeyboardFocusGrid() : error : (focus grid <= 0)" : RETURN
		ELSE
			XuiWindow (window, #WindowSetKeyboardFocusGrid, gg, 0, 0, 0, 0, 0)
			EXIT DO
		END IF
	LOOP
END FUNCTION
'
'
' ###############################
' #####  XuiSetKidArray ()  #####
' ###############################
'
FUNCTION  XuiSetKidArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetKidArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetKidArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetKidArray) THEN PRINT "XuiSetKidArray() : error : (message != #SetKidArray)" : RETURN
'
	upper = UBOUND (r1[])
	IF (upper < 0) THEN RETURN				' error - invalid kid array
	IF (grid != r1[0]) THEN RETURN		' error - invalid kid array element
	DIM temp[upper]
'
	FOR i = 0 TO upper
		temp[i] = r1[i]									' make copy of kid array in r1[]
	NEXT i

	SWAP temp[], kids[grid,]					' replace kid array
	DIM temp[]
END FUNCTION
'
'
' ########################################
' #####  XuiSetCharacterMapArray ()  #####
' ########################################
'
FUNCTION  XuiSetCharacterMapArray (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetCharacterMapArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetCharacterMapArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetCharacterMapArray) THEN PRINT "XuiSetCharacterMapArray() : error : (message != #SetCharacterMapArray)" : RETURN
'
	XgrSetGridCharacterMapArray (grid, @r1[])
END FUNCTION
'
'
' ########################################
' #####  XuiSetCharacterMapEntry ()  #####
' ########################################
'
FUNCTION  XuiSetCharacterMapEntry (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetCharacterMapEntry() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetCharacterMapEntry() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetCharacterMapEntry) THEN PRINT "XuiSetCharacterMapEntry() : error : (message != #SetCharacterMapEntry)" : RETURN
'
' verify valid arguments
'
	IF (v0 < 0) THEN RETURN
	IF (v1 < 0) THEN RETURN
	IF (v0 > 65535) THEN RETURN
	IF (v1 > 65535) THEN RETURN
'
	DIM map[]
	XgrGetGridCharacterMapArray (grid, @map[])
'
	IFZ map[] THEN
		IF (v0 > 255) THEN			' one-byte or two-byte characters?
			upper = 65535					' two-byte
		ELSE
			upper = 255						' one-byte
		END IF
		DIM map[upper]
		FOR i = 0 TO upper
			map[i] = i
		NEXT i
		map[v0] = v1						' map character
	ELSE
		upper = UBOUND (map[])
		IF (v0 > upper) THEN
			old = upper
			upper = 65535
			REDIM map[upper]
			FOR i = old+1 TO upper
				map[i] = i
			NEXT i
		END IF
		map[v0] = v1
	END IF
'
	XgrSetGridCharacterMapArray (grid, @map[])
END FUNCTION
'
'
' #################################
' #####  XuiSetMaxMinSize ()  #####
' #################################
'
FUNCTION  XuiSetMaxMinSize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetMaxMinSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetMaxMinSize() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetMaxMinSize) THEN PRINT "XuiSetMaxMinSize() : error : (message != #SetMaxMinSize)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].maxWidth	= v0
	IF (v1 != -1) THEN grid[grid].maxHeight	= v1
	IF (v2 != -1) THEN grid[grid].minWidth	= v2
	IF (v3 != -1) THEN grid[grid].minHeight	= v3
END FUNCTION
'
'
' #####################################
' #####  XuiSetMenuEntryArray ()  #####
' #####################################
'
FUNCTION  XuiSetMenuEntryArray (grid, message, v0, v1, v2, v3, kid, (r1, MENUENTRY r1[]))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED  MENUENTRY  menuentry[]
	MENUENTRY  me[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetMenuEntryArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetMenuEntryArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetMenuEntryArray) THEN PRINT "XuiSetMenuEntryArray() : error : (message != #SetMenuEntryArray)" : RETURN
'
	IF r1[] THEN
		upper = UBOUND (r1[])
		DIM me[upper]
		FOR i = 0 TO upper
			me[i] = r1[i]
		NEXT i
	END IF
	SWAP me[], menuentry[grid,]
END FUNCTION
'
'
' ##################################
' #####  XuiSetMessageFunc ()  #####
' ##################################
'
FUNCTION  XuiSetMessageFunc (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	kids[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetMessageFunc() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetMessageFunc() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetMessageFunc) THEN PRINT "XuiSetMessageFunc() : error : (message != #SetMessageFunc)" : RETURN
'
	IF (v0 <= 0) THEN PRINT "XuiSetMessageFunc() : error : (v0 <= 0 : bad message number)" : RETURN
	IF (v0 > upperMessage) THEN
		NewMessage (v0)
		IF (v0 > upperMessage) THEN
			PRINT "XuiSetMessageFunc() : error : (v0 > upperMessage : bad message number)"
			RETURN
		END IF
	END IF
'
	upper = upperMessage
	gridType = grid[grid].gridType
	ugmf = UBOUND (gridMessageFunc[grid,])
	ugtmf = UBOUND (gridTypeMessageFunc[gridType,])
	IF (upper < ugtmf) THEN upper = ugtmf
	IF (upper < ugmf) THEN upper = ugmf
'
	IFZ gridMessageFunc[grid, ] THEN
		ugmf = upper
		DIM temp[upper]
		FOR m = 0 TO ugtmf
			temp[m] = gridTypeMessageFunc[gridType,m]
		NEXT m
		ATTACH temp[] TO gridMessageFunc[grid, ]
	END IF
'
	IF (v0 > ugmf) THEN
		ATTACH gridMessageFunc[grid, ] TO temp[]
		REDIM temp[upper]
		ATTACH temp[] TO gridMessageFunc[grid, ]
	END IF
'
	gridMessageFunc[grid,v0] = v1
END FUNCTION
'
'
' #######################################
' #####  XuiSetMessageFuncArray ()  #####
' #######################################
'
FUNCTION  XuiSetMessageFuncArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	gridTypeMessageFunc[]
	SHARED	gridMessageFunc[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetMessageFuncArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetMessageFuncArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetMessageFuncArray) THEN PRINT "XuiSetMessageFuncArray() : error : (message != #SetMessageFuncArray)" : RETURN
'
	SWAP gridMessageFunc[grid, ], r1[] : DIM r1[]
END FUNCTION
'
'
' #################################
' #####  XuiSetMessageSub ()  #####
' #################################
'
FUNCTION  XuiSetMessageSub (grid, message, v0, v1, v2, v3, kid, r1)
	PRINT "XuiSetMessageSub() : unimplemented : (!!! are you sure you want to do this !!!)"
END FUNCTION
'
'
' ######################################
' #####  XuiSetMessageSubArray ()  #####
' ######################################
'
FUNCTION  XuiSetMessageSubArray (grid, message, v0, v1, v2, v3, kid, r1)
	PRINT "XuiSetMessageSubArray() : unimplemented : (!!! are you sure you want to do this !!!)"
END FUNCTION
'
'
' ##################################
' #####  XuiSetModalWindow ()  #####
' ##################################
'
FUNCTION  XuiSetModalWindow (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	WINDOW	windowInfo[]
	SHARED	GRID	grid[]
	SHARED	upperMessage
	SHARED	upperGrid
'
	IF (grid <= 0) THEN PRINT "XuiGetMessageSubArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiGetMessageSubArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetModalWindow) THEN PRINT "XuiSetModalWindow() : error : (message != #SetModalWindow)" : RETURN
'
	IF ((v0 <= 0) AND (v1 > 0)) THEN
		IF (v1 < upperGrid) THEN v0 = grid[v1].window
	END IF
	IF (v0 < 0) THEN v0 = grid[grid].window
	IF (v0 < 0) THEN v0 = 0
	XgrGetModalWindow (@mw)
	IF (v0 = mw) THEN RETURN
	XgrSetModalWindow (0)
	IFZ v0 THEN RETURN
	XuiWindow (v0, #WindowSelect, 0, 0, 0, 0, 0, 0)
	XgrProcessMessages (-1)
	XgrSetModalWindow (v0)
END FUNCTION
'
'
' #############################
' #####  XuiSetParent ()  #####
' #############################
'
FUNCTION  XuiSetParent (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetParent() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetParent() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetParent) THEN PRINT "XuiSetParent() : error : (message != #SetParent)" : RETURN
'
	PRINT "XuiSetParent() : Unimplemented because it probably shouldn't be possible to change parent."
	RETURN
'
	IF (v0 >= 0) THEN
		grid[grid].parent = v0
		XgrSetGridParent (grid, v0)
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiSetRedrawFlags ()  #####
' ##################################
'
FUNCTION  XuiSetRedrawFlags (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetRedrawFlags() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetRedrawFlags() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetRedrawFlags) THEN PRINT "XuiSetRedrawFlags() : error : (message != #SetRedrawFlags)" : RETURN
'
	grid[grid].redrawFlags = v0
END FUNCTION
'
'
' ###########################
' #####  XuiSetSize ()  #####
' ###########################
'
FUNCTION  XuiSetSize (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetSize() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetSize() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetSize) THEN PRINT "XuiSetSize() : error : (message != #SetSize)" : RETURN
'
	XgrSetGridPositionAndSize (grid, v0, v1, v2, v3)
END FUNCTION
'
'
' ############################
' #####  XuiSetState ()  #####
' ############################
'
FUNCTION  XuiSetState (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetState() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetState() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetState) THEN PRINT "XuiSetState() : error : (message != #SetState)" : RETURN
'
	grid[grid].state			= v0
	grid[grid].keyboard		= v1
	grid[grid].mouse			= v2
	grid[grid].redraw			= v3
END FUNCTION
'
'
' ############################
' #####  XuiSetStyle ()  #####
' ############################
'
FUNCTION  XuiSetStyle (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetStyle() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetStyle() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetStyle) THEN PRINT "XuiSetStyle() : error : (message != #SetStyle)" : RETURN
'
	IF (v0 != -1) THEN grid[grid].style = v0
	IF (v1 != -1) THEN grid[grid].styleMax = v1
END FUNCTION
'
'
' ###############################
' #####  XuiSetTabArray ()  #####
' ###############################
'
FUNCTION  XuiSetTabArray (grid, message, v0, v1, v2, v3, kid, (r1, r1[]))
	SHARED  GRID  grid[]
	SHARED  tabArray[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTabArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTabArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTabArray) THEN PRINT "XuiSetTabArray() : error : (message != #SetTabArray)" : RETURN
'
	IF (r1 = -1) THEN RETURN
	DIM tabs[]
'
	IF r1[] THEN
		type = TYPE (r1[])
		IF ((type = $$SLONG) OR (type = $$ULONG) OR (type = $$XLONG)) THEN
			XstQuickSort (@r1[], @empty[], 0, 0, 0)
			upper = UBOUND (r1[])
			DIM tabs[upper]
			d = 0
			old = -1
			FOR i = 0 TO upper
				new = r1[i]
				IF (new > old) THEN
					tabs[d] = r1[i]
					INC d
				END IF
			NEXT i
			DEC d
			REDIM tabs[d]
			SWAP tabs[], tabArray[grid,]
			DIM tabs[]
		END IF
	END IF
END FUNCTION
'
'
' ###############################
' #####  XuiSetTabWidth ()  #####
' ###############################
'
FUNCTION  XuiSetTabWidth (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED  GRID  grid[]
	SHARED	tabArray[]
	SHARED  upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTabWidth() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTabWidth() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTabWidth) THEN PRINT "XuiSetTabWidth() : error : (message != #SetTabWidth)" : RETURN
'
	IF (v0 > 0) THEN grid[grid].tabWidth = v0
END FUNCTION
'
'
' ################################
' #####  XuiSetTextArray ()  #####
' ################################
'
FUNCTION  XuiSetTextArray (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTextArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextArray) THEN PRINT "XuiSetTextArray() : error : (message != #SetTextArray)" : RETURN
'
	XstCopyArray (@r1$[], @new$[])
	ATTACH textArray$[grid, ] TO temp$[]
	ATTACH new$[] TO textArray$[grid, ]
	DIM temp$[]
END FUNCTION
'
'
' ####################################
' #####  XuiSetTextArrayLine ()  #####
' ####################################
'
FUNCTION  XuiSetTextArrayLine (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetTextArrayLine() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextArrayLine() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextArrayLine) THEN PRINT "XuiSetTextArrayLine() : error : (message != #SetTextArrayLine)" : RETURN
'
	upper = UBOUND(textArray$[grid, ])
	IF ((v0 < 0) OR (v0 > upper)) THEN v1 = -1 : v3 = upper : RETURN
	textArray$[grid,v0] = r1$
	v3 = upper
	v1 = v0
END FUNCTION
'
'
' #####################################
' #####  XuiSetTextArrayLines ()  #####
' #####################################
'
FUNCTION  XuiSetTextArrayLines (grid, message, v0, v1, v2, v3, kid, (r1$, r1$[]))
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textArray$[]
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetTextArrayLines() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextArrayLines() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextArrayLines) THEN PRINT "XuiSetTextArrayLines() : error : (message != #SetTextArrayLines)" : RETURN
'
	top = UBOUND(r1$[])
	v3 = UBOUND(textArray$[grid, ])
	IF ((v0 < 0) OR (v0 > v3+2) OR (v1 <= 0) OR (v2 < 0)) THEN v1 = -1 : RETURN
	last = v0 + v1 - 1
	IF (last > v3) THEN
		REDIM textArray$[last]
		v3 = last
	END IF
	i = v2
	FOR j = v0 TO last
		IF (i <= top) THEN
			textArray$[grid,j] = r1$[i]
		ELSE
			textArray$[grid,j] = ""
		END IF
		INC i
	NEXT j
END FUNCTION
'
'
' ###################################
' #####  XuiSetTextFilename ()  #####
' ###################################
'
FUNCTION  XuiSetTextFilename (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	sysTextFilename$
	SHARED	userTextFilename$
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTextFilename() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextFilename() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextFilename) THEN PRINT "XuiSetTextFilename() : error : (message != #SetTextFilename)" : RETURN
'
	IF ##WHOMASK THEN
		userTextFilename$ = r1$
	ELSE
		sysTextFilename$ = r1$
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiSetTextSpacing ()  #####
' ##################################
'
FUNCTION  XuiSetTextSpacing (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTextSpacing() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextSpacing() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextSpacing) THEN PRINT "XuiSetTextSpacing() : error : (message != #SetTextSpacing)" : RETURN
'
	grid[grid].xgap = v0
	grid[grid].ygap = v1
END FUNCTION
'
'
' #################################
' #####  XuiSetTextString ()  #####
' #################################
'
FUNCTION  XuiSetTextString (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTextString() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextString() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextString) THEN PRINT "XuiSetTextString() : error : (message != #SetTextString)" : RETURN
'
	textString$[grid] = r1$
END FUNCTION
'
'
' ##################################
' #####  XuiSetTextStrings ()  #####
' ##################################
'
FUNCTION  XuiSetTextStrings (grid, message, v0, v1, v2, v3, kid, r1$[])
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	textString$[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$[])
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetTextStrings() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTextStrings() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTextStrings) THEN PRINT "XuiSetTextStrings() : error : (message != #SetTextStrings)" : RETURN
'
	IFZ kids[grid, ] THEN
		IF r1$[] THEN XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, 0, r1$[0])
	ELSE
		final = UBOUND (r1$[])
		upper = UBOUND (kids[grid,])
		upper = MIN (final, upper)
		FOR i = 0 TO upper
			XuiSendMessage (grid, #SetTextString, 0, 0, 0, 0, i, r1$[i])
		NEXT i
	END IF
END FUNCTION
'
'
' ##############################
' #####  XuiSetTexture ()  #####
' ##############################
'
FUNCTION  XuiSetTexture (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetTexture() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTexture() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTexture) THEN PRINT "XuiSetTexture() : error : (message != #SetTexture)" : RETURN
'
	IF (v0 >= 0) THEN grid[grid].texture = v0
END FUNCTION
'
'
' ############################
' #####  XuiSetTimer ()  #####
' ############################
'
FUNCTION  XuiSetTimer (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetTimer() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetTimer() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetTimer) THEN PRINT "XuiSetTimer() : error : (message != #SetTimer)" : RETURN
'
	grid[grid].timer = v0
END FUNCTION
'
'
' ############################
' #####  XuiSetValue ()  #####  r1 = offset of value to set
' ############################
'
FUNCTION  XuiSetValue (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetValue() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetValue() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetValue) THEN PRINT "XuiSetValue() : error : (message != #SetValue)" : RETURN
'
	IF values[grid, ] THEN
		upper = UBOUND (values[grid, ])
		IF (upper >= r1) THEN values[grid, r1] = v0
	END IF
END FUNCTION
'
'
' #############################
' #####  XuiSetValues ()  #####  r1 = offset of 1st value to set
' #############################
'
FUNCTION  XuiSetValues (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	values[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSetValues() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetValues() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetValues) THEN PRINT "XuiSetValues() : error : (message != #SetValues)" : RETURN
'
	i = r1
	IF values[grid, ] THEN
		upper = UBOUND (values[grid, ])
		IF (upper >= i+0) THEN values[grid, i+0] = v0
		IF (upper >= i+1) THEN values[grid, i+1] = v1
		IF (upper >= i+2) THEN values[grid, i+2] = v2
		IF (upper >= i+3) THEN values[grid, i+3] = v3
	END IF
END FUNCTION
'
'
' #################################
' #####  XuiSetValueArray ()  #####
' #################################
'
FUNCTION  XuiSetValueArray (grid, message, v0, v1, v2, v3, kid, r1[])
	SHARED	kids[]
	SHARED	values[]
	SHARED	upperGrid
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1[])
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetValueArray() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetValueArray() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetValueArray) THEN PRINT "XuiSetValueArray() : error : (message != #SetValueArray)" : RETURN
'
	IFZ r1[] THEN
		SWAP r1[], values[grid, ]
		DIM r1[]
		RETURN
	END IF
'
	upper = UBOUND (r1[])
	DIM temp[upper]
'
	FOR i = 0 TO upper
		temp[i] = r1[i]
	NEXT i
'
	SWAP temp[], values[grid, ]
	DIM temp[]
END FUNCTION
'
'
' #####################################
' #####  XuiSetWindowFunction ()  #####
' #####################################
'
FUNCTION  XuiSetWindowFunction (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetWindowFunction() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetWindowFunction() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetWindowFunction) THEN PRINT "XuiSetWindowFunction() : error : (message != #SetWindowFunction)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiSetWindowFunction() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowSetFunction, v0, v1, v2, v3, 0, r1)
END FUNCTION
'
'
' #################################
' #####  XuiSetWindowIcon ()  #####
' #################################
'
FUNCTION  XuiSetWindowIcon (grid, message, v0, v1, v2, v3, kid, (r1, r1$))
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetWindowIcon() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetWindowIcon() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetWindowIcon) THEN PRINT "XuiSetWindowIcon() : error : (message != #SetWindowIcon)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiSetWindowIcon() : error : (grid[grid].window <= 0)" : RETURN
	IF ((r1$ != "") AND (r1 != -1)) THEN
		XgrRegisterIcon (@r1$, @v0)
		IF (v0 < 0) THEN v0 = 0
		XuiWindow (window, #WindowSetIcon, v0, v1, v2, v3, 0, 0)
	ELSE
		IF (v0 >= 0) THEN
			XgrIconNumberToName (v0, @icon$)
			IF icon$ THEN XuiWindow (window, #WindowSetIcon, v0, v1, v2, v3, 0, 0)
		END IF
	END IF
END FUNCTION
'
'
' ##################################
' #####  XuiSetWindowTitle ()  #####
' ##################################
'
FUNCTION  XuiSetWindowTitle (grid, message, v0, v1, v2, v3, kid, r1$)
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, @r1$)
		RETURN
	END IF
'
	IF (grid < 0) THEN PRINT "XuiSetWindowTitle() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSetWindowTitle() : error : (grid > upperGrid)" : RETURN
	IF (message != #SetWindowTitle) THEN PRINT "XuiSetWindowTitle() : error : (message != #SetWindowTitle)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiSetWindowTitle() : error : (grid[grid].window <= 0)" : RETURN
	XuiWindow (window, #WindowSetTitle, v0, v1, v2, v3, 0, @r1$)
END FUNCTION
'
'
' ##############################
' #####  XuiShowWindow ()  #####
' ##############################
'
FUNCTION  XuiShowWindow (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiShowWindow() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiShowWindow() : error : (grid > upperGrid)" : RETURN
	IF (message != #ShowWindow) THEN PRINT "XuiShowWindow() : error : (message != #ShowWindow)" : RETURN
'
	window = grid[grid].window
	IF (window <= 0) THEN PRINT "XuiShowWindow() : error : (grid[grid].window <= 0)" : RETURN
	func = windowInfo[window].func
	@func (window, #WindowShow, v0, v1, v2, v3, 0, 0)
	IFZ func THEN PRINT "XuiShowWindow() : error : (window with no windowFunc)" : RETURN
END FUNCTION
'
'
' ##############################
' #####  XuiStartTimer ()  #####
' ##############################
'
FUNCTION  XuiStartTimer (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, v0, v1, v2, v3, kid, r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiStartTimer() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiStartTimer() : error : (grid > upperGrid)" : RETURN
	IF (message != #StartTimer) THEN PRINT "XuiStartTimer() : error : (message != #StartTimer)" : RETURN
'
	IF (v0 <= 0) THEN v0 = grid[grid].timer
	XgrSetGridTimer (grid, v0)
END FUNCTION
'
'
' #################################
' #####  XuiSystemMessage ()  #####
' #################################
'
FUNCTION  XuiSystemMessage (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "XuiSystemMessage() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "XuiSystemMessage() : error : (grid > upperGrid)" : RETURN
	IF (message != #SystemMessage) THEN PRINT "XuiSystemMessage() : error : (message != #SystemMessage)" : RETURN
'
	XuiCallback (grid, message, v0, v1, v2, v3, kid, r1)
END FUNCTION
'
'
' #################################
' #####  XuiTextModifyNot ()  #####  Expects TextEvent message
' #################################
'
FUNCTION  XuiTextModifyNot (grid, message, v0, v1, v2, v3, r0, r1)
'
	IF (message != #TextEvent) THEN PRINT "XuiTextModifyNot : error : (message != TextEvent)": RETURN
	IF (v2{$$StateContents} = 1) THEN r0 = -1
END FUNCTION
'
'
' ###############################
' #####  XuiReturnZeros ()  #####
' ###############################
'
FUNCTION  XuiReturnZeros (grid, message, v0, v1, v2, v3, r0, r1)
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r0 = 0 : r1 = 0
END FUNCTION
'
'
' ###############################
' #####  AddKidToParent ()  #####
' ###############################
'
FUNCTION  AddKidToParent (kid, parent)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IF (kid <= 0) THEN PRINT "AddKidToParent() : error : (kid <= 0)" : RETURN
	IF (parent <= 0) THEN PRINT "AddKidToParent() : error : (parent <= 0)" : RETURN
	IF (kid > upperGrid) THEN PRINT "AddKidToParent() : error : (kid > upperGrid)" : RETURN
	IF (parent > upperGrid) THEN PRINT "AddKidToParent() : error : (parent > upperGrid)" : RETURN
'
	IFZ kids[parent, ] THEN
		DIM temp[7]
		temp[0] = parent
		temp[1] = kid
		ATTACH temp[] TO kids[parent, ]
	ELSE
		upper = UBOUND (kids[parent, ])
		done = $$FALSE
		FOR i = 0 TO upper
			IFZ kids[parent,i] THEN
				kids[parent,i] = kid
				done = $$TRUE
				EXIT FOR
			END IF
		NEXT i
		IFZ done THEN
			entry = upper + 1
			upper = upper + 8
			ATTACH kids[parent, ] TO temp[]
			REDIM temp[upper]
			ATTACH temp[] TO kids[parent, ]
			kids[parent,i] = kid
		END IF
	END IF
	grid[kid].parent = parent
END FUNCTION
'
'
' ##############################
' #####  ComputeLimits ()  #####
' ##############################
'
' Input:	a0, a1, a2, a3		= lowest, low, high, highest [line in document]
'					lo, hi						= win lo and hi limits [yWin of top/bottom of trough]
' Output:	low, high					= low and high value between lo and hi
'
FUNCTION  ComputeLimits (low, high, lo, hi, a0, a1, a2, a3)

	IFZ a3 THEN					' zero size document
		low		= lo
		high	= hi
		RETURN
	END IF
'
	IF a0 THEN
		a1	= a1 - a0
		a2	= a2 - a0
		a3	= a3 - a0
	END IF
'
	IF (a1 < 0) THEN a1 = 0
	IF (a1 > a3) THEN a1 = a3
	IF (a2 < 0) THEN a2 = 0
	IF (a2 > a3) THEN a2 = a3
	IF (a2 < a1) THEN SWAP a1, a2
'
'	lowFactor#		= DOUBLE(a1) / DOUBLE(a3)				' compiler bug
'	highFactor#		= DOUBLE(a2) / DOUBLE(a3)
	a1# = DOUBLE(a1)
	a2# = DOUBLE(a2)
	a3# = DOUBLE(a3)
	lowFactor#		= a1# / a3#
	highFactor#		= a2# / a3#

	range					= hi - lo
	low						= lowFactor# * range
	high					= highFactor# * range
'
'	IF ((high - low) < 7) THEN
'		center			= (high + low) >> 1
'		low					= center - 3
'		high				= center + 3
'	END IF
'
	IF (low < 0) THEN
		high				= high - low
		low					= 0
	END IF
'
	IF (high > range) THEN high = range
	low						= low + lo
	high					= high + lo
END FUNCTION
'
'
' #############################
' #####  DeselectGrid ()  #####
' #############################
'
FUNCTION  DeselectGrid (grid)
	SHARED	selectGrid,  gripGrid
	SHARED	upperGridType
	SHARED	GRID	grid[]
	SHARED	GRID	gridType[]
	SHARED	WINDOW	windowInfo[]
	SHARED	selectX,  selectY,  selectW,  selectH
'
	IFZ selectGrid THEN PRINT "DeselectGrid() : (no selectGrid exists)" : RETURN
	IF (grid != selectGrid) THEN PRINT "DeselectGrid() : (grid != selectGrid)" : RETURN
	XgrGetGridPositionAndSize (gripGrid, @xWin, @yWin, @w, @h)
'
	ww = (w + 2) AND -4						' width to nearest MOD 4
	hh = (h + 2) AND -4						' height to nearest MOD 4
'
	XuiSendMessage (gripGrid, #Destroy, 0, 0, 0, 0, 0, 0)
	XuiSendMessage (grid, #Resize, xWin, yWin, ww, hh, 0, 0)
	XuiSendMessage (grid, #GetSize, 0, 0, @width, @height, 0, 0)
'
	width = (width + 3) AND -4
	height = (height + 3) AND -4
	XuiSendMessage (grid, #Resize, @xWin, @yWin, @width, @height, 0, 0)
'
	can = grid[grid].can
	window = grid[grid].window
	gridType = grid[grid].gridType
	base = windowInfo[window].graph
'
	gridType[gridType].x = xWin
	gridType[gridType].y = yWin
	gridType[gridType].width = width
	gridType[gridType].height = height
'
	selectX = xWin
	selectY = yWin
	selectW = width
	selectH = height
'
	IF (ww > w) THEN w = ww
	IF (hh > h) THEN h = hh
	IF (width > w) THEN w = width
	IF (height > h) THEN h = height
	XuiSendMessage (grid, #Enable, 0, 0, 0, 0, 0, 0)
	XuiWindow (window, #WindowRedraw, xWin, yWin, w, h, 0, 0)
	IF (can AND $$Focus) THEN XuiSendMessage (selectGrid, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
	selectGrid = 0
	gripGrid = 0
END FUNCTION
'
'
' ################################
' #####  DrawTextSegment ()  #####
' ################################
'
FUNCTION  DrawTextSegment (grid, text$, back, draw, xib, yib, topIndent, lineHeight, tabWidth, tabs[])
'
	IFZ text$ THEN RETURN
	tabIndex = INSTR (text$, "\t")
	XgrGetDrawpoint (grid, @x, @y)
	XuiGetColor (grid, #GetColor, @xback, @xdraw, 0, 0, 0, 0)
	XuiSetColor (grid, #SetColor, back, draw, -1, -1, 0, -1)
	XgrFillBox (grid, xback, 0, y, xib-1, y+lineHeight-1)		' cursor pixels
'
	IFZ tabIndex THEN
		XgrDrawTextFill (grid, draw, @text$)
		XuiSetColor (grid, #SetColor, xback, xdraw, -1, -1, 0, -1)
		RETURN
	END IF
'
	i = 1
	lenSeg = LEN (text$)
	IF tabs[] THEN uTab = UBOUND (tabs[])
	IFZ tabWidth THEN tabWidth = 16
'
	DO
		IF (tabIndex != i) THEN
			XgrDrawTextFill (grid, draw, MID$ (text$, i, (tabIndex - i)))
			i = tabIndex
		END IF
		INC i																			' bump the charPointer
		XgrGetDrawpoint (grid, @x, @y)
		xTab = x + topIndent - xib
		SELECT CASE TRUE
			CASE tabs[]															' tabArray
						xStop = -1
						FOR j = 0 TO uTab
							IF (xTab < tabs[j]) THEN
								xStop = tabs[j]
								EXIT FOR
							END IF
						NEXT j
						IF (xStop < 0) THEN NEXT CASE			' beyond list : revert to tabWidth
						xTab = xStop
			CASE ELSE																' tabWidth
						xTab = tabWidth * ((xTab / tabWidth) + 1)
		END SELECT
		xTab = xTab - topIndent + xib
		IF (x != xTab) THEN
			XgrFillBox (grid, back, x, y, xTab, y + lineHeight - 1)
			XgrMoveTo (grid, xTab, y)
		END IF
		tabIndex = INSTR (text$, "\t", i)
		IFZ tabIndex THEN EXIT DO
	LOOP
	IF (i <= lenSeg) THEN XgrDrawTextFill (grid, draw, MID$ (text$, i))
	XuiSetColor (grid, #SetColor, xback, xdraw, -1, -1, 0, -1)
END FUNCTION
'
'
' ###################################
' #####  GetDefaultGridInfo ()  #####
' ###################################
'
FUNCTION  GetDefaultGridInfo (GRID proto)
	SHARED	backgroundColor,  drawingColor
	SHARED	lowlightColor,  highlightColor
	SHARED	dullColor, accentColor
	SHARED	lowtextColor,  hightextColor
	SHARED	defaultFont
	SHARED	GRID	defaultGridInfo
	STATIC	entered
'
	IFZ entered THEN GOSUB Initialize
	proto = defaultGridInfo
	RETURN
'
'
' *****  Initialize  *****
'
SUB Initialize
	entered = $$TRUE
	font = defaultFont
	XgrGetFontMetrics (font, @maxCharWidth, @maxCharHeight, @ascent, @decent, @gap, @flags)
	IF maxCharWidth THEN tab = maxCharWidth + maxCharWidth ELSE tab = 16
	defaultGridInfo.grid							= 0
	defaultGridInfo.gridType					= 0
	defaultGridInfo.gridFunc					= 0
	defaultGridInfo.gridWindow				= 0
	defaultGridInfo.window						= 0
	defaultGridInfo.parent						= 0
	defaultGridInfo.cursor						= #defaultCursor
	defaultGridInfo.clip							= 0
	defaultGridInfo.focusBackground		= backgroundColor
	defaultGridInfo.focusDrawing			= drawingColor
	defaultGridInfo.focusLowlight			= lowlightColor
	defaultGridInfo.focusHighlight		= accentColor
	defaultGridInfo.focusDull					= dullColor
	defaultGridInfo.focusAccent				= accentColor
	defaultGridInfo.focusLowtext			= lowtextColor
	defaultGridInfo.focusHightext			= accentColor
	defaultGridInfo.image							= 0
	defaultGridInfo.imageAlign				= 0
	defaultGridInfo.imageIndentX			= 0
	defaultGridInfo.imageIndentY			= 0
	defaultGridInfo.imageStartX				= 0
	defaultGridInfo.imageStartY				= 0
	defaultGridInfo.imageWidth				= 0
	defaultGridInfo.imageHeight				= 0
	defaultGridInfo.x									= 0
	defaultGridInfo.y									= 0
	defaultGridInfo.width							= 32
	defaultGridInfo.height						= 32
	defaultGridInfo.maxWidth					= $$MAX
	defaultGridInfo.maxHeight					= $$MAX
	defaultGridInfo.minWidth					= 12
	defaultGridInfo.minHeight					= 12
	defaultGridInfo.backgroundColor		= backgroundColor
	defaultGridInfo.drawingColor			= drawingColor
	defaultGridInfo.lowlightColor			= lowlightColor
	defaultGridInfo.highlightColor		= highlightColor
	defaultGridInfo.dullColor					= dullColor
	defaultGridInfo.accentColor				= accentColor
	defaultGridInfo.lowtextColor			= lowtextColor
	defaultGridInfo.hightextColor			= hightextColor
	defaultGridInfo.left							= 0
	defaultGridInfo.top								= 0
	defaultGridInfo.right							= 0
	defaultGridInfo.bottom						= 0
	defaultGridInfo.redrawFlags				= $$RedrawClearBorder
	defaultGridInfo.buffer						= 0
	defaultGridInfo.timer							= 0
	defaultGridInfo.font							= font
	defaultGridInfo.indentLeft				= 4
	defaultGridInfo.indentTop					= 0
	defaultGridInfo.indentRight				= 4
	defaultGridInfo.indentBottom			= 0
	defaultGridInfo.align							= 0
	defaultGridInfo.justify						= 0
	defaultGridInfo.texture						= 0
	defaultGridInfo.tabWidth					= tab
	defaultGridInfo.border						= 0
	defaultGridInfo.borderUp					= 0
	defaultGridInfo.borderDown				= 0
	defaultGridInfo.style							= 0
	defaultGridInfo.styleMax					= 3
	defaultGridInfo.group							= 0
	defaultGridInfo.can								= 0
	defaultGridInfo.kind							= 0
	defaultGridInfo.focus							= 0
	defaultGridInfo.focusKid					= 0
	defaultGridInfo.inputTextArray		= 0					' kid # that inputs text array
	defaultGridInfo.inputTextString		= 0					' kid # that inputs text string
	defaultGridInfo.selectable				= 0
	defaultGridInfo.whomask						= 0
	defaultGridInfo.state							= $$TRUE
	defaultGridInfo.keyboard					= $$TRUE
	defaultGridInfo.mouse							= $$TRUE
	defaultGridInfo.redraw						= $$TRUE
END SUB
END FUNCTION
'
'
' ###########################
' #####  GuiProgram ()  #####
' ###########################
'
FUNCTION  GuiProgram ()
'
	XitQueryFunction (@"PROLOG", @exists)					: IFZ exists THEN RETURN
'	XitQueryFunction (@"Entry", @exists)					: IFZ exists THEN RETURN
	XitQueryFunction (@"InitGui", @exists)				: IFZ exists THEN RETURN
	XitQueryFunction (@"CreateWindows", @exists)	: IFZ exists THEN RETURN
	RETURN ($$TRUE)
END FUNCTION
'
'
' ###################################
' #####  FreeGridFromParent ()  #####
' ###################################
'
FUNCTION  FreeGridFromParent (grid, parent)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
'
	IFZ parent THEN RETURN
	IF (grid <= 0) THEN PRINT "FreeGridFromParent() : error : (grid <= 0)" : RETURN
	IF (parent <= 0) THEN PRINT "FreeGridFromParent() : error : (parent <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "FreeGridFromParent() : error : (grid > upperGrid)" : RETURN
	IF (parent > upperGrid) THEN PRINT "FreeGridFromParent() : error : (parent > upperGrid)" : RETURN
	IF (parent != grid[grid].parent) THEN PRINT "FreeGridFromParent() : error : (parent != grid[grid].parent)" : RETURN
'
	found = $$FALSE
	grid[grid].parent = 0
	upper = UBOUND(kids[parent,])
	IF (upper <= 0) THEN PRINT "FreeGridFromParent() : error : (kids[parent,] is empty)" : RETURN
	FOR i = 0 TO upper
		g = kids[parent,i]
		IF (g = grid) THEN
			kids[parent,i] = 0
			found = $$TRUE
			EXIT FOR
		END IF
	NEXT i
	IFZ found THEN PRINT "FreeGridFromParent() : error : (kid not in kids[parent,])" : RETURN
END FUNCTION
'
'
' #####################################
' #####  GetGridTypePrototype ()  #####
' #####################################
'
FUNCTION  GetGridTypePrototype (gridType, GRID proto)
	SHARED	upperGridType
	SHARED	GRID	gridType[]
'
	IF (gridType < 0) THEN PRINT "GetGridTypePrototype() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "GetGridTypePrototype() : error : (gridType > upperGridType)" : RETURN
'
	proto = gridType[gridType]
END FUNCTION
'
'
' #############################
' #####  GetHelpEntry ()  #####
' #############################
'
FUNCTION  GetHelpEntry (grid, help$, file$, entry$, header, start, count, text$[])
	SHARED  upperGrid
	SHARED	helpfile$
	SHARED	sysSetFile$
	SHARED  userSetFile$
	SHARED	gridName$[]
	SHARED	helpText$[]
	SHARED  GRID  grid[]
'
	DIM text$[]
	file$ = ""
	entry$ = ""
	header = -1
	start = -1
	final = -1
	count = 0
	IFZ help$ THEN
		XuiSendMessage (grid, #GetGridName, 0, 0, 0, 0, 0, @gridName$)
		IFZ gridName$ THEN RETURN
		help$ = ":" + gridName$
	END IF
	XstStringToStringArray (@help$, @text$[])
	upper = UBOUND (text$[])
	first$ = TRIM$ (text$[0])
	colon = RINSTR (first$, ":")
	lefty = INSTR (first$, "[")
	righty = INSTR (first$, "]")
	title = $$FALSE
	text = $$FALSE
'
	SELECT CASE TRUE
		CASE ((lefty = 1) AND (lefty < righty))	: text = $$TRUE : title = $$TRUE
		CASE (colon = 0)												: text = $$TRUE
	END SELECT
'
	IF text THEN
		upper = UBOUND(text$[])
		count = upper + 1
		IF title THEN
			entry$ = text$[0]
			text$[0] = ""
			DEC count
			FOR i = 1 TO upper
				ATTACH text$[i] TO text$[i-1]
			NEXT i
		END IF
		RETURN ($$FALSE)
	END IF
	DIM text$[]
'
' Get the text from the help file into helpText$[]
'
	who = grid[grid].whomask
	IF (colon = 1) THEN
		entry$ = help$
		IF who THEN file$ = userSetFile$ ELSE file$ = sysSetFile$
	ELSE
		file$ = LEFT$(help$,colon-1)
		entry$ = MID$(help$,colon)
	END IF
'
	IFZ file$ THEN
		IF who THEN
			XxxXitGetUserProgramName (@file$)
			file$ = XstPathString$ (@file$)
			slash = RINSTR (file$, $$PathSlash$)
			IF slash THEN file$ = MID$(file$,slash+1)
			dot = INSTR (file$, ".")
			IF dot THEN file$ = LEFT$(file$,dot-1)
		ELSE
			file$ = "pde"
		END IF
	END IF
	dot = INSTR (file$, ".")
	IFZ dot THEN file$ = file$ + ".hlp"
'
	IF (file$ != helpfile$) THEN
		helpfile$ = file$
		##ERROR = $$FALSE
		file = OPEN (helpfile$, 0)
		IF ##ERROR THEN
			' File not found; try again in help directory.
			##ERROR = $$FALSE
			helpfile$ = ##XBDir$ + $$PathSlash$ + "help" + $$PathSlash$ + helpfile$
			file = OPEN(helpfile$, 0)
		END IF
		IF ##ERROR THEN GOSUB BadFile : RETURN ($$TRUE)
		IF (file <= 0) THEN GOSUB BadFile : RETURN ($$TRUE)
		helpSize = LOF (file)
		helpText$ = NULL$ (helpSize)
		READ [file], helpText$
		CLOSE (file)
		IF ##ERROR THEN GOSUB BadFile : RETURN ($$TRUE)
		IFZ helpText$ THEN GOSUB BadFile : RETURN ($$TRUE)
		DIM helpText$[]
		XstStringToStringArray (@helpText$, @helpText$[])
	END IF
'
' If "filename:*" then the desired entry is the whole file
'
	upper = UBOUND (helpText$[])
	IF (entry$ = ":*") THEN
		start = 0
		header = 0
		count = upper + 1
		XstCopyArray (@helpText$[], @text$[])
		RETURN
	END IF
'
' Look for ":entry" header in helpText$[]
'
	FOR i = 0 TO upper
		IF helpText$[i] THEN
			IF (entry$ = helpText$[i]) THEN header = i : EXIT FOR
			start = i
		END IF
	NEXT i
'
' If header not found, return with start = location to insert a header
'
	IF (header < 0) THEN
		IF (start > (upper - 4)) THEN
			upper = upper + 4
			REDIM helpText$[upper]
		END IF
		start = start + 2
		RETURN ($$FALSE)
	END IF
'
' Found header, now collect entry text
'
	final = header
	start = header + 1
	FOR i = start TO upper
		IF helpText$[i] THEN
			IF (helpText$[i]{0} = ':') THEN EXIT FOR
			final = i
		END IF
	NEXT i
	count = final - start + 1
'
' If no text follows ":entry" header, return start = location to insert entry
'
	IF (count <= 0) THEN
		IF (start > (upper - 4)) THEN
			upper = upper + 4
			REDIM helpText$[upper]
		END IF
		count = 0
		RETURN ($$FALSE)
	END IF
'
' Extract help text from helpText$[] and put it into text$[]
'
	entry = 0
	DIM text$[count-1]
	FOR i = start TO final
		text$[entry] = helpText$[i]
		INC entry
	NEXT i
	RETURN ($$FALSE)
'
'
' *****  BadFile  *****
'
SUB BadFile
	start = 0
	final = 0
	count = 0
	file$ = ""
	IF who THEN helpfile$ = userSetFile$ ELSE helpfile$ = sysSetFile$
END SUB
END FUNCTION
'
'
' #######################################
' #####  GetModalResponseSystem ()  #####
' #######################################
'
FUNCTION  GetModalResponseSystem (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	modalGridSystem,  modalResponseSystem
	SHARED	sv0, sv1, sv2, sv3, sr0, sr1
'
	IF (grid != modalGridSystem) THEN RETURN
	IF ##WHOMASK THEN PRINT "GetModalResponseSystem() : error : (##WHOMASK = $$TRUE)" : RETURN
'
	SELECT CASE message
		CASE #Selection	: GOSUB Selection
		CASE #Callback	: IF (r1 = #Selection) THEN GOSUB Selection
	END SELECT
	RETURN
'
SUB Selection
	sv0 = v0 : sv1 = v1 : sv2 = v2 : sv3 = v3 : sr0 = r0 : sr1 = r1
	modalResponseSystem = $$TRUE
END SUB
END FUNCTION
'
'
' #####################################
' #####  GetModalResponseUser ()  #####
' #####################################
'
FUNCTION  GetModalResponseUser (grid, message, v0, v1, v2, v3, r0, r1)
	SHARED	modalGridUser,  modalResponseUser
	SHARED	uv0, uv1, uv2, uv3, ur0, ur1
'
	IF (grid != modalGridUser) THEN RETURN
	IFZ ##WHOMASK THEN PRINT "GetModalResponseUser() : error : (##WHOMASK = $$FALSE)" : RETURN
'
	SELECT CASE message
		CASE #Selection	: GOSUB Selection
		CASE #Callback	: IF (r1 = #Selection) THEN GOSUB Selection
	END SELECT
	RETURN
'
SUB Selection
	uv0 = v0 : uv1 = v1 : uv2 = v2 : uv3 = v3 : ur0 = r0 : ur1 = r1
	modalResponseUser = $$TRUE
END SUB
END FUNCTION
'
'
' #############################
' #####  GetProtoInfo ()  #####
' #############################
'
FUNCTION  GetProtoInfo (grid, message, v0, v1, v2, v3, kid, GRID r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperGridType
	SHARED	GRID	grid[]
	SHARED	GRID	gridType[]
'
	IF (kid > 0) THEN
		XuiSendMessage (grid, message, @v0, @v1, @v2, @v3, kid, @r1)
		RETURN
	END IF
'
	IF (grid <= 0) THEN PRINT "GetProtoInfo() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "GetProtoInfo() : error : (grid > upperGrid)" : RETURN
	IF (message != #GetProtoInfo) THEN PRINT "GetProtoInfo() : error : (message != #GetProtoInfo)" : RETURN
'
	gridType = grid[grid].gridType
	IF (gridType < 0) THEN PRINT "GetProtoInfo() : error : (gridType < 0)" : RETURN
	IF (gridType > upperGridType) THEN PRINT "GetProtoInfo() : error : (gridType > upperGridType)" : RETURN
	r1 = gridType[gridType]
END FUNCTION
'
'
' ###########################
' #####  NewMessage ()  #####
' ###########################
'
FUNCTION  NewMessage (message)
	SHARED	upperMessage
	SHARED	UBYTE messageType[]
'
	IF (message > upperMessage) THEN
		upper = (message + 64) OR 63
		IF (upperMessage > 65535) THEN PRINT "NewMessage() : error : (outrageous message number = "; message; ")" : RETURN
		upperMessage = upper
		REDIM messageType[upper]
	END IF
'
	messageType = messageType[message]
	IFZ messageType THEN
		XgrGetMessageType (message, @messageType)
		messageType[message] = messageType
	END IF
END FUNCTION
'
'
' ##########################  Bubble sort grids into an order where completely
' #####  OrderKids ()  #####  enclosed kids are later in the kids[grid,] array.
' ##########################  This prevents kids from being drawn then covered.
'
FUNCTION  OrderKids (grid)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
'
	IF (grid <= 0) THEN PRINT "OrderKids() : error : (grid <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "OrderKids() : error : (grid > upperGrid)" : RETURN
'
	window = grid[grid].window
	upperWindow = UBOUND (windowInfo[])
	IF (window <= 0) THEN PRINT "OrderKids() : error : (window <= 0)" : RETURN
	IF (window > upperWindow) THEN PRINT "OrderKids() : error : (window > upperWindow)" : RETURN
'
	base = windowInfo[window].graph
	IFZ kids[base, ] THEN PRINT "OrderKids() : error : (kids[base, ] is empty)" : RETURN
'
	upper = UBOUND (kids[base, ])							' upper bound of kids[base,]
	FOR i = 1 TO upper-1
		IFZ kids[base,i] THEN
			FOR j = i TO upper-1
				kids[base,j] = kids[base,j+1]				' remove kids = 0
			NEXT j
		END IF
	NEXT i
'
	FOR i = 1 TO upper
		IFZ kids[base,i] THEN top = i-1 : EXIT FOR
	NEXT i
'
	DO
		flip = $$FALSE
		FOR i = 1 TO top-1
			gridX = kids[base,i]
			gridY = kids[base,i+1]
			IFZ gridX THEN PRINT "OrderKids() : error : (gridX = 0) : RETURN"
			IFZ gridY THEN PRINT "OrderKids() : error : (gridY = 0) : RETURN"
			XgrGetGridBoxWindow (gridX, @x1, @y1, @x2, @y2)
			XgrGetGridBoxWindow (gridY, @xx1, @yy1, @xx2, @yy2)
			IF (y1 < yy1) THEN DO NEXT								' 1st top is higher, order OK
			IF (y1 > yy1) THEN GOSUB Flip : DO NEXT		' 2nd top is higher, flip order
			IF (x1 < xx1) THEN DO NEXT								' 1st left is leftward, order OK
			IF (x1 > xx1) THEN GOSUB Flip : DO NEXT		' 2nd left is leftward, flip order
			IF (y2 > yy2) THEN DO NEXT								' 1st bottom is lower, order OK
			IF (y2 < yy2) THEN GOSUB Flip : DO NEXT		' 2nd bottom is lower, flip order
			IF (x2 > xx2) THEN DO NEXT								' 1st right is rightward, order OK
			IF (x2 < xx2) THEN GOSUB Flip : DO NEXT		' 2nd right is rightward, flip order
		NEXT i
	LOOP WHILE flip
'
'	GOSUB EncloseSort
'
'	FOR i = 0 TO upper
'		PRINT kids[base,i];
'	NEXT i
'	PRINT
	RETURN
'
'
' *****  Flip  *****
'
SUB Flip
	flip = $$TRUE
	kids[base,i]		= gridY
	kids[base,i+1]	= gridX
END SUB
'
'
' *****  EncloseSort  *****  Enclosed grids don't necessarily come after enclosing grid
'
SUB EncloseSort
'	DIM temp[top]
END SUB
END FUNCTION
'
'
' ##########################
' #####  ParseLine ()  #####
' ##########################
'
FUNCTION  ParseLine (line$, arg$[])
'
	DIM arg$[31]
'
	IFZ line$ THEN DIM arg$[] : RETURN
	arg = 0
	done = 0
	index = 0
'
	DO
		a$ = XstNextField$ (line$, @index, @done)
		IF a$ THEN arg$[arg] = TRIM$(a$)
		IF done THEN REDIM arg$[arg] : EXIT DO
		INC arg
	LOOP UNTIL (arg > 31)
END FUNCTION
'
'
' ##########################
' #####  PathSlash ()  #####
' ##########################
'
FUNCTION  PathSlash (path$)
'
	IFZ path$ THEN RETURN										' no path$
'
	back = 0																' # of \
	upper = UBOUND (path$)
	FOR i = 0 TO upper
		IF (path${i} = '\\') THEN INC back		' found \
	NEXT i
	IFZ back THEN RETURN										' no \
'
	slot = 0																' destination offset
	new$ = NULL$ (upper+back+1)							' new string is longer
	FOR i = 0 TO upper
		new${slot} = path${i}									' transfer byte
		INC slot															' next destination byte
		IF (path${i} = '\\') THEN							' byte was \
			IF (path${i+1} = '\\') THEN DO NEXT	' source already has \\
			new${slot} = '\\'										' add extra \ to destination
			INC slot
		END IF
	NEXT i
'
	SWAP new$, path$
END FUNCTION
'
'
' ###############################
' #####  RenameFunction ()  #####
' ###############################
'
FUNCTION  RenameFunction (func$, old$, new$)
'
	i = 1
	old = LEN(old$)
	new = LEN(new$)
	DO
		i = INSTR(func$, old$, i)
		IFZ i THEN EXIT DO
		func$ = LEFT$(func$, i-1) + new$ + MID$(func$, i+old)
		i = i + new
	LOOP
	add$ = CHR$('#', new-old)
	i = INSTR(func$, "' ######")
	IFZ i THEN RETURN
	func$ = LEFT$(func$, i+3) + add$ + MID$(func$, i+4)
	i = i + new - old
	i = INSTR(func$, "' ######", i)
	IFZ i THEN RETURN
	func$ = LEFT$(func$, i+3) + add$ + MID$(func$, i+4)
END FUNCTION
'
'
' ###############################
' #####  ReportUserWhomask  #####
' ###############################
'
FUNCTION  ReportUserWhomask (element, name$, address, element$)
	ULONG  addr
	ULONG  ##DYNO0, ##DYNO, ##DYNOX, ##DYNOZ
'
	addr = address
	IFZ address THEN RETURN
	IFZ element$ THEN PRINT "ReportUserWhomask() : error : (element$ is empty)" : RETURN
	IF (element < 0) THEN PRINT "ReportUserWhomask() : error : (element < 0)", element : RETURN
	IF (addr < ##DYNO0) THEN PRINT "ReportUserWhomask() : error : (addr < ##DYNO0)", HEX$(addr,8) : RETURN
	IF (addr > ##DYNOZ) THEN PRINT "ReportUserWhomask() : error : (addr > ##DYNOZ)", HEX$(addr,8) : RETURN
'
	header = addr - 16
	word0 = XLONGAT (header, [0])
	word1 = XLONGAT (header, [1])
	word2 = XLONGAT (header, [2])
	word3 = XLONGAT (header, [3])
	data0 = XLONGAT (addr, [0])
	data1 = XLONGAT (addr, [1])
	data2 = XLONGAT (addr, [2])
	data3 = XLONGAT (addr, [3])
'
	user = word3 AND 0x01000000
	IF user THEN
		PRINT "ReportUserWhomask() : error : (system string/array has user whomask element : grid ="; element; " aka "; name$; ")"
		PRINT "                    : element$ = "; element$
		PRINT
		PRINT HEX$(header +  0, 8); "	:  "; HEX$(word0, 8)
		PRINT HEX$(header +  4, 8); "	:  "; HEX$(word1, 8)
		PRINT HEX$(header +  8, 8); "	:  "; HEX$(word2, 8)
		PRINT HEX$(header + 12, 8); "	:  "; HEX$(word3, 8)
		PRINT HEX$(addr +  0, 8); "		:  "; HEX$(data0, 8)
		PRINT HEX$(addr +  4, 8); "		:  "; HEX$(data1, 8)
		PRINT HEX$(addr +  8, 8); "		:  "; HEX$(data2, 8)
		PRINT HEX$(addr + 12, 8); "		:  "; HEX$(data3, 8)
'
		check	= word3 AND 0x40FFFFFF
		SELECT CASE check
			CASE 0xC0130004	: PRINT "*****  string array  *****"
'												XLONGAT (&&test$[]) = addr
'												FOR i = 0 TO UBOUND (test$[])
'													PRINT ":"; test$[i]; ":"
'												NEXT i
			CASE 0x40130004	: PRINT "*****  string array  *****"
'												XLONGAT (&&test$[]) = addr
'												FOR i = 0 TO UBOUND (test$[])
'													PRINT ":"; test$[i]; ":"
'												NEXT i
			CASE 0x80130001	: test$ = CSTRING$(addr)
												PRINT "*****  string = <"; test$; ">"
			CASE 0x00130001	: test$ = CSTRING$(addr)
												PRINT "*****  string = <"; test$; ">"
		END SELECT
	END IF
END FUNCTION
'
'
' ###########################
' #####  SelectGrid ()  #####
' ###########################
'
FUNCTION  SelectGrid (grid)
	SHARED	gripGrid
	SHARED	selectGrid
	SHARED	lastSelectGrid
	SHARED	keyboardFocusGrid
	SHARED	GRID	grid[]
	SHARED	WINDOW	windowInfo[]
	SHARED	selectX1,  selectY1,  selectX2,  selectY2
'
	IF selectGrid THEN PRINT "SelectGrid() : error : (selectGrid != 0)" : RETURN
	XgrGetGridWindow (grid, @win)
	base = windowInfo[win].graph
'
	IF keyboardFocusGrid THEN
		IF XuiGridKid (grid, keyboardFocusGrid) THEN
			XuiSendMessage (base, #SetKeyboardFocus, 0, 0, 0, 0, 0, 0)
		END IF
	END IF
'
	selectGrid = grid																			' selectGrid = grid
	lastSelectGrid = grid																	' new lastSelectGrid
	XgrGetGridBoxWindow (grid, @x1, @y1, @x2, @y2)				' selectGrid coords
	XuiSendMessage (grid, #Disable, 0, 0, 0, 0, 0, 0)			' disable selectGrid
	selectX1 = x1
	selectY1 = y1
	selectX2 = x2
	selectY2 = y2
'
' Process consequences of exposure of base grids, etc...
'
	DO
		XgrMessagesPending (@count)
		IFZ count THEN EXIT DO
		XgrProcessMessages (0)
	LOOP
'
	w = x2 - x1 + 1																				' width of selectGrid
	h = y2 - y1 + 1																				' height of selectGrid
	ww = (w + 2) AND -4																		' width of gripGrid
	hh = (h + 2) AND -4																		' height of gridGrid
	IF (w < ww) THEN w = ww																' redraw larger of two grids
	IF (h < hh) THEN h = hh																' redraw larger of two grids
'
	XgrRedrawWindow (win, $$TRUE, x1, y1, w, h)							' draw uncovered grids
	XuiGrip (@gripGrid, #Create, x1, y1, ww, hh, win, base)	' create a grip grid
	XuiGrip ( gripGrid, #RedrawGrid, 0, 0, 0, 0, 0, 0)			' draw grip grid
END FUNCTION
'
'
' ##########################
' #####  SendToAll ()  #####
' ##########################
'
FUNCTION  SendToAll (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
'
	IF (grid < 0) THEN PRINT "SendToAll() : error : (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "SendToAll() : error : (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "SendToAll() : error : (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "SendToAll() : error ::: (message > upperMessage)"
'
	IF (kid > 0) THEN
		IFZ kids[grid, ] THEN RETURN	' asked for kid but grid has no kids
		upper = UBOUND (kids[grid, ])
		IF (kid > upper) THEN RETURN	' asked for too high kid number
		grid = kids[grid,kid]
		IFZ grid THEN RETURN					' asked for kid that does not exist
	END IF
'
	IF kids[grid, ] THEN
		upper = UBOUND (kids[grid, ])
		IF (kids[grid, 0] != grid) THEN PRINT "SendToAll() : error : (kids[grid,0] != grid)" : RETURN
		FOR i = 0 TO upper
			g = kids[grid, i]
			IF g THEN XuiSendMessage (g, message, v0, v1, v2, v3, 0, @r1)
		NEXT i
	END IF
END FUNCTION
'
'
' ###########################
' #####  SetMessage ()  #####
' ###########################
'
FUNCTION  SetMessage (grid, message, v0, v1, v2, v3, kid, r1)
	SHARED	kids[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	FUNCADDR	func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
'
	IF (grid < 0) THEN PRINT "SetMessage() : Error0: (grid < 0)" : RETURN
	IF (message <= 0) THEN PRINT "SetMessage() : Error1: (message <= 0)" : RETURN
	IF (grid > upperGrid) THEN PRINT "SetMessage() : Error2: (grid > upperGrid)" : RETURN
	IF (message > upperMessage) THEN PRINT "SetMessage() : Error3::: (message > upperMessage)" : RETURN
'
	IF (kid > 0) THEN
		IFZ kids[grid, ] THEN RETURN		' asked for kid but grid has no kids
		upper = UBOUND (kids[grid, ])
		IF (kid > upper) THEN RETURN		' asked for too high kid number
		grid = kids[grid,kid]
		IFZ grid THEN RETURN						' asked for kid that does not exist
	END IF
'
	func = grid[grid].gridFunc
	IFZ func THEN XgrGetGridFunction (grid, @func)
	@func (grid, message, v0, v1, v2, v3, 0, @r1)
END FUNCTION
'
'
' #############################
' #####  SortByExtent ()  #####
' #############################
'
FUNCTION  SortByExtent (file$[], order)
'
	IFZ file$[] THEN RETURN											' empty string array
	upper = UBOUND(file$[])											' upper bound of array
	top = -1																		' top non-empty string
	FOR i = upper TO 0 STEP -1									' check from top down
		IF file$[i] THEN top = i : EXIT FOR				' exit on non-empty string
	NEXT i																			' check next string
	IF (top < 0) THEN RETURN										' nothing but empty strings
'
	max = 0
	FOR i = 0 TO top
		file$ = file$[i]
		file$ = TRIM$(file$)
		dot = RINSTR (file$, ".")
		length = LEN(file$)
		IFZ dot THEN
			file$ = "\0" + file$
			IF (max <= length) THEN max = length+1
		ELSE
			file$ = MID$(file$,dot) + "\0" + LEFT$(file$,dot-1)
			IF (max < dot) THEN max = dot
		END IF
		file$[i] = file$
	NEXT i
'
	XstQuickSort (@file$[], @a[], 0, top, order)
'
	FOR i = 0 TO top
		file$ = file$[i]
		z = INSTR(file$,"\0")
		r$ = LEFT$(file$,z-1)
		l$ = MID$(file$,z+1)
		IF r$ THEN
			file$[i] = l$ + r$
		ELSE
			file$[i] = l$
		END IF
	NEXT i
	RETURN (max)
'
END FUNCTION
'
'
' ###########################
' #####  SortByName ()  #####
' ###########################
'
FUNCTION  SortByName (file$[], order)
'
	IFZ file$[] THEN RETURN											' empty string array
	upper = UBOUND(file$[])											' upper bound of array
	top = -1																		' top non-empty string
	FOR i = upper TO 0 STEP -1									' check from top down
		IF file$[i] THEN top = i : EXIT FOR				' exit on non-empty string
	NEXT i																			' check next string
	IF (top < 0) THEN RETURN										' nothing but empty strings
	XstQuickSort (@file$[], @a[], 0, top, order)
END FUNCTION
'
'
' ########################
' #####  SortNot ()  #####
' ########################
'
FUNCTION  SortNot (file$[], order)
'
	IFZ file$[] THEN RETURN											' empty string array
	upper = UBOUND(file$[])											' upper bound of array
	top = -1																		' top non-empty string
	FOR i = upper TO 0 STEP -1									' check from top down
		IF file$[i] THEN top = i : EXIT FOR				' exit on non-empty string
	NEXT i																			' check next string
	IF (top < 0) THEN RETURN										' nothing but empty strings
END FUNCTION
'
'
' ###############################
' #####  SplitFilenames ()  #####
' ###############################
'
FUNCTION  SplitFilenames (file$[], split)
'
	IFZ file$[] THEN RETURN											' empty string array
	upper = UBOUND(file$[])											' upper bound of array
	top = -1																		' top non-empty string
	FOR i = upper TO 0 STEP -1									' check from top down
		IF file$[i] THEN top = i : EXIT FOR				' exit on non-empty string
	NEXT i																			' check next string
	IF (top < 0) THEN RETURN										' nothing but empty strings
	IF (split < 2) THEN split = 9
	IF (split > 256) THEN split = 9
'
' the following generates "NAME      .EXT" format (vs "NAME.EXT")
'
	FOR i = 0 TO top
		file$ = ""
		ATTACH file$[i] TO file$
		dot = RINSTR (file$, ".")
		IFZ dot THEN
			file$[i] = LJUST$(file$,split)
		ELSE
			file$[i] = LJUST$(LEFT$(file$,dot-1),split) + TRIM$(MID$(file$,dot))
		END IF
	NEXT i
END FUNCTION
'
'
' ############################
' #####  StripSymbol ()  #####
' ############################
'
FUNCTION  StripSymbol (symbol$)
	StripSymbolLeft (@symbol$)
	StripSymbolRight (@symbol$)
END FUNCTION
'
'
' #################################
' #####  StripSymbolRight ()  #####
' #################################
'
FUNCTION  StripSymbolRight (symbol$)
	SHARED	UBYTE  charsetSymbol[]
'
	axe = 0
	IFZ symbol$ THEN RETURN
	upper = UBOUND (symbol$)
	FOR i = upper TO 0 STEP -1
		IF charsetSymbol[symbol${i}] THEN EXIT FOR
		INC axe
	NEXT i
	IF axe THEN symbol$ = RCLIP$(symbol$,axe)
END FUNCTION
'
'
' ################################
' #####  StripSymbolLeft ()  #####
' ################################
'
FUNCTION  StripSymbolLeft (symbol$)
	SHARED	UBYTE  charsetSymbol[]
'
	axe = 0
	IFZ symbol$ THEN RETURN
	upper = UBOUND (symbol$)
	FOR i = 0 TO upper
		IF charsetSymbol[symbol${i}] THEN EXIT FOR
		INC axe
	NEXT i
	IF axe THEN symbol$ = LCLIP$(symbol$,axe)
END FUNCTION
'
'
' #####################################
' #####  TrimStringArrayUpper ()  #####
' #####################################
'
FUNCTION  TrimStringArrayUpper (text$[])
'
	IFZ text$[] THEN RETURN
	upper = UBOUND (text$[])
	FOR i = upper TO 0 STEP -1
		IF text$[i] THEN EXIT FOR
	NEXT i
	IF (i < 0) THEN DIM text$[] : RETURN
	REDIM text$[i]
END FUNCTION
'
'
' ################################
' #####  UnsplitFilename ()  #####
' ################################
'
FUNCTION  UnsplitFilename (@filename$)
'
	IFZ filename$ THEN RETURN
	temp$ = TRIM$ (filename$)
	dot = INSTR (temp$, ".")
'
	IFZ dot THEN filename$ = TRIM$(filename$) : RETURN
	left$ = TRIM$(LEFT$(temp$,dot-1))
	right$ = TRIM$(MID$(temp$,dot+1))
	filename$ = left$ + "." + right$
END FUNCTION
'
'
' #################################
' #####  UnsplitFilenames ()  #####
' #################################
'
FUNCTION  UnsplitFilenames (file$[])
'
	IFZ file$[] THEN RETURN											' empty string array
	upper = UBOUND(file$[])											' upper bound of array
	top = -1																		' top non-empty string
	FOR i = upper TO 0 STEP -1									' check from top down
		IF file$[i] THEN top = i : EXIT FOR				' exit on non-empty string
	NEXT i																			' check next string
	IF (top < 0) THEN RETURN										' nothing but empty strings
'
' the following generates "NAME.EXT" format (from "NAME      .EXT")
'
	FOR i = 0 TO top
		file$ = ""
		ATTACH file$[i] TO file$
		dot = RINSTR (file$, ".")
		IFZ dot THEN
			file$[i] = TRIM$(file$)
		ELSE
			l$ = TRIM$(LEFT$(file$,dot-1))
			r$ = TRIM$(MID$(file$,dot+1))
			IF r$ THEN
				file$[i] = l$ + "." + r$
			ELSE
				file$[i] = l$
			END IF
		END IF
	NEXT i
END FUNCTION
'
'
' ###################################
' #####  UpdateCodeFunction ()  #####
' ###################################
'
FUNCTION  UpdateCodeFunction (f$[], c$[])
	SHARED  UBYTE  charsetSymbol[]
'
	IFZ f$[] THEN RETURN
	IFZ c$[] THEN RETURN
	upper = UBOUND (f$[])
	FOR i = upper TO 0 STEP -1
		f$ = TRIM$(f$[i])
		IF (LEFT$(f$,12) = "END FUNCTION") THEN EXIT FOR
	NEXT i
	insert = i
'
	IF (i <= 0) THEN DIM f$[] : RETURN
	IF (i < upper) THEN
		REDIM f$[i]
		upper = i
	END IF
'
	upper = UBOUND (c$[])
	DIM cc$[upper+8]
	cc$[0] = "'"
	cc$[1] = "'"
	cc$[2] = "' *****  Selection  *****"
	cc$[3] = "'"
	cc$[4] = "SUB Selection"
	cc$[5] = "	SELECT CASE kid"
'
	length = 0
	FOR i = 1 TO upper-1
		l = LEN (c$[i])
		IF (l > length) THEN length = l
	NEXT i
'
	length = length + 2
	FOR i = 1 TO upper
		c$ = c$[i]
		l = LEN (c$)
		cc$[i+5] = c$
	NEXT i
	cc$[i+5] = "END SUB"
	REDIM cc$[i+5]
	XstReplaceLines (@f$[], @cc$[], insert, 0, 0, i+6)
END FUNCTION
'
'
' ####################################
' #####  UpdateCreateWindows ()  #####
' ####################################
'
FUNCTION  UpdateCreateWindows (winFunc$, codeFunc$)
'
	XitQueryFunction (@"CreateWindows", @exists)
	IFZ exists THEN PRINT "UpdateCreateWindows() : error : (Function CreateWindows() does not exist)" : RETURN ($$TRUE)
	XitGetFunction (@"CreateWindows", @cw$[])
	length = LEN (winFunc$)
	pad$ = ""
'
	IF cw$[] THEN
		done = $$FALSE
		upper = UBOUND (cw$[])
		FOR i = 2 TO upper
			i$ = cw$[i]
			IF INSTR(i$, winFunc$) THEN
				IF INSTR(i$, "#CreateWindow") THEN
					done = $$TRUE
					EXIT FOR
				END IF
			END IF
			IF INSTR (i$,"END FUNCTION") THEN EXIT FOR
		NEXT i
'
		IF (length < 14) THEN pad$ = CHR$(' ', 14-length)	' spaces
		IF (i > upper) THEN RETURN ($$TRUE)								' no "END FUNCTION"
		IF done THEN RETURN																' already exists
'
		DIM add$[6]
		add$[0] =  "'"
		add$[1] =  "	" + winFunc$ + pad$ + " (@" + winFunc$ + ", #CreateWindow, 0, 0, 0, 0, 0, 0)"
		add$[2] =  "	XuiSendMessage ( " + winFunc$ + ", #SetCallback, " + winFunc$ + ", &" + codeFunc$ + "(), -1, -1, -1, 0)"
		add$[3] =  "	XuiSendMessage ( " + winFunc$ + ", #Initialize, 0, 0, 0, 0, 0, 0)"
		add$[4] =  "	XuiSendMessage ( " + winFunc$ + ", #DisplayWindow, 0, 0, 0, 0, 0, 0)"
		add$[5] =  "	XuiSendMessage ( " + winFunc$ + ", #SetGridProperties, -1, 0, 0, 0, 0, 0)"
		add$[6] =  "'	#" + winFunc$ + " = " + winFunc$
		XstReplaceLines (@cw$[], @add$[], i, 0, 0, 7)
		XitSetFunction (@"CreateWindows", @cw$[])
	END IF
END FUNCTION
'
'
' ###################################
' #####  UpdateKidConstants ()  #####
' ###################################
'
FUNCTION  UpdateKidConstants (func$[], const$[])
'
	DIM z$[]
	start = 0
	upper = UBOUND(func$[])
	const = UBOUND(const$[])
'
	FOR i = 2 TO upper
		func$ = TRIM$(func$[i])
		IF func$ THEN
			IF (INSTR(func$,"FUNCTION") = 1) THEN gotFunc = i
			IF (func${0} = '$') THEN
				IF (INSTR(func$, "' kid ")) THEN
					XstDeleteLines (@func$[], i, 1)
					IFZ start THEN start = i
					DO FOR
				END IF
			END IF
			IFZ start THEN
				IF gotFunc THEN
					IF (func${0} = ''') THEN
						comment = i
						start = i+1
						DO NEXT
					END IF
				END IF
			END IF
		END IF
		IF (INSTR(func$, "IF ")) THEN
			IFZ start THEN start = i
			EXIT FOR
		END IF
	NEXT i
'
	IF start THEN
		IF comment THEN DEC const
		XstReplaceLines (@func$[], @const$[], start, 0, 0, const+1)
	END IF
END FUNCTION
'
'
' ##################################
' #####  ValidSimpleSymbol ()  #####
' ##################################
'
FUNCTION  ValidSimpleSymbol (symbol$)
	SHARED	UBYTE  charsetSymbol[]
'
	IFZ symbol$ THEN RETURN
	symbol$ = TRIM$(symbol$)
	FOR i = 0 TO UBOUND(symbol$)
		IFZ charsetSymbol[symbol${i}] THEN EXIT FOR
	NEXT i
	IFZ i THEN symbol$ = "" : RETURN
	IF ((symbol${0} >= '0') AND (symbol${0} <= '9')) THEN symbol$ = "" : RETURN
	symbol$ = LEFT$(symbol$, i)
END FUNCTION
'
'
' #############################
' #####  FindGridName ()  #####
' #############################
'
FUNCTION  FindGridName (grid, name$)
'
	XuiSendMessage (grid, #GetGridName, 0, 0, 0, 0, 0, @test$)
	IF (test$ = name$) THEN RETURN (grid)
'
	XuiSendMessage (grid, #GetKidArray, 0, 0, 0, 0, 0, @k[])
	IFZ k[] THEN RETURN ($$FALSE)
	upper = UBOUND (k[])
	FOR i = 1 TO upper
		kid = k[i]
		IF kid THEN
			found = FindGridName (kid, @name$)
			IF found THEN RETURN (found)
		END IF
	NEXT i
	RETURN ($$FALSE)
END FUNCTION
'
'
' ##############################  Separate an XuiFunctionName (grid, message...)
' #####  ParseFuncLine ()  #####  call into the function name and 8 arguments.
' ##############################  If format is not correct, return ele$[] empty.
'
FUNCTION  ParseFuncLine (line$, ele$[])
'
	DIM ele$[]
	IFZ line$ THEN RETURN
'
	start = 1
	lefty = INSTR(line$, "(", start)
	IFZ lefty THEN RETURN
	func$ = TRIM$(MID$(line$, start, lefty-start))
	IFZ func$ THEN RETURN
'
	start = lefty + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	grid$ = TRIM$(MID$(line$, start, comma-start))
	IFZ grid$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	message$ = TRIM$(MID$(line$, start, comma-start))
	IFZ message$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	v0$ = TRIM$(MID$(line$, start, comma-start))
	IFZ v0$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	v1$ = TRIM$(MID$(line$, start, comma-start))
	IFZ v1$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	v2$ = TRIM$(MID$(line$, start, comma-start))
	IFZ v2$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	v3$ = TRIM$(MID$(line$, start, comma-start))
	IFZ v3$ THEN RETURN
'
	start = comma + 1
	comma = INSTR(line$, ",", start)
	IFZ comma THEN RETURN
	r0$ = TRIM$(MID$(line$, start, comma-start))
	IFZ r0$ THEN RETURN
'
	IF (func$ != "XuiCreateGrid") THEN
		start = comma + 1
		r1$ = TRIM$(MID$(line$, start))
		IFZ r1$ THEN RETURN
		righty = RINSTR(r1$, ")")
		IFZ righty THEN RETURN
		r1$ = TRIM$(LEFT$(r1$, righty-1))
		IFZ r1$ THEN RETURN
		x$ = ""
	ELSE
		start = comma + 1
		comma = INSTR(line$, ",", start)
		IFZ comma THEN RETURN
		r1$ = TRIM$(MID$(line$, start, comma-start))
		IFZ r1$ THEN RETURN
'
		start = comma + 1
		x$ = TRIM$(MID$(line$, start))
		IFZ x$ THEN RETURN
		righty = RINSTR(x$, ")")
		IFZ righty THEN RETURN
		x$ = TRIM$(LEFT$(x$,righty-1))
	END IF
'
	DIM ele$[9]
	ele$[0] = func$
	ele$[1] = grid$
	ele$[2] = message$
	ele$[3] = v0$
	ele$[4] = v1$
	ele$[5] = v2$
	ele$[6] = v3$
	ele$[7] = r0$
	ele$[8] = r1$
	ele$[9] = x$
	RETURN ($$TRUE)
END FUNCTION
'
'
' ################################
' #####  PullDownMessage ()  #####
' ################################
'
'	separators not implemented
'	non-proportional or proportional fonts
'	called exclusively by XuiPullDown()
'
FUNCTION  PullDownMessage (grid, message, v0, v1, v2, v3, r0, (r1, r1$[]))
'
	$StyleHotKey = 1
'
	IF (message <= 0) THEN RETURN
'
'	messages manipulate text
'
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	IFZ text$[] THEN RETURN
	XuiGetKids (grid, #GetKids, @g, @textGrid, 0, 0, 0, 0)
	IF (g != grid) THEN PRINT "PullDownMessage() : error : g != grid" : RETURN
'
	uText = UBOUND (text$[])
	XuiGetValue (grid, #GetValue, 0, @cursorLine, 0, 0, 0, 0)
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiSetFontNumber (textGrid, #SetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	XgrGetGridBoxLocal (textGrid, 0, 0, @xLR, @yLR)			' width/height
	width = xLR + 1
	height = yLR + 1
	rows = height \ maxCharHeight							' number of COMPLETE rows
	IFZ rows THEN
		XgrClearGrid (textGrid, -1)
		XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
		RETURN
	END IF
	lastRow = rows - 1
	lastLine = MIN (uText, lastRow)
'
	action = r1
	clear = $$TRUE
	oldCursorLine = cursorLine
	SELECT CASE message
		CASE #CursorV
					SELECT CASE action
						CASE #Change	: GOSUB CursorSet
						CASE #OneLess	: GOSUB CursorOneUp
						CASE #OneMore	: GOSUB CursorOneDown
					END SELECT
					IF (cursorLine != oldCursorLine) THEN GOSUB MoveCursorLine
		CASE #Redraw					: GOSUB Redraw
		CASE #RedrawGrid			: GOSUB Redraw
		CASE #SetTextCursor		:	cl = v1
														upper = UBOUND (text$[])
														IF (cl < 0) THEN cl = -1
														IF (cl > upper) THEN cl = -1
														XuiSetValue (grid, #SetValue, 0, cl, 0, 0, 0, 0)
														IF (cursorLine != cl) THEN
															cursorLine = cl
															GOSUB Redraw
														END IF
		CASE ELSE							: XgrMessageNumberToName (message, @message$)
														IF $$ShowUntrappedMessages THEN PRINT "PullDownMessage "; message$
	END SELECT
'
	XuiSetValues (grid, #SetValues, 0, cursorLine, 0, 0, 0, 0)
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
	RETURN
'
'
' *****  CursorOneUp  *****  Up one line
'
SUB CursorOneUp
	DEC cursorLine
	IF (cursorLine < 0) THEN cursorLine = lastLine
END SUB
'
'
' *****  CursorOneDown  *****  Down one line
'
SUB CursorOneDown
	INC cursorLine
	IF (cursorLine > lastLine) THEN cursorLine = 0
END SUB
'
'
' *****  CursorSet  *****  v0 = x : v1 = y
'
SUB CursorSet
	IFZ rows THEN EXIT SUB
'
'	SELECT CASE TRUE
'		CASE (v1 < 0)		: cursorLine = 0
'		CASE (v1 > yLR)	: cursorLine = lastLine
'		CASE ELSE				: cursorLine = v1 \ (maxCharHeight + 2)
'	END SELECT
	SELECT CASE TRUE
		CASE (v0 < 0)		: cursorLine = -1
		CASE (v0 > xLR)	: cursorLine = -1
		CASE (v1 < 0)		: cursorLine = -1
		CASE (v1 > yLR)	: cursorLine = -1
		CASE ELSE				: cursorLine = v1 \ (maxCharHeight + 2)
	END SELECT
	IF (cursorLine > lastLine) THEN cursorLine = lastLine
END SUB
'
'
' *****  MoveCursorLine  *****  Separators not done yet
'
SUB MoveCursorLine
	clear = $$FALSE
	GOSUB Redraw
END SUB
'
'
' *****  Redraw  *****  tabs and separators not done yet
'
SUB Redraw
	IF clear THEN XgrClearGrid (textGrid, -1)
	XuiGetColor (textGrid, #GetColor, @back, @draw, 0, 0, 0, 0)
	XuiGetColorExtra (textGrid, #GetColorExtra, @dull, @accent, 0, 0, 0, 0)
	XuiGetFontNumber (textGrid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	XuiGetTabArray (grid, #GetTabArray, 0, 0, 0, 0, 0, @tabs[])
	XuiGetStyle (grid, #GetStyle, @style, 0, 0, 0, 0, 0)
'
	IF (lastLine < rows - 1) THEN emptyRows = rows - lastLine - 1
	yLine = 0
'
	FOR line = 0 TO lastLine
		bc = back : dc = draw
		IF (line = cursorLine) THEN dc = accent
		text$ = text$[line]
		IF text$ THEN
			XgrMoveTo (textGrid, 0, yLine)
			length = LEN (text$)
			underChar = $$FALSE
			index = 1
'
			IF (style AND $StyleHotKey) THEN
				DO
					under = INSTR (text$, "_", index)
					IF (under <= 0) THEN EXIT DO
					IF (under = length) THEN EXIT DO
					IF (under = 1) THEN underChar = $$TRUE : EXIT DO
					IF (text${under-2} != '\\') THEN underChar = $$TRUE : EXIT DO
					index = under + 1
				LOOP WHILE (index < length)
				IF underChar THEN
					prior$ = LEFT$ (text$, under - 1)
					after$ = prior$ + MID$ (text$, under + 1, 1)
					XgrGetTextImageSize (font, @prior$, 0, 0, @firstUnder, 0, 0, 0)
					XgrGetTextImageSize (font, @after$, 0, 0, @afterUnder, 0, 0, 0)
					text$ = prior$ + MID$ (text$, under + 1)
				END IF
			END IF
'
			DrawTextSegment (textGrid, @text$, bc, dc, 0, 0, 0, 0, tabWidth, @tabs[])
			IF underChar THEN
				yUnder = yLine + maxCharHeight + 1
				XgrDrawLine (textGrid, dc, firstUnder, yUnder, afterUnder, yUnder)
			END IF
		ELSE
			XgrFillBox (textGrid, bc, 0, yLine, width - 1, yLine + maxCharHeight - 1)
		END IF
'
		yLine = yLine + maxCharHeight + 2
	NEXT line
	IF emptyRows THEN
		XgrGetDrawpoint (textGrid, @x, @y)
		XgrFillBox (textGrid, bc, 0, y + maxCharHeight, width - 1, height - 1)
	END IF
END SUB
END FUNCTION
'
'
' ################################
' #####  TextLineMessage ()  #####
' ################################
'
'	Text string messages -- used exclusively by XuiTextLine
'
'	proportional or fixed pitch fonts
'	draws with XgrDrawTextFill() and "-gap" so textGrid must clip to self
'
FUNCTION  TextLineMessage (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	values[]
	SHARED	upperMessage
	SHARED	upperGrid
	SHARED	GRID	grid[]
	STATIC	SUBADDR		messageMod[]
	STATIC	SUBADDR		messageNoMod[]
	AUTOX  text$,  textSeg$
	FUNCADDR  func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
	UBYTE  null[]
'
'	values indices:
'
	$cursorPos		= 0
	$leftIndent		= 1
	$xCursor			= 2
	$xCursorShown	= 3
	$cursorShown	= 4
	$begSelectPos	= 5
	$endSelectPos	= 6
	$tabWidth			= 7
	$cursorNoShow	= 8
	$lastValue		= 8
'
	IFZ messageMod[] THEN GOSUB Initialize
	IF (message > upperMessage) THEN RETURN
	IFZ message THEN RETURN
'
	XuiGetKids (grid, #GetKids, @g, @textGrid, 0, 0, 0, 0)
	IF (g != grid) THEN PRINT "TextLineMessage() : (grid != kid 0)" : RETURN
	IF (textGrid <= 0) THEN PRINT "TextLineMessage() : (textGrid <= 0)" : RETURN
'
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
'	XuiSetFontNumber (textGrid, #SetFontNumber, font, 0, 0, 0, 0, 0)
	XuiGetFontMetrics (grid, #GetFontMetrics, @maxCharWidth, @maxCharHeight, @ascent, @decent, 0, @gap)
	XgrGetGridBoxLocal (textGrid, 0, 0, @xLR, @yLR)
	width = xLR + 1
	height = yLR + 1
	xib = 2
	yib = 0
'
'	Message not modifying text?
'
	IF messageNoMod[message] THEN
		GOSUB @messageNoMod[message]
		RETURN
	END IF
'
'	Remaining messages manipulate text
'
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	leftIndent		= values[grid,$leftIndent]
	cursorPos			= values[grid,$cursorPos]
	xCursor				= values[grid,$xCursor]
	begSelectPos	= values[grid,$begSelectPos]
	endSelectPos	= values[grid,$endSelectPos]
	cursorLine		= 0
	topLine				= 0
	GOSUB EraseOldCursor
'
	noRedraw			= $$FALSE
	redrawn				= $$FALSE
	textModified	= $$FALSE
	oldleftIndent	= leftIndent
	oldBegPos			= begSelectPos
	oldEndPos			= endSelectPos
'
	SELECT CASE message
		CASE #Redraw			: select = v2
		CASE #RedrawGrid	: select = v2
	END SELECT
'
	GOSUB @messageMod[message]
'
	IFF noRedraw THEN
		IFF redrawn THEN
			SELECT CASE TRUE
				CASE (oldleftIndent != leftIndent)
							select = $$SelectNoChange
							GOSUB Redraw
			END SELECT
		END IF
'
		IFF redrawn THEN
			XgrGetTextSelectionGrid (@textSelectionGrid)
			IF (grid = textSelectionGrid) THEN
				IF ((begSelectPos != oldBegPos) OR (endSelectPos != oldEndPos)) THEN
					select = $$SelectNoChange
					GOSUB Redraw
				END IF
			END IF
		END IF
	END IF
'
	GOSUB DrawCursor
	values[grid,$leftIndent]		= leftIndent
	values[grid,$cursorPos]			= cursorPos
	values[grid,$xCursor]				= xCursor
	values[grid,$begSelectPos]	= begSelectPos
	values[grid,$endSelectPos]	= endSelectPos
	IF textModified THEN XuiPokeTextString (grid, #PokeTextString, 0, 0, 0, 0, 0, @text$)
	RETURN
'
'
' *****  GetSmallestSize  *****
'
SUB GetSmallestSize
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @"QW")
	XuiGetSmallestSize (grid, #GetSmallestSize, @v0, @v1, @v2, @v3, 0, 12)
	XuiSetTextString (grid, #SetTextString, 0, 0, 0, 0, 0, @text$)
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiSetColor (textGrid, #SetColor, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetColorExtra  *****
'
SUB SetColorExtra
	XuiSetColorExtra (textGrid, #SetColorExtra, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetFont  *****
'
SUB SetFont
	XuiSetFont (grid, #SetFont, v0, v1, v2, v3, 0, r1)
	XuiSetFont (textGrid, #SetFont, v0, v1, v2, v3, 0, r1)
	XuiSendMessage (grid, #GetSize, @xxx, @yyy, @www, @hhh, 0, 0)
	XuiSendMessage (grid, #Resize, xxx, yyy, www, hhh, 0, 0)
END SUB
'
'
' *****  SetFontNumber  *****
'
SUB SetFontNumber
	XuiSetFontNumber (grid, #SetFontNumber, v0, v1, v2, v3, 0, r1)
	XuiSetFontNumber (textGrid, #SetFontNumber, v0, v1, v2, v3, 0, r1)
	XuiSendMessage (grid, #GetSize, @xxx, @yyy, @www, @hhh, 0, 0)
	XuiSendMessage (grid, #Resize, xxx, yyy, www, hhh, 0, 0)
END SUB
'
'
' *****  HideTextCursor  *****
'
SUB HideTextCursor
'	PRINT "TextLineMessage() : HideTextCursor.A : grid ="; grid
	IFZ values[grid,$cursorShown] THEN EXIT SUB
	IFZ grid[grid].redraw THEN EXIT SUB
	IFZ grid[grid].state THEN EXIT SUB
'	PRINT "TextLineMessage() : HideTextCursor.B : grid ="; grid
	GOSUB EraseOldCursor
	values[grid,$cursorShown] = $$FALSE
END SUB
'
'
' *****  ShowTextCursor  *****
'
SUB ShowTextCursor
'	PRINT "TextLineMessage() : ShowTextCursor.A : grid ="; grid
	IF values[grid,$cursorShown] THEN EXIT SUB
	IFZ grid[grid].redraw THEN EXIT SUB
	IFZ grid[grid].state THEN EXIT SUB
	xCursor = values[grid,$xCursor]
'	PRINT "TextLineMessage() : ShowTextCursor.B : grid ="; grid
	values[grid,$cursorShown] = $$TRUE
	GOSUB DrawCursor
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	v0 = values[grid,$cursorPos]
	v1 = 0
	v2 = values[grid,$leftIndent]
	v3 = 0
END SUB
'
'
' *****  GetCursorXY  *****
'
SUB GetCursorXY
	v0 = values[grid,$xCursor]
	v1 = 0
END SUB
'
'
' *****  SetTextCursor  *****  v02 = cursorPos/leftIndent
'
SUB SetTextCursor
	IF (v2 >= 0) THEN leftIndent = v2
	lineWidth = 0
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
	GOSUB CursorXToPos
	IF (v0 < 0) THEN EXIT SUB
	IF (v0 = cursorPos) THEN EXIT SUB
	IF (v0 <= LEN(text$)) THEN cursorPos = v0
	GOSUB CursorPosToX
END SUB
'
'
' *****  SetCursorXY  ***** v0 = xCursor : -1 = don't change
'
SUB SetCursorXY
	IF (v0 < 0) THEN EXIT SUB
	xCursor = v0
	IF (v0 > width - 1) THEN xCursor = width - 1
	lineWidth = 0
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
	GOSUB CursorXToPos
END SUB
'
'
' *****  GetTextArrayBounds  *****  v01 = cursor pos/line : v23 = upper char/line
'
SUB GetTextArrayBounds
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = -1
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	IFZ text$[] THEN EXIT SUB
	v0 = values[grid,$cursorPos]
	v1 = 0																	' only line in TextLine
	v2 = 0
	v3 = UBOUND (text$[])										' empty array = -1
	IF (v3 >= 0) THEN v2 = LEN(text$[v3])
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
END SUB
'
'
' *****  GetTextString  *****
'
SUB GetTextString
	v0 = cursorPos
	v1 = cursorLine
	v2 = leftIndent
	v3 = topLine
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @r1$)
END SUB
'
'
' *****  SetTextString  *****
'
SUB SetTextString
	text$ = r1$
	textModified = $$TRUE
	cursorPos = LEN (text$)
	GOSUB CursorPosToX
	noRedraw = $$TRUE
END SUB
'
'
' *****  GetTextSelection  *****
'
SUB GetTextSelection
	v0 = values[grid,$begSelectPos]
	v1 = 0
	v2 = values[grid,$endSelectPos]
	v3 = 0
	IF (v2 < v0) THEN
		v0 = v2
		v2 = values[grid,$begSelectPos]
	END IF
	r1$ = ""
	IF (v0 = v2) THEN EXIT SUB
	XuiGetTextString (grid, #GetTextString, 0, 0, 0, 0, 0, @text$)
	IF (v0 > LEN(text$)) THEN EXIT SUB
	r1$ = MID$ (text$, v0 + 1, (v2 - v0))
END SUB
'
'
' *****  SetTextSelection  *****
'
SUB SetTextSelection
	begSelectPos = v0
	endSelectPos = v2
	XgrGetTextSelectionGrid (@textSelectionGrid)
	noRedraw = $$TRUE
END SUB
'
'
' *****  CursorH  *****
'
SUB CursorH
	select = v2
	SELECT CASE r1
		CASE #Change		: GOSUB CursorSet
		CASE #OneLess		: GOSUB CursorOneLeft
		CASE #SomeLess	: GOSUB CursorWordLeft
		CASE #Minimum		: GOSUB CursorBegLine
		CASE #OneMore		: GOSUB CursorOneRight
		CASE #SomeMore	: GOSUB CursorWordRight
		CASE #Maximum		: GOSUB CursorEndLine
	END SELECT
	GOSUB UpdateSelect
END SUB
'
'
' *****  CursorOneLeft  *****
'
SUB CursorOneLeft
	IF cursorPos THEN
		DEC cursorPos
		GOSUB CursorPosToX
	END IF
END SUB
'
'
' *****  CursorWordLeft  *****  Beginning of previous (or current) word
'
SUB CursorWordLeft
	IFZ cursorPos THEN EXIT SUB
	DO WHILE cursorPos													' get into a word
		DEC cursorPos
		SELECT CASE text${cursorPos}
			CASE ' ', '\t':		DO DO
		END SELECT
		EXIT DO
	LOOP
	IFZ cursorPos THEN xCursor = 0 : EXIT SUB
'
	ws = RINCHR (text$, " \t", cursorPos + 1)
	cursorPos = ws															' beg = char following white space
	GOSUB CursorPosToX
END SUB
'
'
' *****  CursorOneRight  *****
'
SUB CursorOneRight
	lastChar = LEN(text$) - 1
	IF (cursorPos > lastChar) THEN EXIT SUB
	INC cursorPos
	GOSUB CursorPosToX
END SUB
'
'
' *****  CursorWordRight  *****  Beginning of next word
'
SUB CursorWordRight
	lenText = LEN(text$)
	IF (cursorPos < lenText) THEN								' find next delimiter
		ws = INCHR (text$, " \t", cursorPos + 1)
		IF ws THEN
			cursorPos = ws
		ELSE
			cursorPos = lenText
		END IF
	END IF
'
	DO WHILE (cursorPos < lenText)							' find next non-delimiter
		SELECT CASE text${cursorPos}
			CASE ' ', '\t'
				INC cursorPos
				DO DO
		END SELECT
		EXIT DO
	LOOP
'
	GOSUB CursorPosToX
END SUB
'
'
' *****  CursorBegLine  *****  Beginning of Line
'
SUB CursorBegLine
	leftIndent	= 0
	cursorPos	= 0
	xCursor		= 0
END SUB
'
'
' *****  CursorEndLine  *****  End of Line
'
SUB CursorEndLine
	lineWidth = 0
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
	cursorPos	= LEN(text$)
'
	IFZ lineWidth THEN
		xCursor		= 0
		leftIndent	= 0
		EXIT SUB
	END IF
'
	xCursor = lineWidth - leftIndent
	SELECT CASE TRUE
		CASE (xCursor < 0), (xCursor > width)
			xCursor		= width - 1
			leftIndent	= lineWidth - width + 1
	END SELECT
END SUB
'
'
' *****  CursorSet  *****  v0 = x : v1 = y
'
SUB CursorSet
	xGrid = v0
	yGrid = v1
'
	lineWidth = 0
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF

	SELECT CASE TRUE
		CASE (xGrid < xUL)
					IF leftIndent THEN
						leftIndent = leftIndent - maxCharWidth
						IF (leftIndent < 0) THEN
							leftIndent = 0
						END IF
					END IF
					xGrid = xUL
		CASE (xGrid > xLR)
					IF (leftIndent + width <= lineWidth) THEN
						leftIndent = leftIndent + maxCharWidth
						IF (leftIndent + width > lineWidth) THEN
							leftIndent = lineWidth - width + 1
						END IF
					END IF
					xGrid = xLR
	END SELECT
'
	xCursor = xGrid
	GOSUB CursorXToPos
END SUB
'
'
' *****  CursorXToPos  *****  xCursor/lineWidth
'
SUB CursorXToPos
	xIndent = xCursor + leftIndent
	IF (xIndent >= lineWidth) THEN
		cursorPos = LEN(text$)										' beyond text:  use last char
		xCursor = lineWidth - leftIndent
	ELSE
		cursorPos = xIndent / maxCharWidth				' inside text:  slip between chars
		offset = 0
		IF cursorPos THEN
			pos = cursorPos
			GOSUB TextSegmentWidth
			offset = segWidth
		END IF
'
		IF (xIndent = offset) THEN EXIT SUB				' Hit it exactly
		IF (xIndent < offset) THEN								' cursorPos too large
			FOR i = (cursorPos - 1) TO 0 STEP -1
				pos = i
				GOSUB TextSegmentWidth
				offset = segWidth
				IF (xIndent >= offset) THEN
					cursorPos = i
					EXIT FOR
				END IF
			NEXT i
			IF (leftIndent > offset) THEN
				leftIndent = offset
				xCursor = 0
			ELSE
				xCursor = offset - leftIndent
			END IF
		ELSE																			' right of approxPos
			lastOffset = offset
			FOR i = (cursorPos + 1) TO LEN(text$)
				pos = i
				GOSUB TextSegmentWidth
				offset = segWidth
				IF (xIndent < offset) THEN
					cursorPos = i - 1
					EXIT FOR
				END IF
				lastOffset = offset
			NEXT i
			IF (leftIndent > lastOffset) THEN
				leftIndent = lastOffset
				xCursor = 0
			ELSE
				xCursor = lastOffset - leftIndent
			END IF
		END IF
	END IF
END SUB
'
'
' *****  CursorPosToX  *****  Get cursor X from cursorPos
'		In:		cursorPos
'		Out:	xCursor
'					leftIndent
'
SUB CursorPosToX
	IFZ cursorPos THEN
		xCursor = 0
		leftIndent = 0
		EXIT SUB
	END IF
'
'	Find xCursor from cursorPos
'
	xCursor = 0 - leftIndent
	IF cursorPos THEN
		pos = cursorPos
		GOSUB TextSegmentWidth
		offset = segWidth
		xCursor = offset - leftIndent
	END IF
	SELECT CASE TRUE
		CASE (xCursor < 0)
					leftIndent = leftIndent + xCursor - 4
					IF (leftIndent < 0) THEN leftIndent = 0
					xCursor = 0
		CASE (xCursor > width)
					leftIndent = leftIndent + (xCursor - width) + 4
					xCursor = width - 4
	END SELECT
END SUB
'
'
' *****  TextDelete  *****  If text is selected in this grid, delete it
'														v3 = key
'
SUB TextDelete
	select = $$SelectNoChange													' for Redraw
	GOSUB DeleteSelectedText
	IF textDeleted THEN
		GOSUB Redraw
		EXIT SUB
	END IF
'
	SELECT CASE v3
		CASE $$KeyBackspace
					IFZ cursorPos THEN EXIT SUB
					DEC cursorPos
		CASE $$KeyDelete
					IF (cursorPos >= LEN(text$)) THEN EXIT SUB
		CASE ELSE:		EXIT SUB
	END SELECT
	IF (cursorPos >= LEN(text$)) THEN EXIT SUB
'
'	Delete the character at cursorPos
'
	textModified = $$TRUE
	lenText = LEN(text$)
	SELECT CASE TRUE
		CASE (cursorPos + 1 >= lenText)						' Max changed on 25 June 1993
					text$ = LEFT$(text$, cursorPos)
		CASE (cursorPos <= 0)
					text$ = MID$(text$, cursorPos + 2)
		CASE ELSE
					text$ = LEFT$(text$, cursorPos) + MID$(text$, cursorPos + 2)
	END SELECT
	GOSUB CursorPosToX
	GOSUB Redraw
END SUB
'
'
' *****  TextInsert  *****
'		If text is selected in this grid, replace selected text with new text
'		v3 = key
'
SUB TextInsert
'	SELECT CASE TRUE
'		CASE (v3 = $$KeyTab)
'		CASE (v3 < 0x20):			EXIT SUB
'		CASE (v3 > 0x7E):			EXIT SUB
'	END SELECT
	GOSUB DeleteSelectedText
	IF (cursorPos > LEN(text$)) THEN cursorPos = LEN(text$)
	text$ = LEFT$(text$, cursorPos) + CHR$(v3) + MID$(text$, cursorPos + 1)
	INC cursorPos
	textModified = $$TRUE
	GOSUB CursorPosToX
	select = $$SelectNoChange													' for Redraw
	GOSUB Redraw
END SUB
'
'
' *****  DeleteSelectedText  *****
'		If text is selected in this grid, delete it from text
'		Goes into bufferNumber 0
'
SUB DeleteSelectedText
	XgrGetTextSelectionGrid (@textSelectionGrid)
	IF (grid = textSelectionGrid) THEN
		IF (begSelectPos != endSelectPos) THEN
			begPos = begSelectPos
			endPos = endSelectPos
			GOSUB DeleteTextSegment
			begSelectPos = begPos
			endSelectPos = begPos
			XgrSetClipboard (0, $$ClipboardTypeText, @deletedText$, @null[])
		END IF
	END IF
END SUB
'
'
' *****  DeleteTextSegment  *****
'		From begPos to endPos
'		return deletedText$
'
SUB DeleteTextSegment
	textDeleted = $$FALSE
	deletedText$ = ""
	IF (begPos != endPos) THEN
		IF (begPos > endPos) THEN
			temp = begPos:	begPos = endPos:	endPos = temp
		END IF
		IF (begPos >= LEN(text$)) THEN EXIT SUB
		textDeleted = $$TRUE
		textModified = $$TRUE
		IF (begPos = 0) THEN
			IF (endPos >= LEN(text$)) THEN
				SWAP text$, deletedText$
				leftIndent = 0
				cursorPos = 0
				xCursor = 0
				EXIT SUB
			END IF
		END IF
		deletedText$ = MID$(text$, begPos + 1, (endPos - begPos))
		a$ = LEFT$(text$, begPos)
		b$ = ""
		IF (endPos < LEN(text$)) THEN
			b$ = MID$(text$, endPos + 1)
		END IF
		text$ = a$ + b$
		SELECT CASE TRUE
			CASE (cursorPos <= begPos)		: cursorPos = cursorPos
			CASE (cursorPos <= endPos)		: cursorPos = begPos
			CASE (cursorPos > endPos)			: cursorPos = cursorPos - (endPos - begPos)
		END SELECT
		GOSUB CursorPosToX
	END IF
END SUB
'
'
' *****  TextReplace  *****  deselects text - doesn't change cursor or redraw
'		v0	= begPos
'		v2	= endPos				- same as TextAreas
'		r1$	= text string
'
SUB TextReplace
'
'	Deselect text if selected
'
	begSelectPos = endSelectPos
	noRedraw = $$TRUE
	begPos = v0
	endPos = v2
	GOSUB DeleteTextSegment
'
	IFZ r1$ THEN EXIT SUB
	lastChar = r1${UBOUND(r1$)}
	textModified = $$TRUE
'
	IFZ text$ THEN text$ = r1$ : EXIT SUB
'
	tail$ = ""
	IF (begPos < LEN(text$)) THEN
		tail$ = MID$(text$, begPos + 1)
	END IF
'
	text$ = LEFT$(text$, begPos) + r1$ + tail$
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
'	PRINT "TextLineMessage() : Redraw : grid ="; grid
	IFZ grid[grid].redraw THEN EXIT SUB
	IFZ grid[grid].state THEN EXIT SUB
	redrawn = $$TRUE
'
	XuiGetTabArray (grid, #GetTabArray, 0, 0, 0, 0, 0, @tabs[])
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	IF (select = $$SelectCancel) THEN begSelectPos = endSelectPos
	XgrGetTextSelectionGrid (@textSelectionGrid)
	selection = $$FALSE
'
	IF (grid = textSelectionGrid) THEN
		begPos = begSelectPos
		endPos = endSelectPos
		IF (begPos != endPos) THEN
			selection = $$TRUE
			IF (begPos > endPos) THEN
				temp		= begPos
				begPos	= endPos
				endPos	= temp
			END IF
		END IF
	END IF
'
	XgrGetGridColors (textGrid, @back, @draw, 0, 0, 0, 0, 0, 0)
	XgrClearGrid (textGrid, -1)
	bc = back : dc = draw
'
	IF text$ THEN
		IF gap THEN
			XgrMoveTo (textGrid, xib-leftIndent, 1 - (gap >> 1))
		ELSE
			XgrMoveTo (textGrid, xib-leftIndent, 0)
		END IF
		IFZ selection THEN
			DrawTextSegment (textGrid, @text$, back, draw, xib, yib, leftIndent, maxCharHeight, tabWidth, @tabs[])
		ELSE
			a$ = "":	b$ = "":	c$ = ""
			IF (begPos > 0) THEN
				a$ = LEFT$(text$, begPos)
			END IF
			b$ = MID$(text$, begPos + 1, (endPos - begPos))
			IF (endPos < LEN(text$)) THEN
				c$ = MID$(text$, endPos + 1)
			END IF
			IF a$ THEN DrawTextSegment (textGrid, @a$, back, draw, xib, yib, leftIndent, maxCharHeight, tabWidth, @tabs[])
			IF b$ THEN DrawTextSegment (textGrid, @b$, draw, back, xib, yib, leftIndent, maxCharHeight, tabWidth, @tabs[])
			IF c$ THEN DrawTextSegment (textGrid, @c$, back, draw, xib, yib, leftIndent, maxCharHeight, tabWidth, @tabs[])
		END IF
		XgrGetDrawpoint (textGrid, @x, @y)
		IF (x < width) THEN
			XgrFillBox (textGrid, back, x, 0, width - 1, height - 1)
		END IF
	ELSE
		XgrFillBox (textGrid, back, 0, 0, width - 1, height - 1)
	END IF
END SUB
'
'
' *****  TextSegmentWidth  *****  Assumes text$ at left margin
'		text$		(unchanged)
'		font
'		pos			(0..;  -1 = use entire text)
'		Handles tabs
'		Returns segWidth
'
SUB TextSegmentWidth
	segWidth = 0
	IFZ pos THEN EXIT SUB
	IFZ text$ THEN EXIT SUB
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	XuiGetTabArray (grid, #GetTabArray, 0, 0, 0, 0, 0, @tabs[])
	IF tabs[] THEN uTab = UBOUND(tabs[])
'
	tabIndex = INSTR(text$, "\t")
	IFZ tabIndex THEN
		IF (pos < 0) THEN
			XgrGetTextImageSize (font, @text$, 0, 0, @segWidth, 0, 0, 0)
		ELSE
			XgrGetTextImageSize (font, LEFT$(text$, pos), 0, 0, @segWidth, 0, 0, 0)
		END IF
		EXIT SUB
	END IF
'
	lenSeg = pos
	IF (pos < 0) THEN lenSeg = LEN(text$)
'
	ii = 1
	DO
		IF (tabIndex > lenSeg) THEN EXIT DO
		IF (tabIndex != ii) THEN
			XgrGetTextImageSize (font, MID$(text$, ii, (tabIndex - ii)), 0, 0, @partWidth, 0, 0, 0)
			segWidth = segWidth + partWidth
			ii = tabIndex
			IF (ii > lenSeg) THEN EXIT DO
		END IF
'
		SELECT CASE TRUE
			CASE tabs[]															' tabArray
						xStop = -1
						FOR jj = 0 TO uTab
							IF (segWidth < tabs[jj]) THEN
								xStop = tabs[jj]
								EXIT FOR
							END IF
						NEXT jj
						IF (xStop < 0) THEN NEXT CASE			' beyond list : revert to tabWidth
						segWidth = xStop
			CASE ELSE																' tabWidth
						segWidth = tabWidth * ((segWidth / tabWidth) + 1)
		END SELECT
		INC ii																		' bump the charPointer
		IF (ii > lenSeg) THEN EXIT DO
		tabIndex = INSTR(text$, "\t", ii)
		IFZ tabIndex THEN EXIT DO
	LOOP
	IF (ii <= lenSeg) THEN
		XgrGetTextImageSize (font, MID$(text$, ii, (lenSeg - ii + 1)), 0, 0, @partWidth, 0, 0, 0)
		segWidth = segWidth + partWidth
	END IF
END SUB
'
'
' *****  EraseOldCursor  *****
'
SUB EraseOldCursor
'	PRINT "TextLineMessage() : EraseCursor.A : grid ="; grid
	IF values[grid,$cursorShown] THEN
		oldXCursor = values[grid,$xCursorShown]
		XgrSetGridDrawingMode (textGrid, $$DrawModeXOR, -1, -1)
		xx1 = oldXCursor : yy1 = 0 : xx2 = oldXCursor : yy2 = height-1
'		PRINT "TextLineMessage() : EraseCursor.B : grid ="; grid
		GOSUB CursorOnOff
		XgrSetGridDrawingMode (textGrid, $$DrawModeCOPY, -1, -1)
	END IF
END SUB
'
'
' *****  DrawCursor  *****
'
SUB DrawCursor
'	PRINT "TextLineMessage() : DrawCursor.A  : grid ="; grid
	IF values[grid,$cursorShown] THEN
		XgrSetGridDrawingMode (textGrid, $$DrawModeXOR, -1, -1)
		xx1 = xCursor : yy1 = 0 : xx2 = xCursor : yy2 = height-1
'		PRINT "TextLineMessage() : DrawCursor.B  : grid ="; grid
		GOSUB CursorOnOff
		XgrSetGridDrawingMode (textGrid, $$DrawModeCOPY, -1, -1)
		values[grid,$xCursorShown] = xCursor
	END IF
END SUB
'
'
' *****  CursorOnOff  *****
'
SUB CursorOnOff
	IF values[grid,$cursorNoShow] THEN EXIT SUB
'	XgrGetBackgroundRGB (textGrid, @r, @g, @b)
'	rr = r : gg = g : bb = b
'	intensity = r + g + b
'	midway = 0x0000FFFF
'	IF (intensity < midway) THEN rr = NOT rr : gg = NOT gg : bb = NOT bb
'	XgrGetDrawingRGB (textGrid, @dr, @dg, @db)
'	XgrSetDrawingRGB (textGrid, rr, gg, bb)
'	XgrSetGridClip (textGrid, 0)
'	XgrDrawLine (textGrid, -1, xx1-1, yy1, xx2-1, yy2)
'	XgrDrawLine (textGrid, -1, xx1-2, yy1, xx2-2, yy2)
'	XgrSetDrawingRGB (textGrid, dr, dg, db)
'	XgrSetGridClip (textGrid, textGrid)
'
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
'	PRINT "TextLineMessage() : CursorOnOff   : grid ="; grid, d, dull
	XgrGetGridColors (textGrid, @back, @draw, @lo, @hi, @dull, @acc, @lot, @hit)
	XgrSetGridColors (textGrid, -1, dull, -1, -1, -1, -1, -1, -1)
	XgrDrawLine (textGrid, -1, xib+xx1-1, yib+yy1, xib+xx2-1, yib+yy2)
	XgrDrawLine (textGrid, -1, xib+xx1-2, yib+yy1, xib+xx2-2, yib+yy2)
	XgrSetGridColors (textGrid, -1, draw, -1, -1, -1, -1, -1, -1)
END SUB
'
'
' *****  Resize  *****  Does not redraw
'
SUB Resize
	x2 = width - 1
	y2 = height - 1
	XgrSetGridPositionAndSize (textGrid, v0, v1, @v2, @v3)
	XgrGetGridBoxLocal (textGrid, @xx, @yy, @xLR, @yLR)
	width = xLR + 1
	height = yLR + 1
	IF (xCursor >= v2) THEN
		xCursor = 0
		GOSUB CursorXToPos
	END IF
	noRedraw = $$TRUE
END SUB
'
'
' *****  UpdateSelect  *****  select = action
'
SUB UpdateSelect
	SELECT CASE select
		CASE $$SelectCancel,  $$SelectSet
					begSelectPos = cursorPos
					endSelectPos = cursorPos
		CASE $$SelectDrag
					endSelectPos = cursorPos
		CASE $$SelectExtend
					IF (begSelectPos <= endSelectPos) THEN
						SELECT CASE TRUE
							CASE (cursorPos < begSelectPos)
										begSelectPos = endSelectPos
										endSelectPos = cursorPos
							CASE (cursorPos > endSelectPos)
										endSelectPos = cursorPos
							CASE ELSE
										dBeg = cursorPos - begSelectPos
										dEnd = endSelectPos - cursorPos
										IF (dBeg <= dEnd) THEN
											begSelectPos = endSelectPos
											endSelectPos = cursorPos
										ELSE
											endSelectPos = cursorPos
										END IF
						END SELECT
					ELSE
						SELECT CASE TRUE												' endSelect < begSelect
							CASE (cursorPos < endSelectPos)
										endSelectPos = cursorPos
							CASE (cursorPos > begSelectPos)
										begSelectPos = endSelectPos
										endSelectPos = cursorPos
							CASE ELSE
										dEnd = cursorPos - endSelectPos
										dBeg = begSelectPos - cursorPos
										IF (dEnd <= dBeg) THEN
											endSelectPos = cursorPos
										ELSE
											begSelectPos = endSelectPos
											endSelectPos = cursorPos
										END IF
						END SELECT
					END IF
	END SELECT
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	DIM messageNoMod[upperMessage]
	messageNoMod[#GetTextCursor]			= SUBADDRESS (GetTextCursor)
	messageNoMod[#GetCursorXY]				= SUBADDRESS (GetCursorXY)
	messageNoMod[#GetSmallestSize]		= SUBADDRESS (GetSmallestSize)
	messageNoMod[#GetTextArrayBounds]	= SUBADDRESS (GetTextArrayBounds)
	messageNoMod[#GetTextSelection]		= SUBADDRESS (GetTextSelection)
	messageNoMod[#GetTextString]			= SUBADDRESS (GetTextString)
	messageNoMod[#HideTextCursor]			= SUBADDRESS (HideTextCursor)
	messageNoMod[#SetColor]						= SUBADDRESS (SetColor)
	messageNoMod[#SetColorExtra]			= SUBADDRESS (SetColorExtra)
	messageNoMod[#SetFont]						= SUBADDRESS (SetFont)
	messageNoMod[#SetFontNumber]			= SUBADDRESS (SetFontNumber)
	messageNoMod[#ShowTextCursor]			= SUBADDRESS (ShowTextCursor)
	IF messageNoMod[0] THEN PRINT "TextLineMessage:  message not SHARED"
'
	DIM messageMod[upperMessage]
	messageMod[#CursorH]							= SUBADDRESS (CursorH)
	messageMod[#Redraw]								= SUBADDRESS (Redraw)
	messageMod[#RedrawGrid]						= SUBADDRESS (Redraw)
	messageMod[#Resize]								= SUBADDRESS (Resize)
	messageMod[#SetCursorXY]					= SUBADDRESS (SetCursorXY)
	messageMod[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	messageMod[#SetTextSelection]			= SUBADDRESS (SetTextSelection)
	messageMod[#SetTextString]				= SUBADDRESS (SetTextString)
	messageMod[#TextDelete]						= SUBADDRESS (TextDelete)
	messageMod[#TextInsert]						= SUBADDRESS (TextInsert)
	messageMod[#TextReplace]					= SUBADDRESS (TextReplace)
	IF messageMod[0] THEN PRINT "TextLineMessage:  message not SHARED"
END SUB
END FUNCTION
'
'
' ############################  NOTE:  There are many places that different
' #####  TextMessage ()  #####  operations are performed depending on gridType.
' ############################  This is completely unaccepatable!!!  Fix this!!!
'
'	TextMessage called by:
'		XuiList
'		XuiConsole
'		XuiFileBox
'		XuiTextArea
'		XuiDirectoryBox
'		??? ... etc ... ???
'
'	Discussion:
'		Non-Proportional or Proportional spaced fonts
'			Cannot mix fonts sizes
'			space, tab, newLine are delimiters
'		These routines are tricky because
'			Both char offset (from 0) and STRING index (from 1) are employed
'			Pesky logic of counting (+-1...)
'
'		The cursor is ALWAYS visible on the display.
'		The cursor may live at a location NOT in the character stream (eg beyond
'			the end of a line, below the bottom line).  cursorPos is maintained as the
'			closest character to the cursor.  Cursor motion keys and text insertion
'			act from this character position.
'			WHAT HAPPENS TO YCURSOR IF FONT CHANGED ON THE FLY ???
'
'		text$[] is an ARRAY of text strings, one for each line.
'
'		TextMessage coordinates are 0 relative to the CLIP GRID.
'			(This includes xyCursor!)
'			When displayed, the textGrid indent and borderwidth are added.
'
'	DO:
'		- recheck redraw circumstances
'		- only redraw sections that have been changed
'				- redraw single line
'				- redraw from this line on down
'
' Text is always drawn 2 pixels to the right of the nominal position
' to leave room for a 2 pixel wide cursor on left of the 1st character.
'
FUNCTION  TextMessage (grid, message, v0, v1, v2, v3, r0, (r1, r1$, r1[], r1$[]))
	SHARED	values[]
	SHARED	textArray$[]
	SHARED	textString$[]
	SHARED	upperGrid
	SHARED	upperMessage
	SHARED	GRID	grid[]
	STATIC	SUBADDR		messageMod[]
	STATIC	SUBADDR		messageNoMod[]
	STATIC	XuiDirectoryBox,  XuiFileBox,  XuiList,  XuiConsole
	FUNCADDR  func (XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG, XLONG)
	UBYTE  null[]
'
' kids indices
'
	$TextArea				= 0
	$Text						= 1
	$ScrollH				= 2
	$ScrollV				= 3
'
'	values indices
'
	$textGrid				= 0						' Set in parent (XuiTextArea, etc)
	$cursorPos			= 2						' chars
	$cursorLine			= 3						'	lines
	$topIndent			= 4						' pixels !!!
	$topLine				= 5						' lines
	$xCursor				= 6						' pixels
	$yCursor				= 7						' pixels
	$xCursorShown		= 8
	$yCursorShown		= 9
	$cursorShown		= 10
	$tabWidth				= 11
	$begSelectPos		= 12
	$begSelectLine	= 13
	$endSelectPos		= 14
	$endSelectLine	= 15
	$begPosDrawn		= 16
	$begLineDrawn		= 17
	$endPosDrawn		= 18
	$endLineDrawn		= 19
	$maxCharWidth		= 20
	$maxCharHeight	= 21
	$selectionDrawn	= 22
	$lastValue			= 31					' XuiConsole accesses 30, 31
'
'	IF ((message = #LostTextSelection) OR (message = #SetTextSelection) OR (message = #SetTextCursor) OR (message = #RedrawText)) THEN
'		XgrMessageNumberToName (message, @message$)
'		XstLog ("TextMessage() : " + STRING$(grid) + " " + message$ + STR$(v0) + STR$(v1) + STR$(v2) + STR$(v3))
'	END IF
'
	IFZ messageMod[] THEN GOSUB Initialize
	IF (message > upperMessage) THEN RETURN
	IFZ message THEN RETURN
'
'	XgrMessageNumberToName (message, @message$)
'	PRINT "TextMessage() : ", grid, message$, v0, v1, v2, v3
'
	XuiGetAlign (grid, #GetAlign, 0, 0, @indentX, @indentY, 0, @borderWidth)
'
	xib = 2											' room for 2 pixel cursor left of 1st char
	yib = 0											' no room needed above top line of chars
	XgrGetGridType (grid, @gridType)
	xCursor = values[grid,$xCursor]
	yCursor = values[grid,$yCursor]
	textGrid = values[grid,$textGrid]
	cursorPos = values[grid,$cursorPos]
	cursorLine = values[grid,$cursorLine]
	topIndent = values[grid,$topIndent]
	topLine = values[grid,$topLine]
	maxCharWidth = values[grid,$maxCharWidth]
	maxCharHeight = values[grid,$maxCharHeight]
	XuiGetFontNumber (grid, #GetFontNumber, @font, 0, 0, 0, 0, 0)
	XuiSetFontNumber (textGrid, #SetFontNumber, font, 0, 0, 0, 0, 0)
	IFZ (maxCharWidth OR maxCharHeight) THEN
		XgrGetFontMetrics (font, @maxCharWidth, @maxCharHeight, @ascent, @decent, @gap, @flags)
		IF (maxCharWidth <= 0) THEN PRINT "TextMessage() : error ::: (maxCharWidth <= 0)" : maxCharWidth = 8
		IF (maxCharHeight <= 0) THEN PRINT "TextMessage() : error ::: (maxCharHeight <= 0)" : maxCharHeight = 15
		values[grid,$maxCharWidth] = maxCharWidth
		values[grid,$maxCharHeight] = maxCharHeight
	END IF
'
'	Message not modifying text?
'
	IF messageNoMod[message] THEN
		GOSUB @messageNoMod[message]
		RETURN
	END IF
'
'	Remaining messages manipulate text
'
	changer = $$TRUE
	ATTACH textArray$[grid, ] TO text$[]
'
	IF text$[] THEN
		uText = UBOUND(text$[])
		cursorPos = values[grid,$cursorPos]
		cursorLine = values[grid,$cursorLine]
		topIndent = values[grid,$topIndent]
		topLine = values[grid,$topLine]
		begSelectPos = values[grid,$begSelectPos]
		begSelectLine = values[grid,$begSelectLine]
		endSelectPos = values[grid,$endSelectPos]
		endSelectLine = values[grid,$endSelectLine]
		IF (begSelectLine > uText) THEN begSelectLine = uText
		IF (endSelectLine > uText) THEN endSelectLine = uText
		IF (begSelectPos > LEN(text$[begSelectLine])) THEN begSelectPos = LEN(text$[begSelectLine])
		IF (endSelectPos > LEN(text$[endSelectLine])) THEN endSelectPos = LEN(text$[endSelectLine])
	ELSE
		uText = -1
		cursorPos =  0
		cursorLine = 0
		topIndent =  0
		topLine =  0
		begSelectPos =  0
		begSelectLine =  0
		endSelectPos =  0
		endSelectLine =  0
	END IF
'
	textGrid = values[grid,$textGrid]
	XgrSetGridClip (textGrid, textGrid)
	XgrGetGridBoxLocal (textGrid, 0, 0, @xLR, @yLR)
	width = xLR - 1
	height = yLR + 1
	columns = width \ maxCharWidth	' number of widest chars per row
	rows = height \ maxCharHeight		' number of COMPLETE rows visible
'
' Has somebody dorked with the text without updating the parameters?
' Later: how should this be handled?  User should update the parameters!
'
	IF (uText >= 0) THEN
		IF (cursorLine > uText) THEN
			cursorLine = uText
			topLine = cursorLine - rows + 1
			IF (topLine < 0) THEN topLine = 0
			topIndent = 0
			cursorPos = 0
			xCursor = 0
			yCursor = (cursorLine - topLine) * maxCharHeight
		END IF
	END IF
'
	noRedraw					= $$FALSE
	redrawn						= $$FALSE
	oldUText					= uText
	oldCursorPos			= cursorPos
	oldCursorLine			= cursorLine
	oldTopIndent			= topIndent
	oldTopLine				= topLine
	oldXCursor				= values[grid,$xCursorShown]
	oldYCursor				= values[grid,$yCursorShown]
	oldBegPos					= values[grid,$begPosDrawn]
	oldBegLine				= values[grid,$begLineDrawn]
	oldEndPos					= values[grid,$endPosDrawn]
	oldEndLine				= values[grid,$endLineDrawn]
	oldSelectionDrawn	= values[grid,$selectionDrawn]
	selectionDrawn		= oldSelectionDrawn
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
'
	SELECT CASE message
		CASE #Redraw			: select = v2
		CASE #RedrawGrid	: select = v2
	END SELECT
'
	GOSUB @messageMod[message]
'
'	Temporary fix for cursor control
'
'	GOSUB ValidatePosLineLeftTop
	yCursorLine = (cursorLine - topLine) * maxCharHeight
	IF (yCursor != yCursorLine) THEN
		yCursor = yCursorLine
		GOSUB CursorXToPos
	END IF
'
	IFZ noRedraw THEN
		SELECT CASE ALL TRUE
			CASE (oldTopLine != topLine), (oldTopIndent != topIndent)
						IFF redrawn THEN GOSUB Redraw
			CASE (oldTopLine != topLine), (oldTopIndent != topIndent), (oldUText != uText)
						IFZ stopScrollRedraw THEN GOSUB RedrawScrollH
			CASE (oldTopLine != topLine), (oldUText != uText)
						IFZ stopScrollRedraw THEN GOSUB RedrawScrollV
		END SELECT
'
' *****  Can't be checking against specific gridTypes... adding new ones wouldn't then work...
'
		IFF redrawn THEN
			IF ((gridType = XuiList) OR (gridType = XuiDirectoryBox) OR (gridType = XuiFileBox)) THEN
				IF (oldCursorLine != cursorLine) THEN
					GOSUB Redraw
				END IF
			ELSE
				XgrGetTextSelectionGrid (@textSelectionGrid)
				IF (grid = textSelectionGrid) THEN
					SELECT CASE TRUE
						CASE (begSelectLine != oldBegLine), (begSelectPos != oldBegPos)
							IF (oldSelectionDrawn OR (begSelectLine != endSelectLine) OR (begSelectPos != endSelectPos)) THEN
								GOSUB Redraw
							END IF
						CASE (endSelectLine != oldEndLine), (endSelectPos != oldEndPos)
							IF (oldSelectionDrawn OR (begSelectLine != endSelectLine) OR (begSelectPos != endSelectPos)) THEN
								GOSUB Redraw
							END IF
					END SELECT
				END IF
				IFF redrawn THEN
					IF ((xCursor != oldXCursor) OR (yCursor != oldYCursor)) THEN
						GOSUB EraseOldCursor
						GOSUB DrawCursor
					END IF
				END IF
			END IF
		END IF
	END IF
'
	values[grid,$cursorPos]				= cursorPos
	values[grid,$cursorLine]			= cursorLine
	values[grid,$topIndent]				= topIndent
	values[grid,$topLine]					= topLine
	values[grid,$xCursor]					= xCursor
	values[grid,$yCursor]					= yCursor
	values[grid,$begSelectPos]		= begSelectPos
	values[grid,$begSelectLine]		= begSelectLine
	values[grid,$endSelectPos]		= endSelectPos
	values[grid,$endSelectLine]		= endSelectLine
	values[grid,$selectionDrawn]	= selectionDrawn
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
	XgrSetGridClip (textGrid, 0)
	RETURN
'
'
' *****  SetValues  *****  Initialize grid values
'
SUB SetValues
	tabWidth = maxCharWidth + maxCharWidth
	XgrSetGridDrawingMode (textGrid, $$DrawModeCOPY, $$LineStyleSolid, 1)		' for cursor
	XuiSetTabWidth (grid, #SetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	values[grid,$cursorPos]				= 0
	values[grid,$cursorLine]			= 0
	values[grid,$topIndent]				= 0
	values[grid,$topLine]					= 0
	values[grid,$xCursor]					= 0
	values[grid,$yCursor]					= 0
	values[grid,$xCursorShown]		= 0
	values[grid,$yCursorShown]		= 0
	values[grid,$cursorShown]			= $$FALSE
	values[grid,$begSelectPos]		= 0
	values[grid,$begSelectLine]		= 0
	values[grid,$endSelectPos]		= 0
	values[grid,$endSelectLine]		= 0
	values[grid,$begPosDrawn]			= 0
	values[grid,$begLineDrawn]		= 0
	values[grid,$endPosDrawn]			= 0
	values[grid,$endLineDrawn]		= 0
	values[grid,$selectionDrawn]	= $$FALSE
	values[grid,$maxCharWidth]		= 0
	values[grid,$maxCharHeight]		= 0
END SUB
'
'
' *****  HideTextCursor  *****
'
SUB HideTextCursor
'	PRINT "TextMessage() : HideTextCursor: A"
	IFF values[grid,$cursorShown] THEN EXIT SUB
'	PRINT "TextMessage() : HideTextCursor: B"
	GOSUB EraseOldCursor
	values[grid,$cursorShown] = $$FALSE
END SUB
'
'
' *****  ShowTextCursor  *****
'
SUB ShowTextCursor
'	PRINT "TextMessage() : ShowTextCursor: A"
	IF values[grid,$cursorShown] THEN EXIT SUB
'	PRINT "TextMessage() : ShowTextCursor: B"
	values[grid,$cursorShown] = $$TRUE
	GOSUB DrawCursor
END SUB
'
'
' *****  GetTextPosition  *****
'		v01 = x,y in local coords
'		v23 = closest position/line out
'		r1  = $$TRUE if xy to right of or below text
'
SUB GetTextPosition
	IF (uText < 0) THEN v2 = 0 : v3 = 0 : r1 = 0 : EXIT SUB		' prevents blow-up
'
	xCursorSave = xCursor								' See CursorXToPos
	topIndentSave = topIndent
	cursorPosSave = cursorPos
	cursorLineSave = cursorLine
'
	xText = v0 - xib
	yText = v1 - yib
	IF (xText < 0) THEN xText = 0
	IF (yText < 0) THEN yText = 0
'
	cursorLine = topLine + (yText / maxCharHeight)
'
	outOfBounds = $$FALSE
	IF (cursorLine > uText) THEN						' beyond text
		outOfBounds = $$TRUE
		cursorLine = uText
	END IF
'
	xCursor = xText
	GOSUB CursorXToPos
'
	v2 = cursorPos
	v3 = cursorLine
	r1 = outOfBounds
'
	xCursor = xCursorSave
	topIndent = topIndentSave
	cursorPos = cursorPosSave
	cursorLine = cursorLineSave
END SUB
'
'
' *****  GetTextCursor  *****
'
SUB GetTextCursor
	v0 = values[grid,$cursorPos]
	v1 = values[grid,$cursorLine]
	v2 = values[grid,$topIndent]
	v3 = values[grid,$topLine]
END SUB
'
'
' *****  GetCursorXY  *****
'
SUB GetCursorXY
	v0 = values[grid,$xCursor]
	v1 = values[grid,$yCursor]
END SUB
'
'
' *****  SetTextCursor  *****  v0123 = cursorPos/cursorLine/topIndent/topLine
'
SUB SetTextCursor
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error : u != uText"
'
	IFZ text$[] THEN v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
	IF (v3 >= 0) THEN topLine = v3
	IF (v2 >= 0) THEN topIndent = v2 * maxCharWidth
	IF (v1 >= 0) THEN cursorLine = v1
	IF (v0 >= 0) THEN cursorPos = v0
'
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorPosToXY
'
	begSelectPos = cursorPos
	endSelectPos = cursorPos
	begSelectLine = cursorLine
	endSelectLine = cursorLine
'	PRINT "SetTextCursor: "; begSelectPos, begSelectLine, endSelectPos, endSelectLine, cursorPos, cursorLine
END SUB
'
'
' *****  SetCursorXY  *****  v01 = xyCursor : -1 = don't change
'
SUB SetCursorXY
	IF ((v0 < 0) AND (v1 < 0)) THEN EXIT SUB
'
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : SetCursorXY : u != uText"
'
	IF (v0 >= 0) THEN
		xCursor = v0
		IF (v0 > xLR) THEN xCursor = xLR
	END IF
'
	IF (v1 >= 0) THEN
		yCursor = v1
		IF (v1 > yLR) THEN yCursor = yLR
	END IF
'
	cursorLine = topLine + (yCursor / maxCharHeight)
	IF (cursorLine > uText) THEN cursorLine = uText
	lineWidth = 0
	IF text$[cursorLine] THEN
		pos = -1
		SWAP text$[cursorLine], text$
		GOSUB TextSegmentWidth
		SWAP text$, text$[cursorLine]
		lineWidth = segWidth
	END IF
	GOSUB CursorXToPos
END SUB
'
'
' *****  GetTextArrayBounds  *****  v01 = cursor pos/line : v23 = upper pos/line
'
SUB GetTextArrayBounds
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = -1
	ATTACH textArray$[grid, ] TO text$[]
	IFZ text$[] THEN EXIT SUB
	v0 = values[grid,$cursorPos]
	v1 = values[grid,$cursorLine]
	v2 = 0
	v3 = UBOUND (text$[])
	IF (v3 >= 0) THEN v2 = LEN(text$[v3])
	ATTACH text$[] TO textArray$[grid, ]
END SUB
'
'
' *****  GetTextArray  *****
'
SUB GetTextArray
	v0 = cursorPos
	v1 = cursorLine
	v2 = topIndent \ maxCharWidth
	v3 = topLine
	XuiGetTextArray (grid, #GetTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  GetTextArrayLine  *****  v0 = line # to get : @v1 = -1 (bad line #)
'
SUB GetTextArrayLine
	XuiGetTextArrayLine (grid, #GetTextArrayLine, v0, @v1, 0, 0, 0, @r1$)
END SUB
'
'
' *****  GrabTextArray  *****
'
SUB GrabTextArray
	v0 = cursorPos
	v1 = cursorLine
	v2 = topIndent \ maxCharWidth
	v3 = topLine
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @r1$[])
END SUB
'
'
' *****  SetTextArray  *****
'
SUB SetTextArray
'	PRINT "SetTextArray: "; begSelectPos, begSelectLine, endSelectPos, endSelectLine, cursorPos, cursorLine
	DIM text$[]
	XstCopyArray (@r1$[], @text$[])
	uText = UBOUND (text$[])
	xCursor = 0
	yCursor = 0
	cursorPos = 0
	cursorLine = 0
	topIndent = 0
	topLine = 0
	begSelectPos = 0
	endSelectPos = 0
	begSelectLine = 0
	endSelectLine = 0
	noRedraw = $$TRUE
END SUB
'
'
' *****  SetTextArrayLine  *****
'		v0  = line number to set
'		r1$ = new line
'		Return  v1  = -1 if bad line number
'
'		IF (v0 = -1) OR (v0 = Last line + 1), expand array to add it in
'
SUB SetTextArrayLine
	v1 = -1
	IF (v0 = uText + 1) THEN						' handles both NULL and non-NULL
		v1 = 0
		INC uText
		REDIM text$[uText]
		text$[uText] = r1$
		EXIT SUB
	END IF
'
	IF (v0 = -1) THEN										' Add to top
		IF (uText = -1) THEN EXIT SUB
		v1 = 0
		DIM temp$[uText + 1]
		temp$[0] = r1$
		FOR i = 0 TO uText
			ATTACH text$[i] TO temp$[i + 1]
		NEXT i
		SWAP temp$[], text$[]
		INC uText
		INC topLine
		INC cursorLine
		EXIT SUB
	END IF
	IF ((v0 < 0) OR (v0 > uText + 1)) THEN EXIT SUB
	v1 = 0
	text$[v0] = r1$
END SUB
'
'
' *****  GetTextSelection  *****
'
SUB GetTextSelection
	v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : r1$ = ""
	XgrGetTextSelectionGrid (@textSelectionGrid)
	IF (grid != textSelectionGrid) THEN EXIT SUB
	v0 = values[grid,$begSelectPos]
	v1 = values[grid,$begSelectLine]
	v2 = values[grid,$endSelectPos]
	v3 = values[grid,$endSelectLine]
	IF ((v0 = v2) AND (v1 = v3)) THEN EXIT SUB
'
	SELECT CASE TRUE
		CASE (v1 > v3)	: SWAP v0, v2 : SWAP v1, v3
		CASE (v1 = v3)	: IF (v0 > v2) THEN SWAP v0, v2
	END SELECT
'
	ATTACH textArray$[grid, ] TO text$[]
	IFZ text$[] THEN v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0 : EXIT SUB
	uText = UBOUND(text$[])
	IF (v1 > uText) THEN
		v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
		ATTACH text$[] TO textArray$[grid, ]
		EXIT SUB
	END IF
'
	IF (v3 > uText) THEN
		v3 = uText
		v2 = LEN(text$[uText])
		IF (v1 = uText) THEN
			IF (v0 >= v2) THEN
				v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
				ATTACH text$[] TO textArray$[grid, ]
				EXIT SUB
			END IF
		END IF
	END IF
'
	IF (v1 = v3) THEN
		IF (v0 >= LEN(text$[v1])) THEN
			v0 = 0 : v1 = 0 : v2 = 0 : v3 = 0
		ELSE
			r1$ = MID$(text$[v1], v0 + 1, (v2 - v0))
		END IF
		ATTACH text$[] TO textArray$[grid, ]
		EXIT SUB
	END IF
'
	IF (v0 < LEN(text$[v1])) THEN
		r1$ = MID$(text$[v1], v0 + 1) + "\n"
	ELSE
		r1$ = "\n"
	END IF
	IF (v3 > v0 + 1) THEN
		FOR line = v1 + 1 TO v3 - 1
			r1$ = r1$ + text$[line] + "\n"
		NEXT line
	END IF
	IF (v2 > 0) THEN
		r1$ = r1$ + LEFT$(text$[v3], v2)
	END IF
	ATTACH text$[] TO textArray$[grid, ]
END SUB
'
'
' *****  SetTextSelection  *****
'
SUB SetTextSelection
	begSelectPos	= v0
	begSelectLine	= v1
	endSelectPos	= v2
	endSelectLine	= v3
	XuiPokeTextArray (grid, #PokeTextArray, 0, 0, 0, 0, 0, @text$[])
	XgrSetTextSelectionGrid (grid)
	XuiGrabTextArray (grid, #GrabTextArray, 0, 0, 0, 0, 0, @text$[])
	noRedraw = $$TRUE
END SUB
'
'
' *****  CursorH  *****
'
SUB CursorH
	select = v2
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	IF (uText < 0) THEN EXIT SUB
	SELECT CASE r1
		CASE #Change		: GOSUB CursorSet
		CASE #OneLess		: GOSUB CursorOneLeft
		CASE #SomeLess	: GOSUB CursorWordLeft
		CASE #Minimum		: GOSUB CursorBegLine
		CASE #OneMore		: GOSUB CursorOneRight
		CASE #SomeMore	: GOSUB CursorWordRight
		CASE #Maximum		: GOSUB CursorEndLine
	END SELECT
	GOSUB UpdateSelect
END SUB
'
'
' *****  CursorSet  *****  Set cursor to xy (assume within grid)
'
SUB CursorSet
	IFZ rows THEN EXIT SUB
	belowTextHeight = rows * maxCharHeight
'	XgrConvertWindowToLocal (textGrid, v0, v1, @xGrid, @yGrid)
'
	xText = v0 + xib
	yText = v1 + yib
'
	SELECT CASE ALL TRUE
		CASE (yText >= belowTextHeight)
					GOSUB ScrollVOneDown
					yText = belowTextHeight - 1
		CASE (yText < 0)
					GOSUB ScrollVOneUp
					yText = 0
		CASE (xText > xLR)
					GOSUB ScrollHOneRight
					xText = xLR
		CASE (xText < 0)
					GOSUB ScrollHOneLeft
					xText = 0
	END SELECT
'
	row = yText / maxCharHeight					' align yCursor to a row
	yCursor = row * maxCharHeight
'
	xCursor = xText
	cursorLine = topLine + row
	IF (cursorLine > uText) THEN						' beyond text:  use last char
		cursorLine = uText										'		(leave xCursor alone!)
		cursorPos = LEN(text$[cursorLine])
	ELSE
		GOSUB CursorXToPos
	END IF
END SUB
'
'
' *****  CursorOneLeft  *****  DEC cursorPos, then reset cursor on display
'
SUB CursorOneLeft
	IFZ cursorPos THEN
		IFZ cursorLine THEN EXIT SUB									' already UL of text
		DEC cursorLine
		cursorPos = LEN(text$[cursorLine])
	ELSE
		DEC cursorPos
	END IF
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorPosToXY
END SUB
'
'
' *****  CursorWordLeft  *****  Beginning of previous (or current) word
'
SUB CursorWordLeft
	DO
		IFZ cursorPos THEN												' find line with text
			DO
				IFZ cursorLine THEN										' no more lines with text
					GOSUB ValidatePosLineLeftTop
					GOSUB CursorPosToXY
					EXIT SUB
				END IF
				DEC cursorLine
				lenLine = LEN(text$[cursorLine])
				IF lenLine THEN
					cursorPos = lenLine
					EXIT DO
				END IF
			LOOP
		END IF
'
		a$ = text$[cursorLine]
		DO WHILE cursorPos												' get into a word
			DEC cursorPos
			SELECT CASE a${cursorPos}
				CASE ' ', '\t':		DO DO
			END SELECT
			EXIT DO
		LOOP
		IF cursorPos THEN EXIT DO									' found a word
	LOOP
'
	ws = RINCHR (a$, " \t", cursorPos + 1)
	cursorPos = ws															' beg = char following white space
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorPosToXY
END SUB
'
'
' *****  CursorOneRight  *****
'
SUB CursorOneRight
	lastChar = LEN(text$[cursorLine]) - 1
	IF (cursorPos > lastChar) THEN
		IF (cursorLine < uText) THEN
			cursorPos = 0
			INC cursorLine
		END IF
	ELSE
		INC cursorPos
	END IF
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorPosToXY
END SUB
'
'
' *****  CursorWordRight  *****  Beginning of next word
'
SUB CursorWordRight
	a$ = text$[cursorLine]											' find next delimiter
	lenText = LEN(a$)
	IF (cursorPos < lenText) THEN
		ws = INCHR (a$, " \t", cursorPos + 1)
		IF ws THEN
			cursorPos = ws
		ELSE
			cursorPos = lenText
		END IF
	END IF
'
	DO
		IF (cursorPos >= lenText) THEN
			IF (cursorLine = uText) THEN						' no more lines with text
				cursorPos = lenText										' pos after last character
				GOSUB ValidatePosLineLeftTop
				GOSUB CursorPosToXY
				EXIT SUB
			END IF
			INC cursorLine
			cursorPos = 0
			a$ = text$[cursorLine]
			lenText = LEN(a$)
			DO DO
		END IF
'
		DO WHILE (cursorPos < lenText)						' find next non-delimiter
			SELECT CASE a${cursorPos}
				CASE ' ', '\t'
					INC cursorPos
					DO DO
			END SELECT
			EXIT DO 2
		LOOP
	LOOP
'
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorPosToXY
END SUB
'
'
' *****  CursorBegLine  *****  Beginning of Line
'
SUB CursorBegLine
	topIndent	= 0
	xCursor		= 0
	cursorPos	= 0
	IF (cursorLine >= uText) THEN
		yCursor = (cursorLine - topLine) * maxCharHeight
	END IF
END SUB
'
'
' *****  CursorEndLine  *****  End of Line
'
SUB CursorEndLine
	text$ = text$[cursorLine]
	lineWidth = 0
	cursorPos	= LEN (text$)
	GOSUB ValidatePosLineLeftTop
'
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
'
	IF (cursorLine >= uText) THEN
		yCursor = (cursorLine - topLine) * maxCharHeight
	END IF
'
	IFZ lineWidth THEN
		xCursor		= 0
		topIndent	= 0
		EXIT SUB
	END IF
'
	xCursor = lineWidth - topIndent
	SELECT CASE TRUE
		CASE (xCursor < 0), (xCursor > width)
					xCursor = xLR - 16
					topIndent = lineWidth - width + 17
	END SELECT
END SUB
'
'
' *****  CursorV  *****
'
SUB CursorV
	select = v2
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	IF (uText < 0) THEN EXIT SUB
	SELECT CASE r1
		CASE #Change		: GOSUB CursorSet
		CASE #OneLess		: GOSUB CursorOneUp
		CASE #SomeLess	: GOSUB CursorBegPage
		CASE #Minimum		: GOSUB CursorBegText
		CASE #OneMore		: GOSUB CursorOneDown
		CASE #SomeMore	: GOSUB CursorEndPage
		CASE #Maximum		: GOSUB CursorEndText
	END SELECT
	GOSUB UpdateSelect
END SUB
'
'
' *****  CursorOneUp  *****  Up one line
'
SUB CursorOneUp
	IFZ cursorLine THEN EXIT SUB
	DEC cursorLine
	IF (topLine > cursorLine) THEN topLine = cursorLine
	yCursor = yCursor - maxCharHeight
	IF (yCursor < 0) THEN yCursor = 0
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorXToPos
END SUB
'
'
' *****  CursorOneDown  *****  Down one line
'
SUB CursorOneDown
	IF (cursorLine >= uText) THEN EXIT SUB					' already at bottom
	INC cursorLine
	IFZ rows THEN
		topLine = cursorLine
	ELSE
		IF (topLine < cursorLine - rows + 1) THEN
			topLine = cursorLine - rows + 1
		END IF
	END IF
	GOSUB ValidatePosLineLeftTop
	yCursor = (cursorLine - topLine) * maxCharHeight
	GOSUB CursorXToPos
END SUB
'
'
' *****  CursorBegPage  *****   Top line, same xCursor
'
SUB CursorBegPage
	cursorLine	= topLine
	yCursor			= 0
	GOSUB CursorXToPos
END SUB
'
'
' *****  CursorEndPage  *****		Bottom line, same xCursor
'
SUB CursorEndPage
	IFZ rows THEN EXIT SUB
	cursorLine = topLine + rows - 1
	IF (cursorLine > uText) THEN cursorLine = uText
	GOSUB ValidatePosLineLeftTop
	yCursor = (cursorLine - topLine) * maxCharHeight
	GOSUB CursorXToPos
END SUB
'
'
' *****  CursorBegText  *****
'
SUB CursorBegText
	topLine			= 0
	cursorLine	= 0
	topIndent		= 0
	xCursor			= 0
	yCursor			= 0
END SUB
'
'
' *****  CursorEndText  *****
'
SUB CursorEndText
	cursorLine = uText
	topLine = cursorLine - rows + 2
	IF (topLine < 0) THEN topLine = 0
	GOSUB ValidatePosLineLeftTop
	text$ = text$[cursorLine]
	lineWidth = 0
'
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
'
	SELECT CASE TRUE
		CASE (lineWidth = 0)
			xCursor		= 0
			topIndent	= 0
		CASE (lineWidth > width)
			xCursor		= xLR
			topIndent	= lineWidth - xCursor
		CASE ELSE
			xCursor		= lineWidth
			topIndent	= 0
	END SELECT
'
	yCursor = (cursorLine - topLine) * maxCharHeight
	cursorPos = LEN(text$)
END SUB
'
'
' *****  CursorXToPos  *****  Get cursorPos from cursorLine and xCursor
'		If in a line of text, align xCursor to nearset character
'		Used by GetTextPosition as well
'		Set outOfBounds for GetTextPosition if beyond end of line
'
SUB CursorXToPos
	xIndent = xCursor + topIndent
	text$ = text$[cursorLine]
	lineWidth = 0
'
	IF text$ THEN
		pos = -1
		GOSUB TextSegmentWidth
		lineWidth = segWidth
	END IF
'
	IF ((gridType = XuiList) OR (gridType = XuiFileBox) OR (gridType = XuiDirectoryBox)) THEN
		xIndent = lineWidth
		cursorPos = LEN (text$)
		xCursor = xIndent
		offset = xIndent
		EXIT SUB
	END IF
'
	IF (xIndent >= lineWidth) THEN
'		Cursor to right of new line.  Leave it in the void, but set cursorPos to
'			end of line
		cursorPos = LEN (text$)
		outOfBounds = $$TRUE
	ELSE
'		Cursor in midst of new line.  Align it to nearest character
		cursorPos = xIndent / maxCharWidth
		offset = 0
		IF cursorPos THEN
			pos = cursorPos
			GOSUB TextSegmentWidth
			offset = segWidth
		END IF
'
		SELECT CASE TRUE
			CASE (xIndent = offset):	EXIT SUB			' Hit it exactly
			CASE (xIndent < offset):								' cursorPos too large
						FOR i = (cursorPos - 1) TO 0 STEP -1
							pos = i
							GOSUB TextSegmentWidth
							offset = segWidth
							IF (xIndent >= offset) THEN
								cursorPos = i
								EXIT FOR
							END IF
						NEXT i
						IF (topIndent > offset) THEN
							topIndent = offset
							xCursor = 0
						ELSE
							xCursor = offset - topIndent
						END IF
			CASE ELSE																' right of approxPos
						lastOffset = offset
						FOR i = (cursorPos + 1) TO LEN(text$)
							pos = i
							GOSUB TextSegmentWidth
							offset = segWidth
							IF (xIndent < offset) THEN
								cursorPos = i - 1
								EXIT FOR
							END IF
							lastOffset = offset
						NEXT i
						IF (topIndent > lastOffset) THEN
							topIndent = lastOffset
							xCursor = 0
						ELSE
							xCursor = lastOffset - topIndent
						END IF
		END SELECT
	END IF
END SUB
'
'
' *****  CursorPosToXY  *****		Get cursor XY from cursorPos/cursorLine
'		In:		cursorPos							Cursor is ALWAYS visible
'					cursorLine
'		Out:	xCursor			- pixels
'					yCursor			- pixels
'					topIndent		- pixels
'
SUB CursorPosToXY
	action = r1
	IFZ cursorLine THEN
		IFZ cursorPos THEN
			xCursor		= 0
			yCursor		= 0
			topLine		= 0
			topIndent = 0
			EXIT SUB
		END IF
	END IF
'
'	Find xCursor from cursorPos
'
	xCursor = 0 - topIndent
	IF cursorPos THEN
		pos = cursorPos
		SWAP text$[cursorLine], text$
		GOSUB TextSegmentWidth
		SWAP text$, text$[cursorLine]
		xCursor = segWidth - topIndent
	END IF
'
	SELECT CASE TRUE
		CASE (xCursor < 0)
					topIndent	= topIndent + xCursor
					xCursor		= 0
		CASE (xCursor > width)
					topIndent = topIndent + (xCursor - width) + 1
					xCursor		= xLR
	END SELECT
'
'	Find yCursor
'
	IFZ rows THEN																				' no complete rows
		yCursor = 0
		topLine = cursorLine
	ELSE
		SELECT CASE TRUE
			CASE (cursorLine = topLine)
						yCursor = 0
			CASE (cursorLine > topLine)											' scroll up required?
						row = cursorLine - topLine + 1								' row number (from 1)
						IF (row > rows) THEN
							IF (gridType = XuiConsole) THEN
								topLine = cursorLine - rows + 1
							ELSE
								topLine = cursorLine - (rows >> 1)
							END IF
							SELECT CASE message
								CASE #CursorH
									IF ((action = #OneMore) OR (action = #SomeMore)) THEN
										topLine = cursorLine - rows + 1
									END IF
								CASE #CursorV
									IF (action = #OneMore) THEN
										topLine = cursorLine - rows + 1
									END IF
							END SELECT
						END IF
						IF (topLine < 0) THEN topLine = 0
						yCursor = (cursorLine - topLine) * maxCharHeight
			CASE ELSE																				' scroll down required
						topLine = cursorLine - (rows >> 1)
						SELECT CASE message
							CASE #CursorH
								IF ((action = #OneLess) OR (action = #SomeLess)) THEN
									topLine = cursorLine
								END IF
							CASE #CursorV
								IF (action = #OneLess) THEN
									topLine = cursorLine
								END IF
						END SELECT
						IF (topLine < 0) THEN topLine = 0
						yCursor = (cursorLine - topLine) * maxCharHeight
		END SELECT
	END IF
END SUB
'
'
' *****  ScrollH  *****
'
SUB ScrollH
	select = v2
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	IF (uText < 0) THEN EXIT SUB
	SELECT CASE r1
		CASE #OneLess		: GOSUB ScrollHOneLeft
		CASE #MuchLess	: GOSUB ScrollHPageLeft
		CASE #OneMore		: GOSUB ScrollHOneRight
		CASE #MuchMore	: GOSUB ScrollHPageRight
		CASE #Change		: GOSUB ScrollHChange
	END SELECT
	GOSUB UpdateSelect
END SUB
'
'
' *****  ScrollHOneLeft  *****	Scroll average character width left
'
SUB ScrollHOneLeft
	IFZ topIndent THEN EXIT SUB
	topIndent = topIndent - maxCharWidth
	IF (topIndent < 0) THEN topIndent = 0
	GOSUB ValidatePosLineLeftTop
	IF (topIndent != oldTopIndent) THEN GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollHOneRight  *****  Scroll average character width right
'
SUB ScrollHOneRight
	maxWidth = width
	lastLine = topLine + rows - 1
	IF (lastLine > uText) THEN lastLine = uText
	GOSUB ValidatePosLineLeftTop
'
	pos = -1
	FOR i = topLine TO lastLine
		SWAP text$[i], text$
		GOSUB TextSegmentWidth
		SWAP text$, text$[i]
		lineWidth = segWidth
		IF (lineWidth > maxWidth) THEN maxWidth = lineWidth
	NEXT i
	IF (maxWidth > (topIndent + width)) THEN
		topIndent = topIndent + maxCharWidth
		GOSUB CursorXToPos
	END IF
END SUB
'
'
' *****  ScrollHPageLeft  *****  Scroll left one page
'
SUB ScrollHPageLeft
	IFZ topIndent THEN EXIT SUB
	topIndent = topIndent - width
	IF (topIndent < 0) THEN topIndent = 0
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollHPageRight  *****  Scroll right one page
'
SUB ScrollHPageRight
	maxWidth = width
	lastLine = topLine + rows - 1
	IF (lastLine > uText) THEN lastLine = uText
	GOSUB ValidatePosLineLeftTop
'
	pos = -1
	FOR i = topLine TO lastLine
		SWAP text$, text$[i]
		GOSUB TextSegmentWidth
		SWAP text$[i], text$
		lineWidth = segWidth
		IF (lineWidth > maxWidth) THEN maxWidth = lineWidth
	NEXT i
	IF (topIndent + width < maxWidth) THEN
		topIndent = topIndent + width
		IF (topIndent + width > maxWidth + maxCharWidth) THEN
			topIndent = maxWidth - width + maxCharWidth
		END IF
		GOSUB CursorXToPos
	END IF
END SUB
'
'
' *****  ScrollHChange
'
SUB ScrollHChange			' top/bottom/max are in pixels
	topSlide = v1
	maxSlide = v3
	IFZ maxSlide THEN maxSlide = 1
'
	maxWidth = topIndent + width
	lastLine = topLine + rows - 1
	IF (lastLine > uText) THEN lastLine = uText
	GOSUB ValidatePosLineLeftTop
'
	pos = -1
	FOR i = topLine TO lastLine
		SWAP text$[i], text$
		GOSUB TextSegmentWidth
		SWAP text$, text$[i]
		lineWidth = segWidth
		IF (lineWidth > maxWidth) THEN maxWidth = lineWidth
	NEXT i
'
	topIndent = maxWidth * topSlide \ maxSlide
	SELECT CASE TRUE
		CASE (topIndent < 0)				: topIndent = 0
		CASE (topIndent > maxWidth)	: topIndent = maxWidth
	END SELECT
'
	IF (topIndent != oldTopIndent) THEN GOSUB CursorXToPos
	stopScrollRedraw = $$TRUE
END SUB
'
'
' *****  ScrollV  *****
'
SUB ScrollV
	select = v2
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	IF (uText < 0) THEN EXIT SUB
	SELECT CASE r1
		CASE #OneLess		: GOSUB ScrollVOneUp
		CASE #SomeLess	: GOSUB ScrollVHalfPageUp
		CASE #MuchLess	: GOSUB ScrollVPageUp
		CASE #OneMore		: GOSUB ScrollVOneDown
		CASE #SomeMore	: GOSUB ScrollVHalfPageDown
		CASE #MuchMore	: GOSUB ScrollVPageDown
		CASE #Change		: GOSUB ScrollVChange
	END SELECT
	GOSUB UpdateSelect
END SUB
'
'
' *****  ScrollVOneUp  *****  Scroll up one line
'
SUB ScrollVOneUp
	IFZ topLine THEN EXIT SUB
	DEC topLine
	GOSUB ValidatePosLineLeftTop
'
	IF (cursorLine > uText) THEN
		yCursorLine = (cursorLine - topLine) * maxCharHeight
		IF (yCursor = yCursorLine) THEN GOSUB CursorXToPos
		EXIT SUB																						' still last line
	END IF
	DEC cursorLine
	GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVOneDown  *****  Scroll down one line
'
SUB ScrollVOneDown
	IF (topLine = uText) THEN EXIT SUB
	INC topLine
	INC cursorLine
	IF (cursorLine > uText) THEN cursorLine = uText
	GOSUB ValidatePosLineLeftTop
	GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVHalfPageUp  *****  Scroll up half page
'
SUB ScrollVHalfPageUp
	IFZ topLine THEN EXIT SUB
	cursorRow = cursorLine - topLine
	IF (rows = 1) THEN
		DEC topLine
	ELSE
		topLine = topLine - (rows >> 1)
	END IF
	IF (topLine < 0) THEN topLine = 0
'
	cursorLine = topLine + cursorRow
	IF (cursorLine > uText) THEN
		cursorLine = uText
		cursorPos = LEN(text$[cursorLine])
		EXIT SUB
	END IF
'
	GOSUB ValidatePosLineLeftTop
	IF (cursorLine != oldCursorLine) THEN GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVPageUp  *****  Scroll up one page
'
SUB ScrollVPageUp
	IFZ topLine THEN EXIT SUB
	cursorRow = cursorLine - topLine
	IF (rows = 1) THEN
		DEC topLine
	ELSE
		topLine = topLine - rows + 1
	END IF
	IF (topLine < 0) THEN topLine = 0
'
	cursorLine = topLine + cursorRow
	IF (cursorLine > uText) THEN
		cursorLine = uText
		cursorPos = LEN(text$[cursorLine])
		EXIT SUB
	END IF
'
	GOSUB ValidatePosLineLeftTop
	IF (cursorLine != oldCursorLine) THEN GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVHalfPageDown  *****  Scroll down half page
'
SUB ScrollVHalfPageDown
	IF (topLine = uText) THEN EXIT SUB
	cursorRow = cursorLine - topLine
	IF (rows = 1) THEN
		INC topLine
	ELSE
		topLine = topLine + (rows >> 1)
	END IF
	IF (topLine > uText) THEN topLine = uText
'
	cursorLine = topLine + cursorRow
	IF (cursorLine > uText) THEN
		cursorLine = uText
		cursorPos = LEN (text$[cursorLine])
	END IF
'
	GOSUB ValidatePosLineLeftTop
	IF (cursorLine != oldCursorLine) THEN GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVPageDown  *****  Scroll down one page (less one line)
'
SUB ScrollVPageDown
	IF (topLine = uText) THEN EXIT SUB
	cursorRow = cursorLine - topLine
	IF (rows = 1) THEN
		INC topLine
	ELSE
		topLine = topLine + rows - 1
	END IF
	IF (topLine > uText) THEN topLine = uText
'
	cursorLine = topLine + cursorRow
	IF (cursorLine > uText) THEN
		cursorLine = uText
		cursorPos = LEN (text$[cursorLine])
	END IF
'
	GOSUB ValidatePosLineLeftTop
	IF (cursorLine != oldCursorLine) THEN GOSUB CursorXToPos
END SUB
'
'
' *****  ScrollVChange  *****
'
SUB ScrollVChange			' top/bottom/max are in pixels
	cursorRow		= cursorLine - topLine
	topSlide	= v1
	maxSlide	= v3
	IFZ maxSlide THEN maxSlide = 1
	topLine		= uText * topSlide / maxSlide
'
	SELECT CASE TRUE
		CASE (topLine < 0)			:	topLine = 0
		CASE (topLine > uText)	:	topLine = uText
	END SELECT
'
	cursorLine = topLine + cursorRow
	IF (cursorLine > uText) THEN
		cursorLine = uText
		cursorPos = LEN (text$[cursorLine])
	END IF
'
	GOSUB ValidatePosLineLeftTop
	IF (cursorLine != oldCursorLine) THEN GOSUB CursorXToPos
	stopScrollRedraw = $$TRUE
END SUB
'
'
' *****  TextDelete  *****  v3 = key : If selected text in grid, delete selected text
'
SUB TextDelete
'	PRINT "TextDelete"
	IF (uText < 0) THEN EXIT SUB
	select = $$SelectCancel												' for Redraw
'
	GOSUB DeleteSelectedText
	IF textDeleted THEN
		GOSUB Redraw
		EXIT SUB
	END IF
'
	IF (v3 = $$KeyBackspace) THEN									' Backspace
		IF cursorPos THEN
			DEC cursorPos
		ELSE
			IFZ cursorLine THEN EXIT SUB
			DEC cursorLine														' combine this and previous line
			cursorPos = LEN(text$[cursorLine])
		END IF
	ELSE																					' Delete
		IF (cursorLine = uText) THEN
			IF (cursorPos >= LEN(text$[cursorLine])) THEN EXIT SUB
		END IF
	END IF
'
	IF (cursorLine > uText) THEN EXIT SUB
	lenText = LEN(text$[cursorLine])
	IF (cursorPos >= lenText) THEN										' combine this and next line
		IF (cursorLine = uText) THEN EXIT SUB
		text$[cursorLine] = text$[cursorLine] + text$[cursorLine + 1]
		DEC uText																				' move lines down
		IF (cursorLine < uText) THEN
			FOR line = cursorLine + 1 TO uText
				SWAP text$[line], text$[line + 1]
			NEXT line
		END IF
		REDIM text$[uText]
		GOSUB ValidatePosLineLeftTop
		GOSUB CursorPosToXY
'
'		Redraw here unless whole screen must be redrawn
'
		IF ((oldTopLine = topLine) AND (oldTopIndent = topIndent)) THEN
			firstLine = cursorLine
			GOSUB DrawLines
		END IF
	ELSE
		SELECT CASE TRUE
			CASE (cursorPos + 2 > lenText)
						text$[cursorLine] = LEFT$(text$[cursorLine], cursorPos)
			CASE (cursorPos = 0)
						text$[cursorLine] = MID$(text$[cursorLine], 2)
			CASE ELSE
						text$[cursorLine] = LEFT$(text$[cursorLine], cursorPos) + MID$(text$[cursorLine], cursorPos + 2)
		END SELECT
		GOSUB ValidatePosLineLeftTop
		GOSUB CursorPosToXY
'
'		Redraw here unless whole screen must be redrawn
'
		IF ((oldTopLine = topLine) AND (oldTopIndent = topIndent)) THEN
			GOSUB RedrawLine
		END IF
	END IF
END SUB
'
'
' *****  TextInsert  *****  Replace any selected text with new text
'
SUB TextInsert
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
'	SELECT CASE TRUE
'		CASE (v3 = $$KeyTab)
'		CASE (v3 = $$KeyEnter)
'		CASE (v3 < 0x20)				: EXIT SUB
'		CASE (v3 > 0x7E)				: EXIT SUB
'	END SELECT
	GOSUB DeleteSelectedText
	SELECT CASE TRUE
		CASE (v3 = $$KeyEnter)												' Add a newLine
			IF (uText < 0) THEN
				DIM text$[1]
				uText = 1
				cursorLine = 1
				cursorPos = 0
				EXIT SELECT
			END IF
			IF (cursorLine > uText) THEN cursorLine = uText
			lenText = LEN(text$[cursorLine])
			SELECT CASE TRUE
				CASE (lenText = 0)
							oldLine$ = ""
							newLine$ = ""
				CASE (cursorPos = 0)
							oldLine$ = ""
							newLine$ = text$[cursorLine]
				CASE (cursorPos >= lenText)
							oldLine$ = text$[cursorLine]
							newLine$ = ""
				CASE ELSE
							oldLine$ = LEFT$(text$[cursorLine], cursorPos)
							newLine$ = MID$(text$[cursorLine], cursorPos + 1)
			END SELECT
			cursorPos = 0
			INC cursorLine
			INC uText
			REDIM text$[uText]
			IF (cursorLine < uText) THEN										' move text up
				line = uText - 1
				DO
					SWAP text$[line], text$[line + 1]
					DEC line
				LOOP WHILE (line >= cursorLine)
			END IF
			text$[cursorLine - 1]	= oldLine$
			text$[cursorLine]			= newLine$
			GOSUB CursorPosToXY
'
'			Redraw here unless whole screen must be redrawn
'
			IF ((oldTopLine = topLine) AND (oldTopIndent = topIndent)) THEN
				firstLine = cursorLine - 1
				GOSUB DrawLines
			END IF
		CASE (v3 < 0x20)
			IF (v3 = $$KeyTab) THEN NEXT CASE
			EXIT SUB
		CASE ELSE
			IF (uText < 0) THEN
				DIM text$[0]
				text$[0] = CHR$(v3)
			ELSE
				IF (cursorLine > uText) THEN cursorLine = uText
				text$[cursorLine] = LEFT$(text$[cursorLine], cursorPos) + CHR$(v3) + MID$(text$[cursorLine], cursorPos + 1)
			END IF
			INC cursorPos
			GOSUB CursorPosToXY
'
'			Redraw here unless whole screen must be redrawn
'
			IF ((oldTopLine = topLine) AND (oldTopIndent = topIndent)) THEN
				firstLine = cursorLine
				IF textDeleted THEN GOSUB DrawLines ELSE GOSUB RedrawLine
			END IF
	END SELECT
'
	select = $$SelectSet
	GOSUB UpdateSelect
END SUB
'
'
' *****  DeleteSelectedText  *****  Put in buffer #0
'
SUB DeleteSelectedText
'	PRINT "DeleteSelectedText"
	XgrGetTextSelectionGrid (@textSelectionGrid)
	IF (grid = textSelectionGrid) THEN
		IF ((begSelectLine != endSelectLine) OR (begSelectPos != endSelectPos)) THEN
			begLine	= begSelectLine
			begPos	= begSelectPos
			endLine	= endSelectLine
			endPos	= endSelectPos
			saveDeletedText = $$TRUE
			GOSUB DeleteTextSegment
			begSelectLine = begLine
			begSelectPos	= begPos
			endSelectLine = begLine
			endSelectPos	= begPos
			XgrSetClipboard (0, $$ClipboardTypeText, @deletedText$, @null[])
		END IF
	END IF
END SUB
'
'
' *****  DeleteTextSegment  *****
'		From begLine/begPos to endLine/endPos
'		Returns beg/end in order
'		saveDeletedText returns deletedText$
'
SUB DeleteTextSegment
'	PRINT "DeleteTextSegment"
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	textDeleted = $$FALSE
	deletedText$ = ""
	IF ((begLine != endLine) OR (begPos != endPos)) THEN
		SELECT CASE TRUE													' set beg before end
			CASE (begLine > endLine)
				temp = begLine:		begLine	= endLine:	endLine = temp
				temp = begPos:		begPos	= endPos:		endPos	= temp
			CASE (begLine = endLine)
				IF (begPos > endPos) THEN
					temp = begPos:	begPos = endPos:		endPos = temp
				END IF
		END SELECT
'
		SELECT CASE TRUE
			CASE (begLine > uText)																		: EXIT SUB
			CASE (begLine = uText) AND (begPos >= LEN(text$[uText]))	: EXIT SUB
		END SELECT
		textDeleted = $$TRUE
'
		IF ((begLine = 0) AND (begPos = 0)) THEN
			IF ((endLine = uText) AND (endPos >= LEN(text$[uText]))) THEN
				IF saveDeletedText THEN
					XstGetNewline (0, @paste)
					IFZ paste THEN nl = $$NewlineDefault
					SELECT CASE nl
						CASE $$NewlineCRLF	: XstStringArrayToStringCRLF (@text$[], @deletedText$)
						CASE ELSE						: XstStringArrayToString (@text$[], @deletedText$)
					END SELECT
					DIM text$[]
					uText = -1
					topLine = 0
					topIndent = 0
					cursorLine = 0
					cursorPos = 0
					xCursor = 0
					yCursor = 0
					EXIT SUB
				END IF
			END IF
		END IF
'
		IF saveDeletedText THEN
			SELECT CASE TRUE
				CASE (begLine = endLine)
							IF (begPos < LEN(text$[begLine])) THEN
								deletedText$ = MID$(text$[begLine], begPos + 1, (endPos - begPos))
							END IF
				CASE ELSE
							XstStringArraySectionToString (@text$[], @copy$, begPos, begLine, endPos, endLine, $$NL)
							ATTACH copy$ TO deletedText$
			END SELECT
		END IF
		a$ = LEFT$(text$[begLine], begPos)
		b$ = ""
		IF (endPos < LEN(text$[endLine])) THEN
			b$ = MID$(text$[endLine], endPos + 1)
		END IF
		text$[begLine] = a$ + b$
		IF (begLine != endLine) THEN
			dLines = (endLine - begLine)
			uText = uText - dLines
			FOR i = begLine + 1 TO uText
				j = i + dLines
				SWAP text$[i], text$[j]
			NEXT i
			REDIM text$[uText]
		END IF
'		cursorLine = begLine
'		cursorPos = begPos
		SELECT CASE TRUE
			CASE (cursorLine < begLine)		' text cursor line unchanged
			CASE (cursorLine = begLine)		: IF (cursorPos > begPos) THEN cursorPos = begPos
			CASE (cursorLine < endLine)		: cursorLine = begLine : cursorPos = begPos
			CASE (cursorLine = endLine)		: cursorLine = begLine : cursorPos = begPos
			CASE (cursorLine > endLine)		: cursorLine = cursorLine - (endLine + begLine)
		END SELECT
		GOSUB CursorPosToXY
	END IF
END SUB
'
'
' *****  TextReplace  *****  deselects text, doesn't change cursor or redraw
'		v0	= begPos
'		v1	= begLine
'		v2	= endPos
'		v3	= endLine
'		r1$	= text string
'
SUB TextReplace
	XgrGetTextSelectionGrid (@textSelectionGrid)
	IF (grid = textSelectionGrid) THEN
		endSelectLine = begSelectLine
		endSelectPos	= begSelectPos
	END IF
	noRedraw = $$TRUE
	begPos	= v0
	begLine	= v1
	endPos	= v2
	endLine	= v3
	saveDeletedText = $$FALSE
	GOSUB DeleteTextSegment
	IFZ r1$ THEN EXIT SUB
	lastChar = r1${UBOUND(r1$)}
	XstStringToStringArray (r1$, @newText$[])
	IFZ text$[] THEN
		ATTACH newText$[] TO text$[]
		uText = UBOUND (text$[])
		EXIT SUB
	END IF
'
	newLines = UBOUND(newText$[])
'
'	Make space in text$[]
'
	IF newLines THEN
		REDIM text$[uText + newLines]
		IF (begLine < uText) THEN
			FOR line = uText TO begLine + 1 STEP -1
				j = line + newLines
				SWAP text$[line], text$[j]
			NEXT line
		END IF
		uText = uText + newLines
	END IF
'
	tail$ = ""
	IF (begPos < LEN(text$[begLine])) THEN
		tail$ = MID$(text$[begLine], begPos + 1)
	END IF
'
	IFZ newLines THEN
		text$[begLine] = LEFT$(text$[begLine], begPos) + newText$[0] + tail$
	ELSE
		text$[begLine] = LEFT$(text$[begLine], begPos) + newText$[0]
		IF (newLines > 1) THEN
			FOR line = 1 TO newLines - 1
				j = begLine + line
				SWAP newText$[line], text$[j]
			NEXT line
		END IF
		IF (lastChar = 10) THEN
			text$[begLine + newLines] = tail$
		ELSE
			text$[begLine + newLines] = newText$[newLines] + tail$
		END IF
	END IF
'
	IF (begLine < topLine) THEN topLine = topLine + newLines
END SUB
'
'
' *****  RedrawMessage  *****
'
SUB RedrawMessage
	GOSUB Redraw
	IFZ stopScrollRedraw THEN GOSUB RedrawScrollH
	IFZ stopScrollRedraw THEN GOSUB RedrawScrollV
END SUB
'
'
' *****  Redraw  *****
'
SUB Redraw
'	PRINT "Redraw"
	u = UBOUND (text$[])
	IF (u != uText) THEN PRINT "TextMessage() : uText error" : uText = u
	redrawn = $$TRUE
	GOSUB EraseOldCursor
	IF (select = $$SelectCancel) THEN
		begSelectLine = endSelectLine
		begSelectPos	= endSelectPos
	END IF
'
	SELECT CASE FALSE
		CASE rows, text$[]
			XgrClearGrid (textGrid, -1)
			GOSUB DrawCursor
			EXIT SUB
	END SELECT
'
	GOSUB PrepForRedraw
	yLine = 0
	FOR line = topLine TO lastLine
		GOSUB DrawLine
		yLine = yLine + maxCharHeight
	NEXT line
'
	IF emptyRows THEN
		XgrGetDrawpoint (textGrid, 0, @y)
		XgrFillBox (textGrid, back, 0, yLine, xLR, yLR)
	END IF
	GOSUB DrawCursor
END SUB
'
'
' *****  RedrawLines  *****
'
SUB RedrawLines
	GOSUB PrepForRedraw
	noRedraw = $$TRUE
	IF (v0 < topLine) THEN firstLine = topLine ELSE firstLine = v0
	IF (v1 < lastLine) THEN lastLine = v1
	IF (lastLine < firstLine) THEN lastLine = firstLine
	GOSUB DrawLines
END SUB
'
'
' *****  DrawLines  *****  Redraw from firstLine to last row only : Not used by XuiList
'
SUB DrawLines
'	PRINT "DrawLines"
	IF (firstLine < topLine) THEN PRINT "TextMessage() : DrawLines : Warning: (firstLine < topLine)"
	redrawn = $$TRUE
	GOSUB EraseOldCursor
'
	SELECT CASE FALSE
		CASE rows, text$[]
			XgrClearGrid (textGrid, -1)
			GOSUB DrawCursor
			EXIT SUB
	END SELECT
'
	GOSUB PrepForRedraw
	yLine = (firstLine - topLine) * maxCharHeight
	FOR line = firstLine TO lastLine
		GOSUB DrawLine
		yLine = yLine + maxCharHeight
	NEXT line
'
	IF emptyRows THEN
		XgrGetDrawpoint (textGrid, 0, @y)
		XgrFillBox (textGrid, back, 0, yLine, xLR, yLR)
	END IF
	GOSUB DrawCursor
END SUB
'
'
' *****  RedrawLine  *****  Redraw cursorLine at yCursor : Not used by XuiList
'
SUB RedrawLine
'	PRINT "RedrawLine"
	redrawn = $$TRUE
	GOSUB EraseOldCursor
'
	SELECT CASE FALSE
		CASE rows, text$[]
			XgrClearGrid (textGrid, -1)
			GOSUB DrawCursor
			EXIT SUB
	END SELECT
'
	GOSUB PrepForRedraw
	yLine = yCursor
	line = cursorLine
	GOSUB DrawLine
	GOSUB DrawCursor
END SUB
'
'
' *****  PrepForRedraw  *****
'
SUB PrepForRedraw
'	PRINT "PrepForRedraw"
	XuiGetColor (textGrid, #GetColor, @back, @draw, 0, 0, 0, 0)
	XuiGetColorExtra (textGrid, #GetColorExtra, @dull, @accent, 0, 0, 0, 0)
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	XuiGetTabArray (grid, #GetTabArray, 0, 0, 0, 0, 0, @tabs[])
	backColor = back
	drawColor = draw
	lastLine = topLine + rows - 1
	IF (lastLine > uText) THEN
		emptyRows = lastLine - uText
		lastLine = uText
	END IF
	IF ((gridType != XuiList) AND (gridType != DirectoryBox) AND (gridType != FileBox)) THEN
		XgrGetTextSelectionGrid (@textSelectionGrid)
		selectionDrawn = $$FALSE
		values[grid,$begLineDrawn] = begSelectLine
		values[grid,$begPosDrawn] = begSelectPos
		values[grid,$endLineDrawn] = endSelectLine
		values[grid,$endPosDrawn] = endSelectPos
		IF (grid = textSelectionGrid) THEN
			IF ((begSelectLine != endSelectLine) OR (begSelectPos != endSelectPos)) THEN
				selectionDrawn = $$TRUE
				begLine = begSelectLine
				begPos = begSelectPos
				endLine = endSelectLine
				endPos = endSelectPos
				SELECT CASE TRUE													' set beg before end
					CASE (begLine > endLine)
						begLine = endLine
						begPos = endPos
						endLine = begSelectLine
						endPos = begSelectPos
					CASE (begLine = endLine)
						IF (begPos > endPos) THEN
							begPos = endPos
							endPos = begSelectPos
						END IF
				END SELECT
			END IF
		END IF
	END IF
END SUB
'
'
' *****  DrawLine  *****  yLine = y coord for line : line = text line #
'
SUB DrawLine
'	PRINT "DrawLine"
	bc = back : dc = draw
	IF (line = cursorLine) THEN
		IF ((gridType = XuiList) OR (gridType = XuiDirectoryBox) OR (gridType = XuiFileBox)) THEN
			XuiGetKeyboardFocus (grid, #GetKeyboardFocus, @kfg, 0, 0, 0, 0, 0)
			IF (grid = kfg) THEN dc = accent ELSE dc = dull
		END IF
	END IF
'
	SWAP text$[line], text$
	IF text$ THEN
		IF (selectionDrawn AND (begLine <= line) AND (line <= endLine)) THEN
			SELECT CASE TRUE
				CASE ((begLine < line) AND (line < endLine))
					XgrMoveTo (textGrid, xib-topIndent, yib+yLine)
					DrawTextSegment (textGrid, @text$, dc, bc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					XgrGetDrawpoint (textGrid, @x, @y)
					IF (x <= xLR) THEN
						XgrFillBox (textGrid, bc, x, y, xLR, y + maxCharHeight - 1)
					END IF
				CASE ((begLine = line) AND (line = endLine))
					a$ = "":  b$ = "":  c$ = ""
					IF (begPos > 0) THEN
						a$ = LEFT$(text$, begPos)
					END IF
					b$ = MID$(text$, begPos + 1, (endPos - begPos))
					IF (endPos < LEN(text$)) THEN
						c$ = MID$(text$, endPos + 1)
					END IF
					XgrMoveTo (textGrid, xib-topIndent, yib+yLine)
					IF a$ THEN DrawTextSegment (textGrid, @a$, bc, dc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					IF b$ THEN DrawTextSegment (textGrid, @b$, dc, bc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					IF c$ THEN DrawTextSegment (textGrid, @c$, bc, dc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					XgrGetDrawpoint (textGrid, @x, @y)
					IF (x <= xLR) THEN
						XgrFillBox (textGrid, bc, x, y, xLR, y + maxCharHeight - 1)
					END IF
				CASE (begLine = line)									' endLine != line
					SELECT CASE TRUE
						CASE (begPos = 0)
							a$ = ""
							b$ = text$
						CASE (begPos > LEN(text$))
							a$ = text$
							b$ = ""
						CASE ELSE
							a$ = LEFT$(text$, begPos)
							b$ = MID$(text$, begPos + 1)
					END SELECT
					XgrMoveTo (textGrid, xib-topIndent, yib+yLine)
					IF a$ THEN DrawTextSegment (textGrid, @a$, bc, dc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					IF b$ THEN DrawTextSegment (textGrid, @b$, dc, bc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					XgrGetDrawpoint (textGrid, @x, @y)
					IF (x <= xLR) THEN
						XgrFillBox (textGrid, bc, x, y, xLR, y + maxCharHeight - 1)
					END IF
				CASE (endLine = line)
					SELECT CASE TRUE
						CASE (endPos = 0)
							a$ = ""
							b$ = text$
						CASE (endPos > LEN(text$))
							a$ = text$
							b$ = ""
						CASE ELSE
							a$ = LEFT$(text$, endPos)
							b$ = MID$(text$, endPos + 1)
					END SELECT
					XgrMoveTo (textGrid, xib-topIndent, yib+yLine)
					IF a$ THEN DrawTextSegment (textGrid, @a$, dc, bc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					IF b$ THEN DrawTextSegment (textGrid, @b$, bc, dc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
					XgrGetDrawpoint (textGrid, @x, @y)
					IF (x <= xLR) THEN
						XgrFillBox (textGrid, bc, x, y, xLR, y + maxCharHeight - 1)
					END IF
			END SELECT
		ELSE
			XgrMoveTo (textGrid, xib-topIndent, yib+yLine)
			DrawTextSegment (textGrid, @text$, bc, dc, xib, yib, topIndent, maxCharHeight, tabWidth, @tabs[])
			XgrGetDrawpoint (textGrid, @x, @y)
			IF (x <= xLR) THEN
				XgrFillBox (textGrid, bc, x, y, xLR, y + maxCharHeight - 1)
			END IF
		END IF
	ELSE
		IF (selectionDrawn AND (begLine <= line) AND (line < endLine)) THEN
			XgrFillBox (textGrid, dc, 0, yLine, xLR, yLine + maxCharHeight - 1)
		ELSE
			XgrFillBox (textGrid, bc, 0, yLine, xLR, yLine + maxCharHeight - 1)
		END IF
	END IF
	SWAP text$, text$[line]
END SUB
'
'
' *****  TextSegmentWidth  *****  Assumes text$ at left margin
'		text$		(unchanged)
'		font
'		pos			(0..;  -1 = use entire text)
'		Handles tabs
'		Returns segWidth
'
SUB TextSegmentWidth
	segWidth = 0
	IFZ text$ THEN EXIT SUB
	IFZ pos THEN EXIT SUB
	tabIndex = INSTR (text$, "\t")
	XuiGetTabWidth (grid, #GetTabWidth, @tabWidth, 0, 0, 0, 0, 0)
	XuiGetTabArray (grid, #GetTabArray, 0, 0, 0, 0, 0, @tabs[])
	IF tabs[] THEN uTab = UBOUND(tabs[])
'
	IFZ tabIndex THEN
		IF (pos < 0) THEN
			XgrGetTextImageSize (font, @text$, 0, 0, @segWidth, 0, 0, 0)
		ELSE
			XgrGetTextImageSize (font, LEFT$(text$, pos), 0, 0, @segWidth, 0, 0, 0)
		END IF
		EXIT SUB
	END IF
	lenSeg = pos
	IF (pos < 0) THEN lenSeg = LEN(text$)
	ii = 1
	DO
		IF (tabIndex > lenSeg) THEN EXIT DO
		IF (tabIndex != ii) THEN
			XgrGetTextImageSize (font, MID$(text$, ii, (tabIndex - ii)), 0, 0, @partWidth, 0, 0, 0)
			segWidth = segWidth + partWidth
			ii = tabIndex
		END IF
		SELECT CASE TRUE
			CASE tabs[]															' tabArray
						xStop = -1
						FOR jj = 0 TO uTab
							IF (segWidth < tabs[jj]) THEN
								xStop = tabs[jj]
								EXIT FOR
							END IF
						NEXT jj
						IF (xStop < 0) THEN NEXT CASE			' beyond list : revert to tabWidth
						segWidth = xStop
			CASE ELSE																' tabWidth
						segWidth = tabWidth * ((segWidth / tabWidth) + 1)
		END SELECT
		INC ii																		' bump the charPointer
		IF (ii > lenSeg) THEN EXIT DO
		tabIndex = INSTR (text$, "\t", ii)
		IFZ tabIndex THEN EXIT DO
	LOOP
	IF (ii <= lenSeg) THEN
		XgrGetTextImageSize (font, MID$(text$, ii, (lenSeg - ii + 1)), 0, 0, @partWidth, 0, 0, 0)
		segWidth = segWidth + partWidth
	END IF
END SUB
'
'
' *****  RedrawScrollH  *****
'
SUB RedrawScrollH
	maxWidth = topIndent + width
	lastLine = topLine + rows - 1
	IF (lastLine > uText) THEN lastLine = uText
	pos = -1
	FOR i = topLine TO lastLine
		SWAP text$[i], text$
		GOSUB TextSegmentWidth
		SWAP text$, text$[i]
		IF (segWidth > maxWidth) THEN maxWidth = segWidth
	NEXT i
	XuiSendToKid (grid, #SetPosition, 0, topIndent, topIndent + width, maxWidth, $ScrollH, 0)
END SUB
'
'
' *****  RedrawScrollV  *****
'
SUB RedrawScrollV
	lastLine = topLine + rows - 1
	IF (lastLine < uText) THEN lastLine = uText
	XuiSendToKid (grid, #SetPosition, 0, topLine, topLine+rows-1, lastLine, $ScrollV, 0)
END SUB
'
'
' *****  EraseOldCursor  *****
'
SUB EraseOldCursor
	IF ((gridType != XuiList) AND (gridType != XuiDirectoryBox) AND (gridType != XuiFileBox)) THEN
		IF values[grid,$cursorShown] THEN
			oldXCursor = values[grid,$xCursorShown]
			oldYCursor = values[grid,$yCursorShown]
			XgrSetGridDrawingMode (textGrid, $$DrawModeXOR, -1, -1)
			x1 = oldXCursor
			y1 = oldYCursor
			x2 = x1
			y2 = y1 + maxCharHeight - 1
			GOSUB CursorOnOff
'			XgrDrawLine (grid, $$White, x1, y1, x2, y2)
			XgrSetGridDrawingMode (textGrid, $$DrawModeCOPY, -1, -1)
		END IF
	END IF
END SUB
'
'
' *****  DrawCursor  *****
'
SUB DrawCursor
	IF ((gridType != XuiList) AND (gridType != XuiDirectoryBox) AND (gridType != XuiFileBox)) THEN
		IF values[grid,$cursorShown] THEN
			XgrSetGridDrawingMode (textGrid, $$DrawModeXOR, -1, -1)
			x1 = xCursor
			y1 = yCursor
			x2 = x1
			y2 = y1 + maxCharHeight - 1
			GOSUB CursorOnOff
'			XgrDrawLine (grid, $$White, x1, y1, x2, y2)
			XgrSetGridDrawingMode (textGrid, $$DrawModeCOPY, -1, -1)
			values[grid,$xCursorShown] = xCursor
			values[grid,$yCursorShown] = yCursor
		END IF
	END IF
END SUB
'
'
' *****  CursorOnOff  *****
'
SUB CursorOnOff
	XuiGetState (grid, #GetState, @state, @keyboard, @mouse, @redraw, 0, 0)
	IFZ (state AND redraw) THEN EXIT SUB
'	XgrGetBackgroundRGB (grid, @r, @g, @b)
'	rr = r : gg = g : bb = b
'	intensity = r + g + b
'	midway = 0x0000FFFF
'	IF (intensity < midway) THEN rr = NOT rr : gg = NOT gg : bb = NOT bb
'	XgrGetDrawingRGB (textGrid, @dr, @dg, @db)
'	XgrSetDrawingRGB (textGrid, rr, gg, bb)
	XgrGetGridColors (textGrid, 0, @d, 0, 0, @dull, 0, 0, 0)
	XgrSetGridColors (textGrid, -1, @dull, -1, -1, -1, -1, -1, -1)
	XgrDrawLine (textGrid, -1, xib+x1-1, yib+y1, xib+x2-1, yib+y2)
	XgrDrawLine (textGrid, -1, xib+x1-2, yib+y1, xib+x2-2, yib+y2)
	XgrSetGridColors (textGrid, -1, @d, -1, -1, -1, -1, -1, -1)
'	XgrSetDrawingRGB (textGrid, dr, dg, db)
END SUB
'
'
' *****  Resize  *****  Resize but do not Redraw
'
SUB Resize
	IF ((xCursor >= v2) OR (yCursor >= v3)) THEN
		xCursor = 0
		yCursor = 0
		cursorLine = topLine
		GOSUB CursorXToPos
	END IF
	noRedraw = $$TRUE
END SUB
'
'
' *****  UpdateSelect  *****
'
SUB UpdateSelect
	SELECT CASE select
		CASE $$SelectCancel
					begSelectLine	= cursorLine
					begSelectPos	= cursorPos
					endSelectLine	= cursorLine
					endSelectPos	= cursorPos
		CASE $$SelectSet
					begSelectLine	= cursorLine
					begSelectPos	= cursorPos
					endSelectLine	= cursorLine
					endSelectPos	= cursorPos
		CASE $$SelectDrag
					endSelectLine	= cursorLine
					endSelectPos	= cursorPos
		CASE $$SelectExtend
					IF ((begSelectLine < endSelectLine) OR ((begSelectLine = endSelectLine) AND (begSelectPos <= endSelectPos))) THEN
						SELECT CASE TRUE
							CASE (cursorLine < begSelectLine)
								begSelectLine	= endSelectLine
								begSelectPos	= endSelectPos
								endSelectLine	= cursorLine
								endSelectPos	= cursorPos
							CASE (cursorLine > endSelectLine)
								endSelectLine	= cursorLine
								endSelectPos	= cursorPos
							CASE (begSelectLine = endSelectLine)		' = cursorLine
								SELECT CASE TRUE
									CASE (cursorPos < begSelectPos)
										begSelectPos = endSelectPos
										endSelectPos = cursorPos
									CASE (cursorPos > endSelectPos)
										endSelectPos = cursorPos
									CASE ELSE
										dBeg = cursorPos - begSelectPos
										dEnd = endSelectPos - cursorPos
										IF (dBeg <= dEnd) THEN
											begSelectPos = endSelectPos
											endSelectPos = cursorPos
										ELSE
											endSelectPos = cursorPos
										END IF
								END SELECT
							CASE (cursorLine = begSelectLine)
								begSelectPos = cursorPos
							CASE (cursorLine = endSelectLine)
								endSelectPos = cursorPos
							CASE ELSE
								dBeg = cursorLine - begSelectLine
								dEnd = endSelectLine - cursorLine
								IF (dBeg <= dEnd) THEN
									begSelectLine	= endSelectLine
									begSelectPos	= endSelectPos
									endSelectLine	= cursorLine
									endSelectPos	= cursorPos
								ELSE
									endSelectLine	= cursorLine
									endSelectPos	= cursorPos
								END IF
						END SELECT
					ELSE
						SELECT CASE TRUE												' endSelect < begSelect
							CASE (cursorLine < endSelectLine)
								endSelectLine	= cursorLine
								endSelectPos	= cursorPos
							CASE (cursorLine > begSelectLine)
								begSelectLine	= endSelectLine
								begSelectPos	= endSelectPos
								endSelectLine	= cursorLine
								endSelectPos	= cursorPos
							CASE (endSelectLine = begSelectLine)		' = cursorLine
								SELECT CASE TRUE
									CASE (cursorPos < endSelectPos)
										endSelectPos = cursorPos
									CASE (cursorPos > begSelectPos)
										begSelectPos = endSelectPos
										endSelectPos = cursorPos
									CASE ELSE
										dEnd = cursorPos - endSelectPos
										dBeg = begSelectPos - cursorPos
										IF (dEnd <= dBeg) THEN
											endSelectPos = cursorPos
										ELSE
											begSelectPos = endSelectPos
											endSelectPos = cursorPos
										END IF
								END SELECT
							CASE (cursorLine = endSelectLine)
								endSelectPos = cursorPos
							CASE (cursorLine = begSelectLine)
								begSelectPos = cursorPos
							CASE ELSE
								dEnd = cursorLine - endSelectLine
								dBeg = begSelectLine - cursorLine
								IF (dEnd <= dBeg) THEN
									endSelectLine	= cursorLine
									endSelectPos	= cursorPos
								ELSE
									begSelectLine	= endSelectLine
									begSelectPos	= endSelectPos
									endSelectLine	= cursorLine
									endSelectPos	= cursorPos
								END IF
						END SELECT
					END IF
	END SELECT
'	PRINT "UpdateSelect: "; begSelectPos, begSelectLine, endSelectPos, endSelectLine, cursorPos, cursorLine
END SUB
'
'
' *****  PokeTextArray  *****
'
SUB PokeTextArray
'	PRINT "PokeTextArray: "; begSelectPos, begSelectLine, endSelectPos, endSelectLine, cursorPos, cursorLine
	ATTACH textArray$[grid, ] TO text$[]
	DIM text$[]
	ATTACH r1$[] TO textArray$[grid, ]
END SUB
'
'
' *****  SetColor  *****
'
SUB SetColor
	XuiSetColor (textGrid, #SetColor, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetColorExtra  *****
'
SUB SetColorExtra
	XuiSetColorExtra (textGrid, #SetColorExtra, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetFocusColor  *****
'
SUB SetFocusColor
	XuiSetFocusColor (textGrid, #SetFocusColor, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetFocusColorExtra  *****
'
SUB SetFocusColorExtra
	XuiSetFocusColorExtra (textGrid, #SetFocusColorExtra, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  SetFont  *****
'
SUB SetFont
	values[grid,$maxCharWidth] = 0			' invalidate maxCharWidth
	values[grid,$maxCharHeight] = 0			' invalidate maxCharHeight
	XuiSetFont (textGrid, #SetFont, v0, v1, v2, v3, 0, @r1$)
END SUB
'
'
' *****  SetFontNumber  *****
'
SUB SetFontNumber
	values[grid,$maxCharWidth] = 0			' invalidate maxCharWidth
	values[grid,$maxCharHeight] = 0			' invalidate maxCharHeight
	XuiSetFontNumber (textGrid, #SetFontNumber, v0, v1, v2, v3, 0, r1)
END SUB
'
'
' *****  ValidatePosLineLeftTop  *****
'
SUB ValidatePosLineLeftTop
	IF (uText < 0) THEN EXIT SUB
	IFZ changer THEN PRINT "TextMessage() : ValidatePosLineLeftTop : changer = 0"
'
' range check cursorPos, cursorLine, topIndent, topLine
'
	IF (cursorLine > uText) THEN cursorLine = uText
	IF (cursorLine < 0) THEN cursorLine = 0
	IF (cursorPos < 0) THEN cursorPos = 0
	IF (topIndent < 0) THEN topIndent = 0
	IF (topLine < 0) THEN topLine = 0
'
' validate topLine
'
	IF (topLine > 0) THEN
		maxTopLine = uText - rows + 2
		IF (topLine > maxTopLine) THEN topLine = maxTopLine
		IF (topLine < 0) THEN topLine = 0
	END IF
'
	SELECT CASE TRUE
		CASE (cursorLine < topLine)
					topLine = cursorLine - (rows >> 1)
		CASE (cursorLine > (topLine + rows - 1))
					IF (gridType = XuiConsole) THEN
						topLine = cursorLine - rows + 1
					ELSE
						topLine = cursorLine - (rows >> 1)
					END IF
	END SELECT
	IF (topLine < 0) THEN topLine = 0
'
' validate cursorPos
'
	lenText = LEN(text$[cursorLine])
	IF (cursorPos > lenText) THEN cursorPos = lenText
'
' validate topIndent (!!! left indent in pixels !!!)
'
	last = topLine + rows - 1
	IF (uText < last) THEN last = uText
'
	pos = -1
	hold$ = ""
	maxPixels = 0
	SWAP hold$, text$
	FOR i = topLine TO last
		ATTACH text$[i] TO text$
		GOSUB TextSegmentWidth
		ATTACH text$ TO text$[i]
		IF (segWidth > maxPixels) THEN maxPixels = segWidth
	NEXT i
	SWAP text$, hold$
	IF (maxPixels < width) THEN
		topIndent = 0
	ELSE
		maxIndent = maxPixels - width + 17
		IF (topIndent > maxIndent) THEN topIndent = maxIndent
	END IF
END SUB
'
'
' *****  Initialize  *****
'
SUB Initialize
	XgrGridTypeNameToNumber (@"XuiDirectoryBox", @XuiDirectoryBox)
	XgrGridTypeNameToNumber (@"XuiFileBox", @XuiFileBox)
	XgrGridTypeNameToNumber (@"XuiConsole", @XuiConsole)
	XgrGridTypeNameToNumber (@"XuiList", @XuiList)
'
	DIM messageNoMod[upperMessage]
	messageNoMod[#GetCursorXY]				= SUBADDRESS (GetCursorXY)
	messageNoMod[#GetTextArray]				= SUBADDRESS (GetTextArray)
	messageNoMod[#GetTextArrayLine]		= SUBADDRESS (GetTextArrayLine)
	messageNoMod[#GetTextArrayBounds]	= SUBADDRESS (GetTextArrayBounds)
	messageNoMod[#GetTextCursor]			= SUBADDRESS (GetTextCursor)
	messageNoMod[#GetTextSelection]		= SUBADDRESS (GetTextSelection)
	messageNoMod[#GrabTextArray]			= SUBADDRESS (GrabTextArray)
	messageNoMod[#HideTextCursor]			= SUBADDRESS (HideTextCursor)
	messageNoMod[#PokeTextArray]			= SUBADDRESS (PokeTextArray)
	messageNoMod[#SetValues]					= SUBADDRESS (SetValues)
	messageNoMod[#ShowTextCursor]			= SUBADDRESS (ShowTextCursor)
	IF messageNoMod[0] THEN PRINT "TextMessage() : undefined message"
'
	DIM messageMod[upperMessage]
	messageMod[#CursorH]							= SUBADDRESS (CursorH)
	messageMod[#CursorV]							= SUBADDRESS (CursorV)
	messageMod[#GetTextPosition]			= SUBADDRESS (GetTextPosition)
	messageMod[#Redraw]								= SUBADDRESS (RedrawMessage)
	messageMod[#RedrawGrid]						= SUBADDRESS (RedrawMessage)
	messageMod[#RedrawLines]					= SUBADDRESS (RedrawLines)
	messageMod[#Resize]								= SUBADDRESS (Resize)
	messageMod[#ScrollH]							= SUBADDRESS (ScrollH)
	messageMod[#ScrollV]							= SUBADDRESS (ScrollV)
	messageMod[#SetColor]							= SUBADDRESS (SetColor)
	messageMod[#SetColorExtra]				= SUBADDRESS (SetColorExtra)
	messageMod[#SetFocusColor]				= SUBADDRESS (SetFocusColor)
	messageMod[#SetFocusColorExtra]		= SUBADDRESS (SetFocusColorExtra)
	messageMod[#SetFont]							= SUBADDRESS (SetFont)
	messageMod[#SetFontNumber]				= SUBADDRESS (SetFontNumber)
	messageMod[#SetTextArray]					= SUBADDRESS (SetTextArray)
	messageMod[#SetTextArrayLine]			= SUBADDRESS (SetTextArrayLine)
	messageMod[#SetTextCursor]				= SUBADDRESS (SetTextCursor)
	messageMod[#SetTextSelection]			= SUBADDRESS (SetTextSelection)
	messageMod[#TextDelete]						= SUBADDRESS (TextDelete)
	messageMod[#TextInsert]						= SUBADDRESS (TextInsert)
	messageMod[#TextReplace]					= SUBADDRESS (TextReplace)
	IF messageMod[0] THEN PRINT "TextMessage() : undefined message"
END SUB
END FUNCTION
'
'
' ###############################
' #####  Raised3DBorder ()  #####
' ###############################
'
FUNCTION  Raised3DBorder (grid, x1, y1, x2, y2)
'
	IF (x1 < x2) THEN
		color = $$LightGrey
		XgrDrawLine (grid, color, x1, y1, x1, y2)
		XgrDrawLine (grid, color, x1, y1, x2, y1)
		color = $$White
		XgrDrawLine (grid, color, x1+1, y1+1, x1+1, y2-2)
		XgrDrawLine (grid, color, x1+1, y1+1, x2-2, y1+1)
		color = $$DarkGrey
		XgrDrawLine (grid, color, x1+1, y2-1, x2-1, y2-1)
		XgrDrawLine (grid, color, x2-1, y1+1, x2-1, y2-2)
		color = $$Black
		XgrDrawLine (grid, color, x1, y2, x2, y2)
		XgrDrawLine (grid, color, x2, y1+1, x2, y2)
	END IF
'
	IF (x1 > x2) THEN
		color = $$LightGrey
		XgrDrawLine (grid, color, x2, y2, x2, y1)
		XgrDrawLine (grid, color, x2, y2, x1, y2)
		color = $$White
		XgrDrawLine (grid, color, x2+1, y2+1, x2+1, y1-2)
		XgrDrawLine (grid, color, x2+1, y2+1, x1-2, y2+1)
		color = $$DarkGrey
		XgrDrawLine (grid, color, x2+1, y1-1, x1-1, y1-1)
		XgrDrawLine (grid, color, x1-1, y2+1, x1-1, y1-2)
		color = $$Black
		XgrDrawLine (grid, color, x2, y1, x1, y1)
		XgrDrawLine (grid, color, x1, y2+1, x1, y1)
	END IF
END FUNCTION
'
'
' #################################
' #####  Recessed3DBorder ()  #####
' #################################
'
FUNCTION  Recessed3DBorder (grid, x1, y1, x2, y2)

	IF (x1 < x2) THEN
		color = $$Black
		XgrDrawLine (grid, color, x1, y1, x1, y2)
		XgrDrawLine (grid, color, x1, y1, x2, y1)
		color = $$DarkGrey
		XgrDrawLine (grid, color, x1+1, y1+1, x1+1, y2-2)
		XgrDrawLine (grid, color, x1+1, y1+1, x2-2, y1+1)
		color = $$LightGrey
		XgrDrawLine (grid, color, x1+1, y2-1, x2-1, y2-1)
		XgrDrawLine (grid, color, x2-1, y1+1, x2-1, y2-2)
		color = $$White
		XgrDrawLine (grid, color, x1, y2, x2-1, y2)
		XgrDrawLine (grid, color, x2, y1, x2, y2)
	END IF
'
	IF (x1 > x2) THEN
		color = $$Black
		XgrDrawLine (grid, color, x2, y2, x2, y1)
		XgrDrawLine (grid, color, x2, y2, x1, y2)
		color = $$DarkGrey
		XgrDrawLine (grid, color, x2+1, y2+1, x2+1, y1-2)
		XgrDrawLine (grid, color, x2+1, y2+1, x1-2, y2+1)
		color = $$LightGrey
		XgrDrawLine (grid, color, x2+1, y1-1, x1-1, y1-1)
		XgrDrawLine (grid, color, x1-1, y2+1, x1-1, y1-2)
		color = $$White
		XgrDrawLine (grid, color, x2, y1, x1-1, y1)
		XgrDrawLine (grid, color, x1, y2, x1, y1)
	END IF
END FUNCTION
'
'
' ###############################
' #####  DrawDottedLine ()  #####
' ###############################
'
' Draw a dotted vertical or horizontal line in selected color
'
FUNCTION  DrawDottedLine (grid, color, x1, y1, x2, y2)

	IF (x1 == x2) THEN
		IF (y1 > y2) THEN s = -2 ELSE s = 2
		FOR y = y1 TO y2 STEP s
			x = x1
			XgrDrawPoint (grid, color, x, y)
		NEXT y
	END IF
'
	IF (y1 == y2) THEN
		IF (x1 > x2) THEN s = -2 ELSE s = 2
		FOR x = x1 TO x2 STEP s
			y = y1
			XgrDrawPoint (grid, color, x, y)
		NEXT x
	END IF
END FUNCTION
'
'
' ##############################
' #####  DrawDottedBox ()  #####
' ##############################
'
FUNCTION  DrawDottedBox (grid, color, x1, y1, x2, y2)
'
	DrawDottedLine (grid, color, x1, y1, x2, y1)
	DrawDottedLine (grid, color, x1, y2, x2, y2)
	DrawDottedLine (grid, color, x1, y1, x1, y2)
	DrawDottedLine (grid, color, x2, y1, x2, y2)
END FUNCTION
'
'
' ##############################
' #####  Erase3DBorder ()  #####
' ##############################
'
FUNCTION  Erase3DBorder (grid, color, x1, y1, x2, y2)
'
	IF (x1 < x2) THEN
		XgrDrawLine (grid, color, x1, y1, x1, y2)
		XgrDrawLine (grid, color, x1, y1, x2, y1)

		XgrDrawLine (grid, color, x1+1, y1+1, x1+1, y2-2)
		XgrDrawLine (grid, color, x1+1, y1+1, x2-2, y1+1)

		XgrDrawLine (grid, color, x1+1, y2-1, x2-1, y2-1)
		XgrDrawLine (grid, color, x2-1, y1+1, x2-1, y2-2)

		XgrDrawLine (grid, color, x1, y2, x2, y2)
		XgrDrawLine (grid, color, x2, y1+1, x2, y2)
	END IF
'
	IF (x1 > x2) THEN
		XgrDrawLine (grid, color, x2, y2, x2, y1)
		XgrDrawLine (grid, color, x2, y2, x1, y2)

		XgrDrawLine (grid, color, x2+1, y2+1, x2+1, y1-2)
		XgrDrawLine (grid, color, x2+1, y2+1, x1-2, y2+1)

		XgrDrawLine (grid, color, x2+1, y1-1, x1-1, y1-1)
		XgrDrawLine (grid, color, x1-1, y2+1, x1-1, y1-2)

		XgrDrawLine (grid, color, x2, y1, x1, y1)
		XgrDrawLine (grid, color, x1, y2+1, x1, y1)
	END IF
END FUNCTION
'
'
' ##############################
' #####  FillDottedBox ()  #####
' ##############################
'
FUNCTION  FillDottedBox (grid, color, x1, y1, x2, y2)

	oddOrEven = ABS(x2-x1) MOD 2

	IFZ oddOrEven THEN
		IF (x2 > x1) THEN
			FOR x = x1 TO x2 STEP 2
				DrawDottedLine (grid, color, x, y1, x, y2)
			NEXT x
			FOR x = x1+1 TO x2-1 STEP 2
				DrawDottedLine (grid, color, x, y1+1, x, y2)
			NEXT x
		END IF

		IF (x1 > x2) THEN
			FOR x = x1 TO x2 STEP -2
				DrawDottedLine (grid, color, x, y1, x, y2)
			NEXT x
			FOR x = x1-1 TO x2+1 STEP -2
				DrawDottedLine (grid, color, x, y1-1, x, y2)
			NEXT x
		END IF
	ELSE
		IF (x2 > x1) THEN
			FOR x = x1 TO x2 STEP 2
				DrawDottedLine (grid, color, x, y1, x, y2)
				DrawDottedLine (grid, color, x+1, y1+1, x+1, y2)
			NEXT x
		END IF

		IF (x1 > x2) THEN
			FOR x = x1 TO x2 STEP -2
				DrawDottedLine (grid, color, x, y1, x, y2)
				DrawDottedLine (grid, color, x-1, y1-1, x-1, y2)
			NEXT x
		END IF
	END IF
END FUNCTION
'
'
' #########################
' #####  DrawArc2 ()  #####
' #########################
'
FUNCTION  DrawArc2 (grid, color, x, y, radius, start, end)
	STATIC SINGLE pi, rtd

	s = 2
	IF ((end - start) < 0) THEN
		temp = end
		end = start - 360
		start = temp
		s = -s
	END IF

	FOR theta = start TO end STEP s
		xset = radius * SIN(theta * $$DEGTORAD) + x
		yset = radius * COS(theta * $$DEGTORAD) + y
		XgrDrawPoint (grid, color, xset, yset)
	NEXT theta
END FUNCTION
END PROGRAM
